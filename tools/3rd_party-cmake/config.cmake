# ****************************************************************************
# CUI
#
# The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
#
# The use, dissemination or disclosure of data in this file is subject to
# limitation or restriction. See accompanying README and LICENSE for details.
# ****************************************************************************
# Configure the 3rd_party directory
# use one of these if it exists:
#     /local/swdev/3rd_party
#     c:/swdev/3rd_party
#     ENV: SWDEV_THIRD_PARTY_PATH
#
# otherwise, use ../3rd_party

# do not create a default third party root folder
# if one has already been specified
if(NOT EXISTS "${SWDEV_THIRD_PARTY_ROOT}")
   SET(DEFAULT_THIRD_PARTY_ROOT)
   if(EXISTS $ENV{SWDEV_THIRD_PARTY_PATH})
      set(DEFAULT_THIRD_PARTY_ROOT "$ENV{SWDEV_THIRD_PARTY_PATH}")
   elseif(EXISTS "${CMAKE_CURRENT_LIST_DIR}/../3rd_party")
      set(DEFAULT_THIRD_PARTY_ROOT "${CMAKE_CURRENT_LIST_DIR}/../3rd_party")
   elseif(EXISTS "${CMAKE_CURRENT_LIST_DIR}/../../3rd_party")
      set(DEFAULT_THIRD_PARTY_ROOT "${CMAKE_CURRENT_LIST_DIR}/../../3rd_party")
   elseif(EXISTS "${CMAKE_CURRENT_LIST_DIR}/../../../3rd_party")
      set(DEFAULT_THIRD_PARTY_ROOT "${CMAKE_CURRENT_LIST_DIR}/../../../3rd_party")
   else()
      # Use cmake build directory as default location for per-build isolation
     set(DEFAULT_THIRD_PARTY_ROOT "${CMAKE_BINARY_DIR}/3rd_party")
      # Generate the 3rd_party directory if it doesn't yet exist
      if(NOT EXISTS "${DEFAULT_THIRD_PARTY_ROOT}")
         file(MAKE_DIRECTORY "${DEFAULT_THIRD_PARTY_ROOT}")
      endif()
   endif()

   set(SWDEV_THIRD_PARTY_ROOT ${DEFAULT_THIRD_PARTY_ROOT} CACHE PATH "Directory into which 3rd-party packages will be unpacked")
endif()

if(NOT EXISTS "${SWDEV_THIRD_PARTY_ROOT}")
   message(FATAL_ERROR "SWDEV_THIRD_PARTY_ROOT does not exist: ${SWDEV_THIRD_PARTY_ROOT}")
endif()

set(SWDEV_THIRD_PARTY_BRANCH ${SWDEV_BASE_BRANCH})

get_filename_component(CURRENT_LIST_DIR ${CMAKE_CURRENT_LIST_FILE} PATH)
include(${CURRENT_LIST_DIR}/shared.cmake)

if(NOT SWDEV_THIRD_PARTY_PACKAGE_SOURCES)
   # An initial search path is not expected to normally be defined, but
   # provides a hook for a developer or build system to specify alternate
   # layouts without requiring source modification.
   if(NOT SWDEV_THIRD_PARTY_SEARCHPATH)
      if(WIN32)
         list(APPEND SWDEV_THIRD_PARTY_SEARCHPATH "//sllabl1/data/3rd_party/${SWDEV_THIRD_PARTY_BRANCH}")
         list(APPEND SWDEV_THIRD_PARTY_SEARCHPATH "//homer/l1r/data/3rd_party/${SWDEV_THIRD_PARTY_BRANCH}")
      else()
         list(APPEND SWDEV_THIRD_PARTY_SEARCHPATH "/data/3rd_party/${SWDEV_THIRD_PARTY_BRANCH}")
      endif()
      list(APPEND SWDEV_THIRD_PARTY_SEARCHPATH "${afsim_SOURCE_DIR}/../dependencies/3rd_party")
   endif()

   foreach(PATHDIR IN LISTS SWDEV_THIRD_PARTY_SEARCHPATH)
      if(IS_DIRECTORY "${PATHDIR}")
         get_filename_component(FOUND_SWDEV_THIRD_PARTY_SOURCE "${PATHDIR}" ABSOLUTE)
         break()
      endif()
   endforeach()

   if(FOUND_SWDEV_THIRD_PARTY_SOURCE)
      set(SWDEV_THIRD_PARTY_PACKAGE_SOURCES "${FOUND_SWDEV_THIRD_PARTY_SOURCE}" CACHE
         PATH "The source directory used for locating prebuilt 3rd party packages.")
   else()
      message("Unable to detect a source location for 3rd party packages. Assuming unpacked libraries exist in ${SWDEV_THIRD_PARTY_ROOT}.")
   endif()
endif()

macro(swdev_find_package_source FULL_PATH PKGNAME PKGFILE)
   foreach(SRCPATH ${SWDEV_THIRD_PARTY_PACKAGE_SOURCES})
      foreach(pathOption ${SRCPATH}/${PKGNAME}/${PKGFILE};${SRCPATH}/${PKGFILE})
         if(EXISTS ${pathOption})
            set(${FULL_PATH} ${pathOption})
         endif()
      endforeach()
   endforeach()
endmacro()

# find, download, extract, and configure 3rd party packages
# EXE_TARGET_DIRECTORY specifies the directory for the executable target that will need the 3rd party packages.
# For an executable target calling this macro for itself (e.g. wizard), this argument should be the same
# directory passed to 'create_vs_debug_env', e.g. ${CMAKE_CURRENT_SOURCE_DIR}.
# For a library target that has 3rd party dependencies but may be linked into any executable target, e.g. as a
# plugin, use "" (empty string).
macro(swdev_acquire_packages EXE_TARGET_DIRECTORY)
   message(VERBOSE "Acquiring 3rd party packages ${ARGN} for project ${PROJECT_NAME}...")
   set(packagesFound 0)
   set(packagesNotUpdatable 0)
   foreach(arg ${ARGN})
      foreach(pkg ${arg})
         get_property(${pkg}_ACQUIRED GLOBAL PROPERTY ${pkg}_ACQUIRED SET)
         if (NOT ${pkg}_ACQUIRED)
            set_property(GLOBAL PROPERTY ${pkg}_ACQUIRED TRUE)
            string(REGEX MATCH "([^-]*).*" pkgNameMatch "${pkg}")
            if(NOT pkgNameMatch)
               message(FATAL_ERROR "Third party package: ${pkg} cannot determine package name")
            endif()
            set(pkgBaseName ${CMAKE_MATCH_1})
            set_property(GLOBAL PROPERTY ${pkg}_BASE_NAME ${pkgBaseName})
            set(ARCH_SUFFIX -x86)
            if(ARCH_64)
               set(ARCH_SUFFIX -x64)
            endif()
            #message("ARCH: ${ARCH_64}  ${ARCH_SUFFIX}")
            if(WIN32)
               set(SYS_SUFFIXES "-${SWDEV_SYS_SUFFIX}")
            else()
               set(SYS_SUFFIXES "-rh6" "-fc6" "-lnx")
            endif()
            set(pkgPath)
            set(pkgfile)
            foreach(sys ${SYS_SUFFIXES})
               set(pkgname ${pkg}${ARCH_SUFFIX}${sys})
               # Search multiple package formats natively unpackable by CMake.
               # File types are in order of precedence, the first match found is used.
               foreach(pkgExt tar.gz;tar;zip)
                  set(pkgfile "${pkgname}.${pkgExt}")
                  swdev_find_package_source(pkgPath ${pkgBaseName} ${pkgfile})
                  if(pkgPath)
                     break()
                  endif()
               endforeach()
               if(pkgPath)
                  break()
               endif()
            endforeach()
            set_property(GLOBAL PROPERTY ${pkg}_NAME ${pkgname})
            set(usingPackage FALSE)
            if(NOT pkgPath)
               if(EXISTS ${SWDEV_THIRD_PARTY_ROOT}/${pkgname})
                  # Found package already on system
                  # don't warn here
                  math(EXPR packagesNotUpdatable "${packagesNotUpdatable}+1")
                  set(usingPackage TRUE)
               else()
                  message(WARNING "Cannot locate package ${pkg}")
               endif()
            else()
               set(usingPackage TRUE)
               set(getPackage FALSE)
               set(REMOTE_CHECKSUM "")
               set(LOCAL_CHECKSUM "0")
               if (EXISTS "${SWDEV_THIRD_PARTY_ROOT}/${pkgfile}.sha512")
                  if(EXISTS "${pkgPath}.sha512")
                     file(READ "${pkgPath}.sha512" REMOTE_CHECKSUM)
                  else()
                     message(STATUS "Calculating SHA512 hash for: ${pkgPath}")
                     file(SHA512 "${pkgPath}" REMOTE_CHECKSUM)
                  endif()
                  file(READ ${SWDEV_THIRD_PARTY_ROOT}/${pkgfile}.sha512 LOCAL_CHECKSUM)
                  if (NOT "${LOCAL_CHECKSUM}" STREQUAL "${REMOTE_CHECKSUM}")
                     message(STATUS "${pkgname} different than installed version. Fetching new version.")
                     set(getPackage TRUE)
                  endif()
               else()
                  set(getPackage TRUE)
               endif()
               if (getPackage)
                  message("Installing package: ${pkgPath} to ${SWDEV_THIRD_PARTY_ROOT}")
                  execute_process(COMMAND ${CMAKE_COMMAND} -E remove_directory "${SWDEV_THIRD_PARTY_ROOT}/${pkgname}")
                  execute_process(COMMAND ${CMAKE_COMMAND} -E make_directory "${SWDEV_THIRD_PARTY_ROOT}/${pkgname}")
                  execute_process(COMMAND ${CMAKE_COMMAND} -E tar xzf "${pkgPath}" WORKING_DIRECTORY "${SWDEV_THIRD_PARTY_ROOT}/${pkgname}")
                  if(NOT "${REMOTE_CHECKSUM}")
                     file(SHA512 "${pkgPath}" REMOTE_CHECKSUM)
                  endif()
                  file(WRITE "${SWDEV_THIRD_PARTY_ROOT}/${pkgfile}.sha512" "${REMOTE_CHECKSUM}")
               endif()
            endif()
         else()
            message(VERBOSE "Package ${pkg} already acquired...skipping")
            set(usingPackage TRUE)
            get_property(pkgBaseName GLOBAL PROPERTY ${pkg}_BASE_NAME)
            get_property(pkgname GLOBAL PROPERTY ${pkg}_NAME)
         endif()
         if (usingPackage)
            set(${pkgBaseName}_ROOT_DIR "${SWDEV_THIRD_PARTY_ROOT}/${pkgname}")
            include("${CURRENT_LIST_DIR}/${pkg}.cmake")
            if ("${EXE_TARGET_DIRECTORY}" STREQUAL "")
               set_property(GLOBAL APPEND PROPERTY SWDEV_ALL_PACKAGES_USED ${pkgBaseName})
            else()
               set_property(DIRECTORY ${EXE_TARGET_DIRECTORY} APPEND PROPERTY SWDEV_ALL_PACKAGES_USED ${pkgBaseName})
            endif()
         endif()
      endforeach()
   endforeach()
   if(NOT "${packagesNotUpdatable}" STREQUAL "0")
      message(VERBOSE "Using ${packagesNotUpdatable} local packages, can't check for updates")
   endif()
   if(NOT "${packagesFound}" STREQUAL "0")
      message(VERBOSE "${packagesFound} 3rd party packages were already up to date")
   endif()
endmacro()

macro(swdev_package_include_directories TARGET)
   foreach(arg ${ARGN})
      foreach(pkg ${arg})
         string(REGEX MATCH "([^-]*).*" pkgNameMatch "${pkg}")
         if(NOT pkgNameMatch)
            message(FATAL_ERROR "Third party package: ${pkg} cannot determine package name")
         endif()
         set(pkgBaseName ${CMAKE_MATCH_1})
         if (DEFINED ${pkgBaseName}_INCLUDE_DIR)
            target_include_directories(${TARGET} PUBLIC ${${pkgBaseName}_INCLUDE_DIR})
         endif()
      endforeach()
   endforeach()
endmacro()

macro(swdev_package_link_libraries TARGET)
   foreach(arg ${ARGN})
      foreach(pkg ${arg})
         string(REGEX MATCH "([^-]*).*" pkgNameMatch "${pkg}")
         if(NOT pkgNameMatch)
            message(FATAL_ERROR "Third party package: ${pkg} cannot determine package name")
         endif()
         set(pkgBaseName ${CMAKE_MATCH_1})
         if (DEFINED ${pkgBaseName}_LIBRARY)
            target_link_libraries(${TARGET} ${${pkgBaseName}_LIBRARY})
         else()
            if(DEFINED ${pkgBaseName}_LIBRARY_DEBUG)
               target_link_libraries(${TARGET} debug ${${pkgBaseName}_LIBRARY_DEBUG})
            elseif(DEFINED ${pkgBaseName}_LIBRARY_RELEASE)
               target_link_libraries(${TARGET} release ${${pkgBaseName}_LIBRARY_RELEASE})
            else()
               message("Could not find a library definition to link ${TARGET} to ${pkgBaseName}")
            endif()
         endif()
      endforeach()
   endforeach()
endmacro()

# Todo: this is fairly difficult in cMake because you can't call a macro given a macro-name in a string
#         and the install() command doesn't support multiple 'FILES' commands for instance
#macro(swdev_package_install)
#   foreach(arg ${ARGN})
#      foreach(pkg ${arg})
#         string(REGEX MATCH "([^-]*).*" pkgNameMatch "${pkg}")
#         if(NOT pkgNameMatch)
#            message(FATAL_ERROR "Third party package: ${pkg} cannot determine package name")
#         endif()
#         set(pkgBaseName ${CMAKE_MATCH_1})
#         if (DEFINED ${pkgBaseName}_INSTALL_FILES)
#            set(INSTALL_CMD)
#            foreach(WORD ${${pkgBaseName}_INSTALL_FILES})
#               message("${INSTALL_CMD}")
#               if(${WORD} STREQUAL FILES)
#                  if(INSTALL_CMD)
#                     message("DOINSTALL: ${INSTALL_CMD}")
#                     install(${INSTALL_CMD})
#                  endif()
#                  set(INSTALL_CMD ${WORD})
#               else()
#                  list(APPEND INSTALL_CMD ${WORD})
#               endif()
#            endforeach()
#            if(INSTALL_CMD)
#                     message("DOINSTALL: ${INSTALL_CMD}")
#               install(${INSTALL_CMD})
#            endif()
#         endif()
#      endforeach()
#   endforeach()
#endmacro()
