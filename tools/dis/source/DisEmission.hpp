// ****************************************************************************
// CUI
//
// The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
//
// Copyright 2003-2015 The Boeing Company. All rights reserved.
//
// The use, dissemination or disclosure of data in this file is subject to
// limitation or restriction. See accompanying README and LICENSE for details.
// ****************************************************************************
// ****************************************************************************
// Updated by Infoscitex, a DCS Company.
// ****************************************************************************

#ifndef DISEMISSION_HPP
#define DISEMISSION_HPP

#include "dis_export.h"

#include "DisEntityId.hpp"
#include "DisEventId.hpp"
#include "DisPdu.hpp"
#include "DisPtrContainer.hpp"
#include "DisSystem.hpp"

class DisSystem;
class GenI;
class GenO;

class DIS_EXPORT DisEmission : public DisPdu
{
public:
   //! Default Constructor
   DisEmission();
   //! Copy Constructor
   DisEmission(const DisEmission& aSrc);
   //! Partial Stream Constructor
   /*!
    *  This constructor builds the Emissions PDU from the stream, but uses
    *  an already unpacked DIS PDU Header to initialize this PDU's header.
    *
    *  \param[in] aPdu  Unpacked PDU Header for this PDU
    *  \param[in] aGenI Stream with the data for the body of this PDU
    */
   DisEmission(DisPdu& aPdu, GenI& aGenI);
   //! Stream Constructor
   DisEmission(GenI& aGenI);
   //! Destructor
   ~DisEmission() override = default;

   //! Creates an exact copy of this PDU.
   /*!
    *  \note The caller is responsible for managing the memory created by this
    *        method.
    */
   DisPdu* Clone() const override;

   //! Return the Dis PDU Type for an Emissions PDU
   int GetClass() const override;
   //! Return the Entity ID associated with the sending of this PDU.
   /*!
    *  \note This returns the same result as GetEmittingEntityId()
    */
   const DisEntityId& GetOriginatingEntity() const override;


   // Accessors
   //! Emitting Entity ID
   /*!
    *  This field shall iftity the entity that is the source of the emissions.
    */
   const DisEntityId& GetEmittingEntityId() const;
   //! Event ID
   /*!
    *  This field shall contain an identification generated by the issuing
    *  simulation application to associate related events.
    */
   const DisEventId& GetEventId() const;
   //! State Update Indicator
   /*!
    *  Use of this field is optional.  This field enumerates whether the
    *  issuance of this PDU was due to a state change or a heartbeat update.
    */
   DisEnum8 GetStateUpdateIndicator() const;
   //! Number Of Systems
   /*!
    *  This field shall specify the number of emitter systems described in the
    *  current PDU.
    */
   DisUint8 GetNumberOfSystems() const;
   //! Reported Number Of Systems
   /*!
    *  If this DisEmission was read in from a buffer, this function returns
    *  the Number of Systems reported within that buffer.  If this DisEmission
    *  was not read from a buffer, then the value will be either 0 or the
    *  value from the previous read from a buffer.
    *  \note
    *     This value is not the actual Number of Systems, if you desire the
    *     actual value, use GetNumberOfSystems() instead
    */
   DisUint8 GetReportedNumberOfSystems() const;

   // Mutators
   void SetEmittingEntityId(const DisEntityId& aEntityId);
   void SetEventId(const DisEventId& aEventId);
   void SetStateUpdateIndicator(DisEnum8 aSUI);

   //! Returns the length of this PDU, as it would be sent over the wire in
   //! octets.
   DisUint16 GetLengthOctets() const;

   // Input/Output
   //! To implement virtual, call const GetLengthOctets();
   DisUint16 GetLength() override;

   void        Get(GenI& aGenI) override;
   void        Put(GenO& aGenO) override;
   void        Stream(std::ostream& aStream) const override;
   std::string ToString() const override;

   // Data Validation
   bool IsValid() const override;

   // System list maintenance...
   //! Helper function to determine if a new system could be added to this PDU
   /*!
    *  This will test to see if a system can be added to this Emission PDU.
    *  \note If aSystem is null, a best case assumption of a single beam with
    *        no track/jam targets will be made.
    */
   bool CanAddSystem(DisSystem* aSystem) const;
   //! Add Emitter System to Emissions PDU
   /*!
    *  If the supplied emitter system can be added to this Emissions PDU without
    *  going over MAX_PDU_SIZE_OCTETS, then the System will be added.
    *
    *  \return true if the system was added
    *
    *  \warn This Emissions PDU takes ownership of the DisSystem's memory
    */
   bool AddSystem(DisSystem* aSystem);

   // Return iterators to DisSystem vector.
   std::vector<DisSystem*>::iterator       GetSystemBegin();
   std::vector<DisSystem*>::const_iterator GetSystemBegin() const;
   std::vector<DisSystem*>::iterator       GetSystemEnd();
   std::vector<DisSystem*>::const_iterator GetSystemEnd() const;

   // Remove and delete a DisSystem object from the list.
   // If successful, return a positive number, if not return a zero.
   // Warning: This function only removes the first System on the list.
   unsigned int RemoveSystem(DisSystem* aSystem);

   // Remove and delete all DisSystem objects from the list.
   void RemoveAllSystems();

   // Remove DisSystem object from the list, but DO NOT DELETE the object.
   // If successful, return a positive number, if not return a zero.
   // Warning: This function only removes the first System on the list.
   unsigned int RemoveSystemWithNoDelete(DisSystem* aSystem);

   // Remove all DisSystem objects from the list, but DO NOT DELETE them.
   void RemoveAllSystemsWithNoDelete();

   //! Deprecated, use enumerations in DisEmissionEnums.hpp
   enum
   {
      StateUpdate       = 0,
      ChangedDataUpdate = 1
   };

private:
   //! Helper function to read Contents of the Emissions PDU from a stream
   /*!
    *  \note Excludes reading of the PDU Header
    */
   void GetMemberData(GenI& aGenI);

   // Disallow assignment
   DisEmission& operator=(const DisEmission& aRhs);
   /*!
    * Identifies the entity that is the source of the emissions
    */
   DisEntityId mEmittingEntityId;
   /*!
    * Contains an identification generated by the issuing simulation application to
    * associate related events.
    */
   DisEventId mEventId;
   /*!
    * Optional field if not used, set to heartbeat update
    */
   DisEnum8 mStateUpdateIndicator;
   /*!
    * The number of systems associated with this PDU
    */
   DisUint8 mReportedNumberOfSystems;
   /*!
    * The list of systems associated with this PDU
    */
   DisPtrContainer<DisSystem> mSystemList;
};

// Accessors
inline const DisEntityId& DisEmission::GetOriginatingEntity() const
{
   return GetEmittingEntityId();
}
inline const DisEntityId& DisEmission::GetEmittingEntityId() const
{
   return mEmittingEntityId;
}
inline const DisEventId& DisEmission::GetEventId() const
{
   return mEventId;
}
inline DisEnum8 DisEmission::GetStateUpdateIndicator() const
{
   return mStateUpdateIndicator;
}
inline DisUint8 DisEmission::GetNumberOfSystems() const
{
   return static_cast<DisUint8>(mSystemList.GetSize());
}
inline DisUint8 DisEmission::GetReportedNumberOfSystems() const
{
   return mReportedNumberOfSystems;
}

// Mutators
inline void DisEmission::SetEmittingEntityId(const DisEntityId& aEntityId)
{
   mEmittingEntityId = aEntityId;
}
inline void DisEmission::SetEventId(const DisEventId& aEventId)
{
   mEventId = aEventId;
}
inline void DisEmission::SetStateUpdateIndicator(DisEnum8 aSUI)
{
   mStateUpdateIndicator = aSUI;
}

inline DisUint16 DisEmission::GetLength()
{
   return GetLengthOctets();
}

// System list methods
inline std::vector<DisSystem*>::iterator DisEmission::GetSystemBegin()
{
   return mSystemList.GetBegin();
}

inline std::vector<DisSystem*>::const_iterator DisEmission::GetSystemBegin() const
{
   return mSystemList.GetBegin();
}

inline std::vector<DisSystem*>::iterator DisEmission::GetSystemEnd()
{
   return mSystemList.GetEnd();
}

inline std::vector<DisSystem*>::const_iterator DisEmission::GetSystemEnd() const
{
   return mSystemList.GetEnd();
}

inline unsigned int DisEmission::RemoveSystem(DisSystem* aSystem)
{
   return mSystemList.Remove(aSystem);
}

inline void DisEmission::RemoveAllSystems()
{
   mSystemList.RemoveAll();
}

#endif
