// ****************************************************************************
// CUI
//
// The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
//
// Copyright 2003-2014 The Boeing Company. All rights reserved.
//
// The use, dissemination or disclosure of data in this file is subject to
// limitation or restriction. See accompanying README and LICENSE for details.
// ****************************************************************************

#include "UtQtGL2DPlot.hpp"

#include <cassert>
#include <cfloat> // DBL_MAX on Linux

#include <QAbstractItemModel>
#include <QApplication>
#include <QFile>
#include <QMatrix4x4>
#include <QVector3D>
#include <QtMath>

#include "UtCast.hpp"
#include "UtQtInitResources.hpp"
#include "UtQtMemory.hpp"
#include "UtQtTextureTGA.hpp"

int UtQtGL2DPlot::overlay::mCount = 1;

namespace
{
double SampleRange(int aIndex)
{
   // Returns the sequence:
   //   (.5 interval)   (.25 interval)                (.125 interval)
   // 0.25, 0.75,       0.125, 0.375, 0.625, 0.875,   0.0625, 0.1875, 0.3125, 0.4375, 0.5625, 0.6875, 0.8125, 0.9375, ...
   //
   // This samples a range at regular intervals that get more fine as index increases,
   // and never returns the same number, until precision is exhausted
   double interval = 0.5;
   int    idx      = aIndex;
   for (int rangeI = 2; true; rangeI *= 2)
   {
      if (idx < rangeI)
      {
         return interval * idx + interval * 0.5;
      }
      idx -= rangeI;
      interval *= 0.5;
   }
}

int SampleRangeOctave(int aIndex)
{
   int octave = 1;
   int idx    = aIndex;
   for (int rangeI = 2; true; rangeI *= 2)
   {
      if (idx < rangeI)
      {
         return octave;
      }
      idx -= rangeI;
      ++octave;
   }
}

QColor GetAutoGeneratedColor(int aSeriesNumber)
{
   // pick a pre-selected color
   switch (aSeriesNumber)
   {
   case 0:
      return QApplication::palette().color(
         QPalette::WindowText); // ask the palette for the text color (should provide some contrast)
   case 1:
      return QColor(0, 255, 255); // Aqua
   case 2:
      return QColor(0, 0, 255); // Blue
   case 3:
      return QColor(255, 0, 255); // Fuschia
   case 4:
      return QColor(128, 128, 128); // Gray
   case 5:
      return QColor(0, 128, 0); // Green
   case 6:
      return QColor(0, 255, 0); // Lime
   case 7:
      return QColor(128, 0, 0); // Maroon
   case 8:
      return QColor(0, 0, 128); // Navy
   case 9:
      return QColor(128, 128, 0); // Olive
   case 10:
      return QColor(128, 0, 128); // Purple
   case 11:
      return QColor(255, 0, 0); // Red
   case 12:
      return QColor(192, 192, 192); // Silver
   }
   // create a new color
   float lightness  = 0.4f;
   float hue        = SampleRange(aSeriesNumber);
   float saturation = SampleRange(SampleRangeOctave(aSeriesNumber));
   saturation       = saturation * 0.45f + 0.5f;
   QColor c;
   c.setHslF(hue, saturation, lightness);
   return c;
}
} // namespace

UtQtGL2DPlot::UtQtGL2DPlot()
{
   ClearPlotBackground();
}

UtQtGL2DPlot::~UtQtGL2DPlot()
{
   for (auto&& it : mData)
   {
      SeriesBase* sb = it.second;
      delete sb;
   }
   mData.clear();
}

void UtQtGL2DPlot::Initialize()
{
   // This is required to initialize the resources when statically linking utilqt
   initUtQtResources();
}

void UtQtGL2DPlot::SetWindowSize(int aWidth, int aHeight)
{
   mDisplayWidth  = aWidth;
   mDisplayHeight = aHeight;
}

void UtQtGL2DPlot::Reset()
{
   mMinXBoundary  = std::numeric_limits<double>::max();
   mMinYBoundary  = std::numeric_limits<double>::max();
   mMinYBoundary2 = std::numeric_limits<double>::max();
   mMaxXBoundary  = std::numeric_limits<double>::lowest();
   mMaxYBoundary  = std::numeric_limits<double>::lowest();
   mMaxYBoundary2 = std::numeric_limits<double>::lowest();

   mTickMarkNumberX        = 5;
   mTickMarkNumberY        = 5;
   mUseTickMarkIncrementX  = false;
   mUseTickMarkIncrementY  = false;
   mUseTickMarkIncrementY2 = false;
   mTickMarkIncrementX     = 0;
   mTickMarkIncrementY     = 0;

   RemoveAllOverlayLines();
   RemoveAllOverlayText();
   ClearData();

   // TODO Should we emit SeriesRemoved() for each series?
   for (auto&& it : mData)
   {
      SeriesBase* sb = it.second;
      delete sb;
   }
   mData.clear();
}

void UtQtGL2DPlot::ClearData()
{
   for (auto& i : mData)
   {
      i.second->ClearData();
   }
   mUseZColor = false;
   mGridXValues.clear();
   mGridYValues.clear();
   mGridDataValues.clear();
   mGridMidXValues.clear();
   mGridMidYValues.clear();
}

void UtQtGL2DPlot::ClearColorData()
{
   mUseZColor = false;
   for (auto& i : mData)
   {
      i.second->ClearColorData();
   }
}

void UtQtGL2DPlot::SetShowOrigin(bool aInput)
{
   mShowOrigin = aInput;
}

void UtQtGL2DPlot::SetShowFullBorder(bool aInput)
{
   mShowFullBorder = aInput;
}

void UtQtGL2DPlot::SetShowGrid(bool aInput)
{
   mShowGrid = aInput;
}

void UtQtGL2DPlot::Draw()
{
   // The reason ComputeTickPositions() is call twice is due to the following dependencies:
   //  ComputePlotBoundaries needs the tick mark labels' text width to compute the plot boundaries.
   //  ComputeTickPositions computes the tick mark labels and their position.
   //  To compute the tick mark position, the Plot Boundaries must be computed already.
   // If the first ComputeTickPositions() is removed, the first time the plot is shown, the text on
   //  the Y axis may overlap the tickmark labels until Draw() is called a second time.
   //  Note: Draw() is called anytime an update() is invoked, there are many ways this can happen.
   ComputeTickPositions();  // Compute tick mark labels (positions returned may not be valid)
   ComputePlotBoundaries(); // Compute Boundaries of the plot
   ComputeTickPositions();  // compute the position and labels of the tick marks using the correct boundaries

   DrawPlotBackground();
   DrawUnderlayLines();
   if (!mDrawDataLast)
   {
      DrawDataDisplay();
   }
   DrawGrid();
   DrawBorder();
   DrawOrigin();
   DrawTickMarks();
   if (mDrawDataLast)
   {
      DrawDataDisplay();
   }
   DrawOverlayLines();
   DrawCrosshairs();
}

void UtQtGL2DPlot::QtDraw(QPainter* aPainter)
{
   DrawLabels(aPainter);
   DrawDataDisplayText(aPainter);
   DrawOverlayText(aPainter);
   DrawCrosshairsText(aPainter);
   DrawLegend(aPainter);
}

void UtQtGL2DPlot::ComputePlotBoundaries()
{
   QFont font = qApp->font();
   font.setPointSize(mTickMarkFontSize);

   QFontMetrics fm(qApp->font());
   int          tickmarkLabelWidth1 = 0;
   int          tickmarkLabelWidth2 = 0;
   double       width;

   for (auto& iter : mYAxisTicks)
   {
      width = fm.width(QString::number(iter.second, 'g', mSignificantDigits));
      if (tickmarkLabelWidth1 < width)
      {
         tickmarkLabelWidth1 = width;
      }
   }

   if (mEnableSecondaryAxis)
   {
      for (auto& iter : mYAxisTicks2)
      {
         width = fm.width(QString::number(iter.second, 'g', mSignificantDigits));

         if (tickmarkLabelWidth2 < width)
         {
            tickmarkLabelWidth2 = width;
         }
      }
   }
   font.setPointSize(mLabelFontSize);
   QFontMetrics fm2(font);
   double       widthWithoutLabel1 = cTickMarkLength * mDisplayWidth + tickmarkLabelWidth1 + 2;
   double       widthWithoutLabel2 = cTickMarkLength * mDisplayWidth + tickmarkLabelWidth2 + 2;
   double       h                  = fm2.height();
   double       widthWithLabel1    = widthWithoutLabel1 + h;
   double       widthWithLabel2    = widthWithoutLabel2 + h;

   mPlotLeft_percent  = (double)(widthWithLabel1 + 2) / (double)(mDisplayWidth);
   mLeftLabelPosition = (mPlotLeft_percent * mDisplayWidth) - widthWithoutLabel1;

   mPlotRight_percent  = 1.0 - (double)(widthWithLabel2 + 2) / (double)(mDisplayWidth);
   mRightLabelPosition = (mPlotRight_percent * mDisplayWidth) + widthWithoutLabel2;

   mPlotBottom_percent = cPlotMinDefaultBoundary;
   if (mReduceTopPadding)
   {
      mPlotTop_percent = cPlotMaxDefaultBoundaryReduced;
   }
   else
   {
      mPlotTop_percent = cPlotMaxDefaultBoundary;
   }

   mPlotRight_pixels  = mPlotRight_percent * mDisplayWidth - mDisplayWidth / 2;
   mPlotTop_pixels    = mPlotTop_percent * mDisplayHeight - mDisplayHeight / 2;
   mPlotLeft_pixels   = mPlotLeft_percent * mDisplayWidth - mDisplayWidth / 2;
   mPlotBottom_pixels = mPlotBottom_percent * mDisplayHeight - mDisplayHeight / 2;
}

void UtQtGL2DPlot::DrawOrigin()
{
   // If show Origin enabled, and 0,0 is within the plot.
   if (mShowOrigin && 0 <= mMaxXBoundary && 0 >= mMinXBoundary && 0 <= mMaxYBoundary && 0 >= mMinYBoundary)
   {
      double originX, originY;
      TranslatePointFromRealToScene(0, 0, originX, originY);

      glPushMatrix();
      {
         glTranslated((double)(mDisplayWidth)*0.5, (double)(mDisplayHeight)*0.5, 0.0);

         glLineWidth(4.0);
         glColor4f(1.0, 0.0, 0.0, 0.5);
         glBegin(GL_LINES);
         {
            glVertex2i(originX - 5, originY);
            glVertex2i(originX + 5, originY);

            glVertex2i(originX, originY - 5);
            glVertex2i(originX, originY + 5);
         }
         glEnd();
      }
      glPopMatrix();
   }
}

void UtQtGL2DPlot::DrawGrid()
{
   if (mShowGrid)
   {
      glPushMatrix();
      {
         glTranslated((double)(mDisplayWidth)*0.5, (double)(mDisplayHeight)*0.5, 0.0);

         glLineWidth(mGridWidth);
         glColor4f(mGridColor.redF(), mGridColor.greenF(), mGridColor.blueF(), mGridColor.alphaF());
         EnableStippling(mGridStipple);

         glBegin(GL_LINES);
         {
            for (auto& iter : mXAxisTicks)
            {
               glVertex2i(iter.first, mPlotBottom_pixels);
               glVertex2i(iter.first, mPlotTop_pixels);
            }

            for (auto& iter : mYAxisTicks)
            {
               glVertex2i(mPlotLeft_pixels, iter.first);
               glVertex2i(mPlotRight_pixels, iter.first);
            }

            if (mEnableSecondaryAxis)
            {
               for (auto& iter : mYAxisTicks2)
               {
                  glVertex2i(mPlotLeft_pixels, iter.first);
                  glVertex2i(mPlotRight_pixels, iter.first);
               }
            }
         }
         glEnd();
         DisableStippling();
      }
      glPopMatrix();
   }
}

void UtQtGL2DPlot::DrawBorder()
{
   glPushMatrix();
   {
      glTranslated((double)(mDisplayWidth)*0.5, (double)(mDisplayHeight)*0.5, 0.0);

      glLineWidth(mBorderWidth);
      glColor4f(mBorderColor.redF(), mBorderColor.greenF(), mBorderColor.blueF(), mBorderColor.alphaF());

      EnableStippling(mBorderStipple);
      // Draw Border
      glBegin(GL_LINE_STRIP);
      glVertex2i(mPlotLeft_pixels, mPlotTop_pixels);
      glVertex2i(mPlotLeft_pixels, mPlotBottom_pixels);
      glVertex2i(mPlotRight_pixels, mPlotBottom_pixels);
      if (mShowFullBorder)
      {
         glVertex2i(mPlotRight_pixels, mPlotTop_pixels);
         glVertex2i(mPlotLeft_pixels, mPlotTop_pixels);
      }
      glEnd();

      DisableStippling();
   }
   glPopMatrix();
}

void UtQtGL2DPlot::DrawPlotBackground()
{
   if (mDrawPlotBackground)
   {
      glPushMatrix();
      {
         glTranslated(static_cast<double>(mDisplayWidth) * 0.5, static_cast<double>(mDisplayHeight) * 0.5, 0.0);
         if (mBackgroundImage > 0)
         {
            glEnable(GL_TEXTURE_2D);

            glColor3d(1, 1, 1);
            glBindTexture(GL_TEXTURE_2D, mBackgroundImage);

            glBegin(GL_POLYGON);
            {
               glTexCoord2f(0, 0);
               glVertex3d(mPlotLeft_pixels, mPlotBottom_pixels, 0);
               glTexCoord2f(1, 0);
               glVertex3d(mPlotRight_pixels, mPlotBottom_pixels, 0);
               glTexCoord2f(1, 1);
               glVertex3d(mPlotRight_pixels, mPlotTop_pixels, 0);
               glTexCoord2f(0, 1);
               glVertex3d(mPlotLeft_pixels, mPlotTop_pixels, 0);
            }
            glEnd();
            glDisable(GL_TEXTURE_2D);
         }
         else if (mPlotBackgroundGradient)
         {
            glBegin(GL_QUADS);
            {
               for (auto& mPlotGradientPoint : mPlotGradientPoints)
               {
                  glColor4f(mPlotGradientPoint.color.redF(),
                            mPlotGradientPoint.color.greenF(),
                            mPlotGradientPoint.color.blueF(),
                            mPlotGradientPoint.color.alphaF());
                  glVertex2f(mPlotGradientPoint.x * mPlotRight_pixels, mPlotGradientPoint.y * mPlotTop_pixels);
               }
            }
            glEnd();
         }
         else
         {
            glColor4f(mPlotBackgroundColor.redF(),
                      mPlotBackgroundColor.greenF(),
                      mPlotBackgroundColor.blueF(),
                      mPlotBackgroundColor.alphaF());
            glBegin(GL_POLYGON);
            {
               glVertex2i(mPlotLeft_pixels, mPlotBottom_pixels);
               glVertex2i(mPlotLeft_pixels, mPlotTop_pixels);
               glVertex2i(mPlotRight_pixels, mPlotTop_pixels);
               glVertex2i(mPlotRight_pixels, mPlotBottom_pixels);
            }
            glEnd();
         }
      }
      glPopMatrix();
   }
}

void UtQtGL2DPlot::DrawOverlayLines()
{
   for (const auto& line : mOverlayLines)
   {
      // Draw the line in the new location
      QList<std::pair<double, double>> points;
      // Check on y are <= while checks on x are just <
      //  this is so corners are not counted twice
      if (line.mVertical)
      {
         if (mMinXBoundary < line.mIntercept && line.mIntercept < mMaxXBoundary)
         {
            points.push_back(std::make_pair(line.mIntercept, mMinYBoundary));
            points.push_back(std::make_pair(line.mIntercept, mMaxYBoundary));
         }
      }
      else
      {
         double y = line.mSlope * mMinXBoundary + line.mIntercept;
         if (mMinYBoundary <= y && y <= mMaxYBoundary)
         {
            points.push_back(std::make_pair(mMinXBoundary, y));
         }
         y = line.mSlope * mMaxXBoundary + line.mIntercept;
         if (mMinYBoundary <= y && y <= mMaxYBoundary)
         {
            points.push_back(std::make_pair(mMaxXBoundary, y));
         }
      }

      if (line.mSlope != 0)
      {
         double x = (mMinYBoundary - line.mIntercept) / line.mSlope;
         if (mMinXBoundary < x && x < mMaxXBoundary)
         {
            points.push_back(std::make_pair(x, mMinYBoundary));
         }
         x = (mMaxYBoundary - line.mIntercept) / line.mSlope;
         if (mMinXBoundary < x && x < mMaxXBoundary)
         {
            points.push_back(std::make_pair(x, mMaxYBoundary));
         }
      }

      if (points.size() == 2)
      {
         // draw line
         double x1, x2, y1, y2;
         TranslatePointFromRealToScene(points[0].first, points[0].second, x1, y1);
         TranslatePointFromRealToScene(points[1].first, points[1].second, x2, y2);
         glPushMatrix();
         {
            glTranslated((double)(mDisplayWidth)*0.5, (double)(mDisplayHeight)*0.5, 0.0);

            glLineWidth(line.mWidth);
            EnableStippling(line.mStipple);
            glColor4f(line.mColor.redF(), line.mColor.greenF(), line.mColor.blueF(), line.mColor.alphaF());

            glBegin(GL_LINES);
            {
               glVertex2i(x1, y1);
               glVertex2i(x2, y2);
            }
            glEnd();
            DisableStippling();
         }
         glPopMatrix();
      }
   }
}

void UtQtGL2DPlot::DrawOverlayText(QPainter* aPainter)
{
   auto iter = mOverlayText.begin();
   for (; iter != mOverlayText.end(); ++iter)
   {
      // Legend position is a % of the screen.
      int x = iter->mX * mDisplayWidth;
      int y = iter->mY * mDisplayHeight;

      QFont font = qApp->font();
      font.setPointSize(iter->mSize);
      aPainter->setFont(font);
      aPainter->setPen(iter->mColor);
      RenderText(aPainter, x, y, iter->mText, iter->mAlign, iter->mAngle);
   }
}

void UtQtGL2DPlot::DrawLegend(QPainter* aPainter)
{
   if (mShowLegend && ContainsData())
   {
      QFont font = qApp->font();
      font.setPointSize(mLegendFontSize);
      QFontMetrics fm(font);
      aPainter->setFont(font);
      int legendWidth = 0;

      // Legend position is a % of the screen.
      int x = mLegendXPosition * mDisplayWidth;
      int y = mLegendYPosition * mDisplayHeight;

      int visibleSeriesCount = 0;
      for (const auto& series : mData)
      {
         if (GetSeriesVisible(series.first) && !series.second->IsEmpty())
         {
            QString text  = series.second->Name();
            int     width = fm.width(text);
            // If width is greater than previous widths, update it
            if (width > legendWidth)
            {
               legendWidth = width;
            }
            visibleSeriesCount++;
         }
      }

      // if no series are visible do not draw the legend even if the plot contains data.
      if (visibleSeriesCount != 0)
      {
         int legendRowHeight    = fm.height();
         int drawElementSpacing = legendRowHeight / 2; // Spacing between elements in the legend

         // To ensure that all the line styles will appear close to the same length,
         // we should make it so that the dotted line will end on a line, rather than a space
         int lineLengthMultiple = 4; // For each lineLengthMultiple, 2 dotted lines will be drawn
         int legendLineLength   = 8 * lineLengthMultiple - 3; // Length of the series line in the legend

         legendWidth += legendLineLength + drawElementSpacing;
         int legendHeight = visibleSeriesCount * legendRowHeight;
         int padding      = 3;

         int xLeft   = x - padding;
         int xRight  = x + legendWidth + padding;
         int yBottom = y - padding;
         int yTop    = y + legendHeight + padding;

         aPainter->setBrush(mLegendBackgroundColor);
         aPainter->setPen(Qt::black);

         QPoint topleft(xLeft, mDisplayHeight - legendRowHeight - 6 - yBottom);
         QPoint bottomright = topleft + QPoint(xRight - xLeft, yTop - yBottom);
         mLegendRect        = QRect(topleft, bottomright);
         aPainter->drawRect(mLegendRect);

         int rowCount = 0;
         for (const auto& series : mData)
         {
            if (GetSeriesVisible(series.first) && !series.second->IsEmpty())
            {
               QColor color = GetSeriesColor(series.first);
               aPainter->setPen(mTextColor);
               RenderText(aPainter,
                          x + legendLineLength + drawElementSpacing,
                          y - legendRowHeight * rowCount + padding,
                          series.second->Name(),
                          Qt::AlignLeft | Qt::AlignBottom,
                          0);

               QPen  pen             = QPen();
               float seriesLineWidth = GetSeriesWidth(series.first);
               pen.setColor(color);
               pen.setWidth(seriesLineWidth);
               switch (GetSeriesStipple(series.first))
               {
               case UtQtGL2DPlot::NO_STIPPLE:
                  pen.setStyle(Qt::SolidLine);
                  break;
               case UtQtGL2DPlot::DOTTED:
                  // 0x1111 -> 100010001000 -> 1p line - 3p space - 1p line
                  // We need to divide by the line width of the series because
                  // Qt will scale the dash pattern by the line width
                  pen.setDashPattern(QVector<qreal>() << 1.0 / seriesLineWidth << 3.0 / seriesLineWidth);
                  pen.setCapStyle(Qt::FlatCap);
                  break;
               case UtQtGL2DPlot::DASHED:
                  // 0x0F0F -> 111100001111 -> 4p line - 4p space - 4p line
                  // We need to divide by the line width of the series because
                  // Qt will scale the dash pattern by the line width
                  pen.setDashPattern(QVector<qreal>() << 4.0 / seriesLineWidth << 4.0 / seriesLineWidth);
                  pen.setCapStyle(Qt::FlatCap);
                  break;
               default:
                  pen.setStyle(Qt::SolidLine);
                  break;
               }
               aPainter->setPen(pen);
               aPainter->drawLine(x,
                                  mDisplayHeight - y + legendRowHeight * rowCount - 0.5 * legendRowHeight,
                                  x + legendLineLength,
                                  mDisplayHeight - y + legendRowHeight * rowCount - 0.5 * legendRowHeight);
               rowCount++;
            }
         }
      }
   }
}

void UtQtGL2DPlot::DrawDataDisplay()
{
   glEnable(GL_BLEND);
   glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);

   // For each series
   for (const auto& i : mData)
   {
      const int seriesNum = i.first;
      if (GetSeriesVisible(seriesNum))
      {
         const PlotStyle plotStyle = i.second->mPlotStyle;
         if (plotStyle == VERTICAL_BAR || plotStyle == HORIZONTAL_BAR)
         {
            DrawDataDisplayBar(seriesNum);
         }
         else if (plotStyle == POINT || i.second->Size() == 1) // Line with a a single point, display as point
         {
            DrawDataDisplayPoint(seriesNum, i.second->mWidth);
         }
         else if (plotStyle == LINE)
         {
            // highlight the selected series (if there is one)
            DrawDataDisplayLine(seriesNum, GetSelectedSeries() == seriesNum);
         }
         else if (plotStyle == MIDPOINT_GRID)
         {
            DrawDataDisplayMidpointGrid(seriesNum);
         }
      }
   }
}

void UtQtGL2DPlot::DrawDataDisplayText(QPainter* aPainter)
{
   // For each series
   for (const auto& i : mData)
   {
      const int seriesNum = i.first;
      if (GetSeriesVisible(seriesNum))
      {
         const PlotStyle plotStyle = i.second->mPlotStyle;

         if (plotStyle == POINT || i.second->Size() == 1) // Line with a a single point, display as point
         {
            DrawDataDisplayPointText(aPainter, seriesNum);
         }
         else if (plotStyle == LINE)
         {
            // highlight the selected series (if there is one)
            DrawDataDisplayLineText(aPainter, seriesNum, GetSelectedSeries() == seriesNum);
         }
      }
   }
}

void UtQtGL2DPlot::DrawDataDisplayLineText(QPainter* aPainter, int aSeriesNum, bool aHighlight)
{
   SeriesBase& series = *FindSeriesP(aSeriesNum);

   if (aHighlight)
   {
      QColor prevColor = series.mColor;

      series.mColor = prevColor.lighter();

      DrawDataDisplayLineText(aPainter, aSeriesNum, false);

      series.mColor = prevColor;
   }

   if (series.mShowPoints)
   {
      DrawDataDisplayPointText(aPainter, aSeriesNum);
   }
}

void UtQtGL2DPlot::DrawDataDisplayPointText(QPainter* aPainter, int aSeriesNum)
{
   SeriesBase& series = *FindSeriesP(aSeriesNum);

   int index = 0;
   for (size_t i = 0; i < series.Size(); ++i)
   {
      double       x    = 0.0;
      double       y    = 0.0;
      unsigned int rgba = 0xFFFFFFFF;
      series.Get(i, x, y);
      series.GetRGBA(i, rgba);
      if (x >= mMinXBoundary && x <= mMaxXBoundary && y >= GetYMinBoundary(series.mIsSecondaryAxis) &&
          y <= GetYMaxBoundary(series.mIsSecondaryAxis))
      {
         double translatedX, translatedY;
         TranslatePointFromRealToScene(series, x, y, translatedX, translatedY);

         // If this point should be highlighted.
         if (series.mSelectedDataPoint == index)
         {
            if (mShowLabelOnSelectedDataPoint)
            {
               QFont font = qApp->font();

               aPainter->setPen(series.mColor);
               QString label = "(" + QString::number(x, 'g', mSignificantDigits) + ", " +
                               QString::number(y, 'g', mSignificantDigits) + ")";
               font.setPointSize(cSeriesFontLabelFactor * mLabelFontSize);
               aPainter->setFont(font);
               // If point is more than 80% of the plot region, display label on left side instead of right side
               if (translatedX > (mPlotLeft_pixels + cRightLeftLabelTransition * (mPlotRight_pixels - mPlotLeft_pixels)))
               {
                  RenderText(aPainter,
                             0.5 * mDisplayWidth + translatedX - cSeriesFontLabelOffset,
                             0.5 * mDisplayHeight + translatedY,
                             label,
                             Qt::AlignRight | Qt::AlignVCenter,
                             0);
               }
               else
               {
                  RenderText(aPainter,
                             0.5 * mDisplayWidth + translatedX + cSeriesFontLabelOffset,
                             0.5 * mDisplayHeight + translatedY,
                             label,
                             Qt::AlignLeft | Qt::AlignVCenter,
                             0);
               }
            }
         }
      }
      index++;
   }
}

void UtQtGL2DPlot::DrawDataDisplayBar(int aSeriesNum)
{
   double      barWidth = GetBarWidth(aSeriesNum);
   SeriesBase& series   = *FindSeriesP(aSeriesNum);

   if (series.mPlotStyle == VERTICAL_BAR)
   {
      for (size_t i = 0; i < series.Size(); ++i)
      {
         double x = 0.0;
         double y = 0.0;
         series.Get(i, x, y);
         if (x >= mMinXBoundary && x <= mMaxXBoundary)
         {
            double x1, x2;
            x1 = x - barWidth;
            x2 = x + barWidth;
            double translatedX1, translatedX2, translatedY1;
            TranslatePointFromRealToScene(series, x1, y, translatedX1, translatedY1);
            TranslatePointFromRealToScene(series, x2, y, translatedX2, translatedY1);

            // Bound the bar by the sides of the graph
            if (translatedX1 < mPlotLeft_pixels)
            {
               translatedX1 = mPlotLeft_pixels;
            }
            if (translatedX2 > mPlotRight_pixels)
            {
               translatedX2 = mPlotRight_pixels;
            }

            QVector<QPointF> points;
            if (translatedY1 < mPlotBottom_pixels)
            {
               translatedY1 = mPlotBottom_pixels;
               points.push_back(QPointF(translatedX1, mPlotBottom_pixels));
               points.push_back(QPointF(translatedX2, mPlotBottom_pixels));
               points.push_back(QPointF(translatedX2 - (translatedX2 - translatedX1) / 2,
                                        translatedY1 + .01 * (mPlotTop_pixels - mPlotBottom_pixels)));
               points.push_back(QPointF(translatedX1, mPlotBottom_pixels));
            }
            else if (translatedY1 > mPlotTop_pixels)
            {
               translatedY1 = mPlotTop_pixels;
               points.push_back(QPointF(translatedX1, translatedY1));
               points.push_back(QPointF(translatedX1, mPlotBottom_pixels));
               points.push_back(QPointF(translatedX2, mPlotBottom_pixels));
               points.push_back(QPointF(translatedX2, translatedY1));
               points.push_back(QPointF(translatedX2 - (translatedX2 - translatedX1) / 2,
                                        translatedY1 - .01 * (mPlotTop_pixels - mPlotBottom_pixels)));
               points.push_back(QPointF(translatedX1, translatedY1));
            }
            else
            {
               points.push_back(QPointF(translatedX1, translatedY1));
               points.push_back(QPointF(translatedX1, mPlotBottom_pixels));
               points.push_back(QPointF(translatedX2, mPlotBottom_pixels));
               points.push_back(QPointF(translatedX2, translatedY1));
               points.push_back(QPointF(translatedX1, translatedY1));
            }

            glPushMatrix();
            {
               glTranslated((double)(mDisplayWidth)*0.5, (double)(mDisplayHeight)*0.5, 0.0);
               glLineWidth(series.mWidth);

               if (GetSeriesFill(aSeriesNum))
               {
                  glColor4f(series.mFillColor.redF(),
                            series.mFillColor.greenF(),
                            series.mFillColor.blueF(),
                            series.mFillColor.alphaF());
                  // Draw the polygon that fills in the "bar"
                  glBegin(GL_POLYGON);
                  {
                     for (auto& point : points)
                     {
                        glVertex2i(point.x(), point.y());
                     }
                  }
                  glEnd();
               }

               glColor4f(series.mColor.redF(), series.mColor.greenF(), series.mColor.blueF(), series.mColor.alphaF());
               EnableStippling(series.mStipple);
               // Draw the border around the "bar"
               glBegin(GL_LINE_LOOP);
               {
                  for (auto& point : points)
                  {
                     glVertex2i(point.x(), point.y());
                  }
               }
               glEnd();
               DisableStippling();
            }
            glPopMatrix();
         }
      }
   }
   else // HORIZONTAL_BAR
   {
      for (size_t i = 0; i < series.Size(); ++i)
      {
         double x = 0.0;
         double y = 0.0;
         series.Get(i, x, y);
         if (y >= GetYMinBoundary(series.mIsSecondaryAxis) && y <= GetYMaxBoundary(series.mIsSecondaryAxis))
         {
            double y1, y2;
            y1 = y - barWidth;
            y2 = y + barWidth;
            double translatedX1, translatedY1, translatedY2;
            TranslatePointFromRealToScene(series, x, y1, translatedX1, translatedY1);
            TranslatePointFromRealToScene(series, x, y2, translatedX1, translatedY2);

            // Bound the bar by the top/bottom of the graph
            if (translatedY1 < mPlotBottom_pixels)
            {
               translatedY1 = mPlotBottom_pixels;
            }
            if (translatedY2 > mPlotTop_pixels)
            {
               translatedY2 = mPlotTop_pixels;
            }

            QVector<QPointF> points;
            if (translatedX1 > mPlotRight_pixels)
            {
               translatedX1 = mPlotRight_pixels;
               points.push_back(QPointF(translatedX1, translatedY1));
               points.push_back(QPointF(mPlotLeft_pixels, translatedY1));
               points.push_back(QPointF(mPlotLeft_pixels, translatedY2));
               points.push_back(QPointF(translatedX1, translatedY2));
               points.push_back(QPointF(translatedX1 + .01 * (mPlotRight_pixels - mPlotLeft_pixels),
                                        translatedY2 - (translatedY2 - translatedY1) / 2));
               points.push_back(QPointF(translatedX1, translatedY1));
            }
            else if (translatedX1 < mPlotLeft_pixels)
            {
               translatedX1 = mPlotLeft_pixels;
               points.push_back(QPointF(mPlotLeft_pixels, translatedY1));
               points.push_back(QPointF(mPlotLeft_pixels, translatedY2));
               points.push_back(QPointF(translatedX1 - .01 * (mPlotRight_pixels - mPlotLeft_pixels),
                                        translatedY2 - (translatedY2 - translatedY1) / 2));
               points.push_back(QPointF(mPlotLeft_pixels, translatedY1));
            }
            else
            {
               points.push_back(QPointF(translatedX1, translatedY1));
               points.push_back(QPointF(mPlotLeft_pixels, translatedY1));
               points.push_back(QPointF(mPlotLeft_pixels, translatedY2));
               points.push_back(QPointF(translatedX1, translatedY2));
               points.push_back(QPointF(translatedX1, translatedY1));
            }

            glPushMatrix();
            {
               glTranslated((double)(mDisplayWidth)*0.5, (double)(mDisplayHeight)*0.5, 0.0);

               glLineWidth(GetSeriesWidth(aSeriesNum));

               if (GetSeriesFill(aSeriesNum))
               {
                  glColor4f(GetSeriesFillColor(aSeriesNum).redF(),
                            GetSeriesFillColor(aSeriesNum).greenF(),
                            GetSeriesFillColor(aSeriesNum).blueF(),
                            GetSeriesFillColor(aSeriesNum).alphaF());
                  // Draw the polygon that fille in the "bar"
                  glBegin(GL_POLYGON);
                  {
                     for (auto& point : points)
                     {
                        glVertex2i(point.x(), point.y());
                     }
                  }
                  glEnd();
               }

               glColor4f(series.mColor.redF(), series.mColor.greenF(), series.mColor.blueF(), series.mColor.alphaF());
               EnableStippling(series.mStipple);
               // Draw the border around the "bar"
               glBegin(GL_LINE_LOOP);
               {
                  for (auto& point : points)
                  {
                     glVertex2i(point.x(), point.y());
                  }
               }
               glEnd();
               DisableStippling();
            }
            glPopMatrix();
         }
      }
   }
}

void UtQtGL2DPlot::DrawDataDisplayPoint(int aSeriesNum, int aWidth)
{
   SeriesBase& series = *FindSeriesP(aSeriesNum);
   glPushMatrix();
   {
      glTranslated((double)(mDisplayWidth)*0.5, (double)(mDisplayHeight)*0.5, 0.0);

      glPointSize(aWidth);

      glColor4f(series.mColor.redF(), series.mColor.greenF(), series.mColor.blueF(), series.mColor.alphaF());

      glEnable(GL_POINT_SMOOTH);
      glBegin(GL_POINTS);
      {
         int index = 0;
         for (size_t i = 0; i < series.Size(); ++i)
         {
            double       x    = 0.0;
            double       y    = 0.0;
            unsigned int rgba = 0xFFFFFFFF;
            series.Get(i, x, y);
            series.GetRGBA(i, rgba);
            if (x >= mMinXBoundary && x <= mMaxXBoundary && y >= GetYMinBoundary(series.mIsSecondaryAxis) &&
                y <= GetYMaxBoundary(series.mIsSecondaryAxis))
            {
               double translatedX, translatedY;
               TranslatePointFromRealToScene(series, x, y, translatedX, translatedY);

               // If this point should be highlighted.
               if (series.mSelectedDataPoint == index)
               {
                  glEnd();
                  // Change color and point Width for the highlight
                  QColor lighterColor = series.mColor.lighter();
                  glColor4f(lighterColor.redF(), lighterColor.greenF(), lighterColor.blueF(), lighterColor.alphaF());
                  glPointSize(aWidth + cHighlightWidthModifier);
                  // Draw the highlight point
                  glBegin(GL_POINTS);
                  glVertex2i(translatedX, translatedY);
                  glEnd();
                  // Change the color and point width back to the normal size
                  glPointSize(aWidth);
                  glColor4f(series.mColor.redF(), series.mColor.greenF(), series.mColor.blueF(), series.mColor.alphaF());

                  glBegin(GL_POINTS);
               }
               if (mUsePointColor)
               {
                  glColor4ubv((unsigned char*)&rgba);
               }
               glVertex2i(translatedX, translatedY);
            }
            index++;
         }
      }
      glEnd();
   }
   glPopMatrix();
}

void UtQtGL2DPlot::DrawDataDisplayLine(int aSeriesNum, bool aHighlight)
{
   SeriesBase& series = *FindSeriesP(aSeriesNum);
   double      x1     = (double)(mPlotLeft_pixels + mDisplayWidth / 2);
   double      x2     = x1 + (double)(mPlotRight_pixels - mPlotLeft_pixels);
   double      y1     = (double)(mPlotBottom_pixels + mDisplayHeight / 2);
   double      y2     = y1 + (double)(mPlotTop_pixels - mPlotBottom_pixels);

   // Create the plane equations
   GLdouble equationX1[] = {1.0, 0.0, 0.0, -x1};
   GLdouble equationX2[] = {-1.0, 0.0, 0.0, x2};
   GLdouble equationY1[] = {0.0, 1.0, 0.0, -y1};
   GLdouble equationY2[] = {0.0, -1.0, 0.0, y2};

   // Load the plane equations into the clippers
   glClipPlane(GL_CLIP_PLANE0, equationX1);
   glClipPlane(GL_CLIP_PLANE1, equationX2);
   glClipPlane(GL_CLIP_PLANE2, equationY1);
   glClipPlane(GL_CLIP_PLANE3, equationY2);

   // Enable the clipping planes
   glEnable(GL_CLIP_PLANE0);
   glEnable(GL_CLIP_PLANE1);
   glEnable(GL_CLIP_PLANE2);
   glEnable(GL_CLIP_PLANE3);

   if (series.mFill)
   {
      glPushMatrix();
      {
         glTranslated((double)(mDisplayWidth)*0.5, (double)(mDisplayHeight)*0.5, 0.0);
         glColor4f(series.mFillColor.redF(),
                   series.mFillColor.greenF(),
                   series.mFillColor.blueF(),
                   series.mFillColor.alphaF());
         // Draw the polygon that filled in the shape
         glBegin(GL_POLYGON);
         {
            for (size_t i = 0; i < series.Size(); ++i)
            {
               double x = 0.0;
               double y = 0.0;
               series.Get(i, x, y);
               double translatedX, translatedY;
               TranslatePointFromRealToScene(series, x, y, translatedX, translatedY);
               glVertex2i(translatedX, translatedY);
            }
         }
         glEnd();
      }
      glPopMatrix();
   }

   if (aHighlight)
   {
      int    prevWidth = series.mWidth;
      QColor prevColor = series.mColor;

      series.mWidth += cHighlightWidthModifier;
      series.mColor = prevColor.lighter();

      DrawDataDisplayLine(aSeriesNum, false);

      series.mWidth = prevWidth;
      series.mColor = prevColor;
   }

   // Draw points also

   if (series.mShowPoints)
   {
      DrawDataDisplayPoint(aSeriesNum, series.mWidth + cPointWidthModifier);
   }

   if (series.Size() > 0)
   {
      glPushMatrix();
      {
         glTranslated((double)(mDisplayWidth)*0.5, (double)(mDisplayHeight)*0.5, 0.0);

         glLineWidth(series.mWidth);
         EnableStippling(series.mStipple);

         if (mUseZColor)
         {
            /*
            Currently this code will draw multiple colored lines based on data in mColorData and mColorPoints.
            There is a limitation that due to simplicity it may not handle certain cases as desired.
            For example, if there is a line with point 1 having a z value of 0 and point 2 having a z value of 2,
            with the mColorPoints have the following values: (0 green),(1 blue),(2 red).  The line drawn from point 1
            to point 2 will start green and transition to red without first transitioning to blue.
            this may or may not be desired however it is simpler to implement this way.
            Look into transition between intermediate colors for a future update.
            */
            glEnable(GL_LINE_SMOOTH);
            glBegin(GL_LINE_STRIP);
            {
               QColor color;
               for (size_t i = 0; i < series.Size(); i++)
               {
                  double x = 0.0;
                  double y = 0.0;
                  double z = 0.0;
                  series.Get(i, x, y);
                  series.GetZ(i, z);
                  color = series.GetColorAt(z);
                  double translatedX, translatedY;
                  glColor4f(color.redF(), color.greenF(), color.blueF(), color.alphaF());
                  TranslatePointFromRealToScene(series, x, y, translatedX, translatedY);
                  glVertex2i(translatedX, translatedY);
               }
            }
            glEnd();
         }
         else
         {
            glColor4f(series.mColor.redF(), series.mColor.greenF(), series.mColor.blueF(), series.mColor.alphaF());

            glEnable(GL_LINE_SMOOTH);
            glBegin(GL_LINE_STRIP);
            {
               for (size_t i = 0; i < series.Size(); i++)
               {
                  double x = 0.0;
                  double y = 0.0;
                  series.Get(i, x, y);
                  double translatedX, translatedY;
                  TranslatePointFromRealToScene(series, x, y, translatedX, translatedY);
                  if (mUsePointColor)
                  {
                     unsigned int rgba;
                     series.GetRGBA(i, rgba);
                     glColor4uiv(&rgba);
                  }
                  glVertex2i(translatedX, translatedY);
               }
            }
            glEnd();
         }
         DisableStippling();
      }
      glPopMatrix();
   }

   // Disable the clipping planes
   glDisable(GL_CLIP_PLANE0);
   glDisable(GL_CLIP_PLANE1);
   glDisable(GL_CLIP_PLANE2);
   glDisable(GL_CLIP_PLANE3);
}

void UtQtGL2DPlot::DrawDataDisplayMidpointGrid(int aSeriesNum)
{
   SeriesBase& series        = FindOrMakeSeries(aSeriesNum);
   const auto& midXValues    = mGridMidXValues[aSeriesNum];
   const auto& midYValues    = mGridMidYValues[aSeriesNum];
   const auto& midDataValues = mGridDataValues[aSeriesNum];

   if (midXValues.empty() && midYValues.empty())
   {
      GenerateMidpointGridData(aSeriesNum);
   }

   const size_t midXSize = midXValues.size();
   const size_t midYSize = midYValues.size();

   glShadeModel(GL_FLAT);
   glPushMatrix();
   glTranslated((double)mDisplayWidth * 0.5, (double)mDisplayHeight * 0.5, 0.0);
   glBegin(GL_QUADS);

   for (size_t x = 1; x < midXSize; ++x)
   {
      for (size_t y = 1; y < midYSize; ++y)
      {
         const QColor& color = series.GetColorAt(midDataValues[x - 1][y - 1]);
         glColor3f(color.redF(), color.greenF(), color.blueF());
         double tx, ty;

         TranslatePointFromRealToScene(GetBoundedX(midXValues[x - 1]), GetBoundedY(midYValues[y - 1]), tx, ty, false);
         glVertex2f(tx, ty);
         TranslatePointFromRealToScene(GetBoundedX(midXValues[x - 1]), GetBoundedY(midYValues[y]), tx, ty, false);
         glVertex2f(tx, ty);
         TranslatePointFromRealToScene(GetBoundedX(midXValues[x]), GetBoundedY(midYValues[y]), tx, ty, false);
         glVertex2f(tx, ty);
         TranslatePointFromRealToScene(GetBoundedX(midXValues[x]), GetBoundedY(midYValues[y - 1]), tx, ty, false);
         glVertex2f(tx, ty);
      }
   }
   glEnd();

   glPopMatrix();
}

void UtQtGL2DPlot::DrawCrosshairs()
{
   if (mShowCrosshairs)
   {
      bool   visible = false;
      double xPos    = 0;
      double xValue  = 0;

      if (mUseCrosshairValue)
      {
         if (mCrosshairsValue >= mMinXBoundary && mCrosshairsValue <= mMaxXBoundary)
         {
            visible = true;
            // Calculate the X OGL coordinate for the crosshair line
            double plotXPercent = (mCrosshairsValue - mMinXBoundary) / (mMaxXBoundary - mMinXBoundary);
            xPos                = plotXPercent * (mPlotRight_pixels - mPlotLeft_pixels) + mPlotLeft_pixels;
            xValue              = mCrosshairsValue;
         }
      }
      else
      {
         xPos = mCrosshairsPercent * mDisplayWidth - mDisplayWidth / 2;
         if (xPos >= mPlotLeft_pixels && xPos <= mPlotRight_pixels)
         {
            visible = true;
            xValue =
               ((xPos - mPlotLeft_pixels) / (mPlotRight_pixels - mPlotLeft_pixels)) * (mMaxXBoundary - mMinXBoundary) +
               mMinXBoundary;
         }
      }

      if (visible)
      {
         glPushMatrix();
         {
            glTranslated((double)(mDisplayWidth)*0.5, (double)(mDisplayHeight)*0.5, 0.0);
            glLineWidth(mCrosshairWidth);
            EnableStippling(mCrosshairStipple);
            glColor4f(mCrosshairColor.redF(), mCrosshairColor.greenF(), mCrosshairColor.blueF(), mCrosshairColor.alphaF());
            glEnable(GL_LINE_SMOOTH);
            glBegin(GL_LINES);
            {
               glVertex2i(xPos, mPlotBottom_pixels);
               glVertex2i(xPos, mPlotTop_pixels);
            }
            glEnd();
            DisableStippling();

            QList<double> yValues;
            for (auto& seriesIter : mData)
            {
               SeriesBase* series = seriesIter.second;
               if ((mCrosshairShowAllSeries || mCrosshairSeriesNum == seriesIter.first) && series->mVisible)
               {
                  QList<double> yValues;
                  CalculateValueForSeries(seriesIter.first, xValue, yValues);

                  glEnable(GL_POINT_SMOOTH);

                  for (double& yValue : yValues)
                  {
                     if (yValue <= GetYMaxBoundary(seriesIter.second->mIsSecondaryAxis) &&
                         yValue >= GetYMinBoundary(seriesIter.second->mIsSecondaryAxis))
                     {
                        double yPosition = (yValue - GetYMinBoundary(seriesIter.second->mIsSecondaryAxis)) /
                                           (GetYMaxBoundary(seriesIter.second->mIsSecondaryAxis) -
                                            GetYMinBoundary(seriesIter.second->mIsSecondaryAxis));
                        yPosition = yPosition * (mPlotTop_pixels - mPlotBottom_pixels) + mPlotBottom_pixels;

                        QColor color = GetSeriesColor(seriesIter.first);
                        glPointSize(series->mWidth + 4);
                        glColor4f(color.redF(), color.greenF(), color.blueF(), color.alphaF());

                        glBegin(GL_POINTS);
                        {
                           glVertex2i(xPos, yPosition);
                        }
                        glEnd();
                     }
                  }
               }
            }
         }
         glPopMatrix();
      }
   }
}

void UtQtGL2DPlot::DrawCrosshairsText(QPainter* aPainter)
{
   if (mShowCrosshairs)
   {
      bool   visible = false;
      double xPos    = 0;
      double xValue  = 0;

      if (mUseCrosshairValue)
      {
         if (mCrosshairsValue >= mMinXBoundary && mCrosshairsValue <= mMaxXBoundary)
         {
            visible = true;
            // Calculate the X OGL coordinate for the cross-hair line
            double plotXPercent = (mCrosshairsValue - mMinXBoundary) / (mMaxXBoundary - mMinXBoundary);
            xPos                = plotXPercent * (mPlotRight_pixels - mPlotLeft_pixels) + mPlotLeft_pixels;
            xValue              = mCrosshairsValue;
         }
      }
      else
      {
         xPos = mCrosshairsPercent * mDisplayWidth - mDisplayWidth / 2;
         if (xPos >= mPlotLeft_pixels && xPos <= mPlotRight_pixels)
         {
            visible = true;
            xValue =
               ((xPos - mPlotLeft_pixels) / (mPlotRight_pixels - mPlotLeft_pixels)) * (mMaxXBoundary - mMinXBoundary) +
               mMinXBoundary;
         }
      }

      if (visible)
      {
         QList<double> yValues;
         for (auto& seriesIter : mData)
         {
            SeriesBase* series = seriesIter.second;
            if ((mCrosshairShowAllSeries || mCrosshairSeriesNum == seriesIter.first) && series->mVisible)
            {
               QList<double> yValues;
               CalculateValueForSeries(seriesIter.first, xValue, yValues);

               for (double& yValue : yValues)
               {
                  if (yValue <= GetYMaxBoundary(seriesIter.second->mIsSecondaryAxis) &&
                      yValue >= GetYMinBoundary(seriesIter.second->mIsSecondaryAxis))
                  {
                     double yPosition = (yValue - GetYMinBoundary(seriesIter.second->mIsSecondaryAxis)) /
                                        (GetYMaxBoundary(seriesIter.second->mIsSecondaryAxis) -
                                         GetYMinBoundary(seriesIter.second->mIsSecondaryAxis));
                     yPosition = yPosition * (mPlotTop_pixels - mPlotBottom_pixels) + mPlotBottom_pixels;

                     QColor color = GetSeriesColor(seriesIter.first);
                     aPainter->setPen(color);

                     QFont font = qApp->font();
                     font.setPointSize(cSeriesFontLabelFactor * mLabelFontSize);
                     aPainter->setFont(font);

                     if (xPos > (mPlotLeft_pixels + cRightLeftLabelTransition * (mPlotRight_pixels - mPlotLeft_pixels)))
                     {
                        RenderText(aPainter,
                                   xPos - cSeriesFontLabelOffset + mDisplayWidth * 0.5,
                                   mDisplayHeight * 0.5 + yPosition,
                                   QString::number(yValue, 'g', mSignificantDigits),
                                   Qt::AlignRight | Qt::AlignVCenter,
                                   0);
                     }
                     else
                     {
                        RenderText(aPainter,
                                   xPos + cSeriesFontLabelOffset + mDisplayWidth * 0.5,
                                   mDisplayHeight * 0.5 + yPosition,
                                   QString::number(yValue, 'g', mSignificantDigits),
                                   Qt::AlignLeft | Qt::AlignVCenter,
                                   0);
                     }
                  }
               }
            }
         }
      }
   }
}

void UtQtGL2DPlot::ComputeTickPositions()
{
   mXAxisTicks.clear();
   mYAxisTicks.clear();
   mYAxisTicks2.clear();

   int gridWidth  = mPlotRight_pixels - mPlotLeft_pixels;
   int gridHeight = mPlotTop_pixels - mPlotBottom_pixels;

   if (mUseTickMarkIncrementX)
   {
      if ((mMaxXBoundary - mMinXBoundary) != 0 && mTickMarkIncrementX != 0)
      {
         if (mLeftJustifiedXTicks)
         {
            double tickWidth = (mTickMarkIncrementX * gridWidth) / (mMaxXBoundary - mMinXBoundary);
            int    numTicks  = (mMaxXBoundary - mMinXBoundary) / mTickMarkIncrementX;
            double count     = 0;

            while (count <= numTicks)
            {
               mXAxisTicks.emplace_back(mPlotLeft_pixels + (count * tickWidth),
                                        mMinXBoundary + count * mTickMarkIncrementX);
               count++;
            }
         }
         else
         {
            double tickMarkStartValue = ((int)(mMinXBoundary / mTickMarkIncrementX)) * mTickMarkIncrementX;
            // if tickMarkStartValue is less than the min boundary add one increment to it so that start value is
            // greater than the min boundary
            if (tickMarkStartValue < mMinXBoundary)
            {
               tickMarkStartValue += mTickMarkIncrementX;
            }

            double curTickMarkValue = tickMarkStartValue;
            while (curTickMarkValue <= mMaxXBoundary)
            {
               double tickMarkLocation = (curTickMarkValue - mMinXBoundary) / (mMaxXBoundary - mMinXBoundary) * gridWidth;
               mXAxisTicks.emplace_back(mPlotLeft_pixels + tickMarkLocation, curTickMarkValue);
               curTickMarkValue += mTickMarkIncrementX;
            }
         }
      }
   }
   else if (mTickMarkNumberX != 0)
   {
      for (unsigned int i = 0; i < mTickMarkNumberX - 1; ++i)
      {
         double value = mMinXBoundary + i * (mMaxXBoundary - mMinXBoundary) / (mTickMarkNumberX - 1);
         mXAxisTicks.emplace_back(mPlotLeft_pixels + ((gridWidth * (int)i) / ((int)mTickMarkNumberX - 1)), value);
      }
      // Handle last one slightly different to prevent any rounding error that may cause last tick to not line up.
      if (mTickMarkNumberX > 1)
      {
         mXAxisTicks.emplace_back(mPlotRight_pixels, mMaxXBoundary);
      }
   }

   if (mUseTickMarkIncrementY)
   {
      if ((mMaxYBoundary - mMinYBoundary) != 0 && mTickMarkIncrementY != 0)
      {
         if (mBottomJustifiedYTicks)
         {
            double tickHeight = (mTickMarkIncrementY * gridHeight) / (mMaxYBoundary - mMinYBoundary);
            int    numTicks   = (mMaxYBoundary - mMinYBoundary) / mTickMarkIncrementY;
            double count      = 0;

            while (count <= numTicks)
            {
               mYAxisTicks.emplace_back(mPlotBottom_pixels + (count * tickHeight),
                                        mMinYBoundary + count * mTickMarkIncrementY);
               count++;
            }
         }
         else
         {
            double tickMarkStartValue = ((int)(mMinYBoundary / mTickMarkIncrementY)) * mTickMarkIncrementY;
            if (tickMarkStartValue < mMinYBoundary)
            {
               tickMarkStartValue += mTickMarkIncrementY;
            }

            double curTickMarkValue = tickMarkStartValue;
            while (curTickMarkValue <= mMaxYBoundary)
            {
               double tickMarkLocation = (curTickMarkValue - mMinYBoundary) / (mMaxYBoundary - mMinYBoundary) * gridHeight;
               mYAxisTicks.emplace_back(mPlotBottom_pixels + tickMarkLocation, curTickMarkValue);
               curTickMarkValue += mTickMarkIncrementY;
            }
         }
      }
   }
   else if (mTickMarkNumberY != 0)
   {
      for (unsigned int i = 0; i < mTickMarkNumberY - 1; ++i)
      {
         double value = mMinYBoundary + i * (mMaxYBoundary - mMinYBoundary) / (mTickMarkNumberY - 1);
         mYAxisTicks.emplace_back(mPlotBottom_pixels + ((gridHeight * (int)i) / ((int)mTickMarkNumberY - 1)), value);
      }
      // Handle last one slightly different to prevent any rounding error that may cause last tick to not line up.
      if (mTickMarkNumberY > 1)
      {
         mYAxisTicks.emplace_back(mPlotTop_pixels, mMaxYBoundary);
      }
   }

   if (mUseTickMarkIncrementY2)
   {
      if ((mMaxYBoundary2 - mMinYBoundary2) != 0 && mTickMarkIncrementY2 != 0)
      {
         if (mBottomJustifiedYTicks2)
         {
            double tickHeight = (mTickMarkIncrementY2 * gridHeight) / (mMaxYBoundary2 - mMinYBoundary2);
            int    numTicks   = (mMaxYBoundary2 - mMinYBoundary2) / mTickMarkIncrementY2;
            double count      = 0;

            while (count <= numTicks)
            {
               mYAxisTicks2.emplace_back(mPlotBottom_pixels + (count * tickHeight),
                                         mMinYBoundary2 + count * mTickMarkIncrementY2);
               count++;
            }
         }
         else
         {
            double tickMarkStartValue = ((int)(mMinYBoundary2 / mTickMarkIncrementY2)) * mTickMarkIncrementY2;
            if (tickMarkStartValue < mMinYBoundary2)
            {
               tickMarkStartValue += mTickMarkIncrementY2;
            }

            double curTickMarkValue = tickMarkStartValue;
            while (curTickMarkValue <= mMaxYBoundary2)
            {
               double tickMarkLocation =
                  (curTickMarkValue - mMinYBoundary2) / (mMaxYBoundary2 - mMinYBoundary2) * gridHeight;
               mYAxisTicks2.emplace_back(mPlotBottom_pixels + tickMarkLocation, curTickMarkValue);
               curTickMarkValue += mTickMarkIncrementY2;
            }
         }
      }
   }
   else if (mTickMarkNumberY2 != 0)
   {
      for (unsigned int i = 0; i < mTickMarkNumberY2 - 1; ++i)
      {
         double value = mMinYBoundary2 + i * (mMaxYBoundary2 - mMinYBoundary2) / (mTickMarkNumberY2 - 1);
         mYAxisTicks2.emplace_back(mPlotBottom_pixels + ((gridHeight * (int)i) / ((int)mTickMarkNumberY2 - 1)), value);
      }
      // Handle last one slightly different to prevent any rounding error that may cause last tick to not line up.
      if (mTickMarkNumberY2 > 1)
      {
         mYAxisTicks2.emplace_back(mPlotTop_pixels, mMaxYBoundary2);
      }
   }
}

void UtQtGL2DPlot::DrawTickMarks()
{
   // Only draw tick marks if requested
   if (mTickMarkPosition != NONE)
   {
      glPushMatrix();
      {
         glTranslated((double)(mDisplayWidth)*0.5, (double)(mDisplayHeight)*0.5, 0.0);

         glLineWidth(mTickWidth);
         glColor4f(mTickColor.redF(), mTickColor.greenF(), mTickColor.blueF(), mTickColor.alphaF());
         glBegin(GL_LINES);
         {
            int yAxesTickMarkLeftSide, yAxesTickMarkRightSide, xAxesTickMarkBottomSide;
            if (mTickMarkPosition == EXTERIOR)
            {
               yAxesTickMarkLeftSide   = (mPlotLeft_percent - cTickMarkLength) * mDisplayWidth - mDisplayWidth / 2;
               xAxesTickMarkBottomSide = (mPlotBottom_percent - cTickMarkLength) * mDisplayHeight - mDisplayHeight / 2;
               yAxesTickMarkRightSide  = (mPlotRight_percent + cTickMarkLength) * mDisplayWidth - mDisplayWidth / 2;
            }
            else // INTERIOR
            {
               yAxesTickMarkLeftSide   = (mPlotLeft_percent + cTickMarkLength) * mDisplayWidth - mDisplayWidth / 2;
               xAxesTickMarkBottomSide = (mPlotBottom_percent + cTickMarkLength) * mDisplayHeight - mDisplayHeight / 2;
               yAxesTickMarkRightSide  = (mPlotRight_percent - cTickMarkLength) * mDisplayWidth - mDisplayWidth / 2;
            }

            for (auto& iter : mXAxisTicks)
            {
               glVertex2i(iter.first, mPlotBottom_pixels);
               glVertex2i(iter.first, xAxesTickMarkBottomSide);
            }

            for (auto& iter : mYAxisTicks)
            {
               glVertex2i(yAxesTickMarkLeftSide, iter.first);
               glVertex2i(mPlotLeft_pixels, iter.first);
            }

            if (mEnableSecondaryAxis)
            {
               for (auto& iter : mYAxisTicks2)
               {
                  glVertex2i(yAxesTickMarkRightSide, iter.first);
                  glVertex2i(mPlotRight_pixels, iter.first);
               }
            }
         }
         glEnd();
      }
      glPopMatrix();
   }
}

void UtQtGL2DPlot::DrawLabels(QPainter* aPainter)
{
   QFont font                = qApp->font();
   int   tickmarkLabelHeight = 0;
   int   tickmarkLabelWidth  = 0;
   int   tickmarkLabelWidth2 = 0;

   font.setPointSize(mTickMarkFontSize);
   QFontMetrics fm(font);
   aPainter->setFont(font);
   aPainter->setPen(mTextColor);

   if (mTickMarkShowLabel)
   {
      for (auto& iter : mXAxisTicks)
      {
         QString text        = QString::number(iter.second, 'g', mSignificantDigits);
         tickmarkLabelHeight = fm.height();
         RenderText(aPainter,
                    iter.first + (mDisplayWidth / 2),
                    (mPlotBottom_percent - cTickMarkLength) * mDisplayHeight,
                    text,
                    Qt::AlignHCenter | Qt::AlignTop,
                    0);
      }

      for (auto& iter : mYAxisTicks)
      {
         QString text = QString::number(iter.second, 'g', mSignificantDigits);
         RenderText(aPainter,
                    (mPlotLeft_percent - cTickMarkLength) * mDisplayWidth,
                    iter.first + (mDisplayHeight / 2),
                    text,
                    Qt::AlignRight | Qt::AlignVCenter,
                    0);

         if (fm.width(text) > tickmarkLabelWidth)
         {
            tickmarkLabelWidth = fm.width(text);
         }
      }

      if (mEnableSecondaryAxis)
      {
         for (auto& iter : mYAxisTicks2)
         {
            QString text = QString::number(iter.second, 'g', mSignificantDigits);
            RenderText(aPainter,
                       (mPlotRight_percent + cTextLabelOffset) * mDisplayWidth,
                       iter.first + (mDisplayHeight / 2),
                       text,
                       Qt::AlignLeft | Qt::AlignVCenter,
                       0);

            if (fm.width(text) > tickmarkLabelWidth2)
            {
               tickmarkLabelWidth2 = fm.width(text);
            }
         }
      }
   }

   font.setPointSize(mLabelFontSize);
   aPainter->setFont(font);
   // tickmarkLabelHeight is the height of the tickmark label on the X axis which are aligned top at .09 * mDisplayHeight
   int labelLimitXAxis     = mPlotBottom_percent * mDisplayHeight - tickmarkLabelHeight;
   int bottomLabelPosition = std::min(labelLimitXAxis, (int)(mDisplayHeight * cBottomLabelPosition));

   QColor color = GetLabelColor(TITLE);
   aPainter->setPen(color);
   RenderText(aPainter,
              .5 * mDisplayWidth,
              cTitleLabelPosition * mDisplayHeight,
              mLabelStrings[TITLE],
              Qt::AlignHCenter | Qt::AlignVCenter,
              0);

   color = GetLabelColor(TOP);
   aPainter->setPen(color);
   RenderText(aPainter,
              .5 * mDisplayWidth,
              cTopLabelPosition * mDisplayHeight,
              mLabelStrings[TOP],
              Qt::AlignHCenter | Qt::AlignVCenter,
              0);

   color = GetLabelColor(LEFT);
   aPainter->setPen(color);
   RenderText(aPainter, mLeftLabelPosition, .5 * mDisplayHeight, mLabelStrings[LEFT], Qt::AlignHCenter | Qt::AlignBottom, 90);

   color = GetLabelColor(RIGHT);
   aPainter->setPen(color);
   RenderText(aPainter, mRightLabelPosition, .5 * mDisplayHeight, mLabelStrings[RIGHT], Qt::AlignHCenter | Qt::AlignTop, 90);

   color = GetLabelColor(BOTTOM);
   aPainter->setPen(color);
   RenderText(aPainter, .5 * mDisplayWidth, bottomLabelPosition, mLabelStrings[BOTTOM], Qt::AlignHCenter | Qt::AlignTop, 0);
}

void UtQtGL2DPlot::RenderText(QPainter* aPainter, int aX, int aY, const QString& aText, int aJust, float aRot)
{
   QFontMetrics fm(aPainter->font());
   int          x = 0;
   int          y = 0;
   if (aJust & Qt::AlignLeft)
   {
      x = 0;
   }
   else if (aJust & Qt::AlignHCenter)
   {
      x = -fm.width(aText) * 0.5;
   }
   else if (aJust & Qt::AlignRight)
   {
      x = -fm.width(aText);
   }
   if (aJust & Qt::AlignTop)
   {
      y = fm.height();
   }
   else if (aJust & Qt::AlignVCenter)
   {
      y = fm.height() * 0.5;
   }
   else if (aJust & Qt::AlignBottom)
   {
      y = 0;
   }
   aPainter->translate(aX, mDisplayHeight - aY);
   aPainter->rotate(-aRot);
   aPainter->translate(x, y);
   aPainter->drawText(0, 0, aText);
   aPainter->translate(-x, -y);
   aPainter->rotate(aRot);
   aPainter->translate(-aX, -mDisplayHeight + aY);
}

void UtQtGL2DPlot::SetSeriesName(QString aName, unsigned int aSeriesNum)
{
   FindOrMakeSeries(aSeriesNum).SetName(aName);
   emit SeriesNameChanged(aSeriesNum);
}

void UtQtGL2DPlot::SetSeriesColor(QColor aColor, unsigned int aSeriesNum)
{
   FindOrMakeSeries(aSeriesNum).mColor = aColor;
   emit SeriesColorChanged(aSeriesNum);
}

QString UtQtGL2DPlot::GetSeriesName(unsigned int aSeriesNum) const
{
   // if series exist
   if (mData.count(aSeriesNum) != 0)
   {
      return mData.at(aSeriesNum)->Name();
   }
   return "";
}

bool UtQtGL2DPlot::GetSeriesNumberFromSeriesName(QString aName, unsigned int& aSeriesNum) const
{
   for (const auto& iter : mData)
   {
      if (iter.second->Name() == aName)
      {
         aSeriesNum = ut::safe_cast<unsigned int, int>(iter.first);
         return true;
      }
   }
   return false;
}

void UtQtGL2DPlot::SetSeriesUseSecondaryAxis(bool aUseSecondaryAxis, unsigned int aSeriesNum)
{
   FindOrMakeSeries(aSeriesNum).mIsSecondaryAxis = aUseSecondaryAxis;
   UpdateSecondaryAxisVisibility();
}

bool UtQtGL2DPlot::GetSeriesUseSecondaryAxis(unsigned int aSeriesNum) const
{
   if (FindSeries(aSeriesNum))
   {
      return FindSeries(aSeriesNum)->mIsSecondaryAxis;
   }
   return false;
}

void UtQtGL2DPlot::SetAllSeriesVisible(bool aVisible)
{
   for (auto& iter : mData)
   {
      iter.second->mVisible = aVisible;
   }
   UpdateSecondaryAxisVisibility();
}

void UtQtGL2DPlot::SetSeriesVisible(bool aVisible, unsigned int aSeriesNum)
{
   FindOrMakeSeries(aSeriesNum).mVisible = aVisible;
   UpdateSecondaryAxisVisibility();
}

bool UtQtGL2DPlot::GetSeriesVisible(unsigned int aSeriesNum) const
{
   const SeriesBase* seriesPtr = FindSeries(aSeriesNum);
   if (seriesPtr)
   {
      return seriesPtr->mVisible;
   }
   return true;
}

bool UtQtGL2DPlot::WriteDataToFile(QString aFilename)
{
   bool retVal = true;

   QFile file(aFilename);
   if (file.open(QIODevice::WriteOnly))
   {
      QTextStream out(&file);

      for (const auto& seriesIter : mData)
      {
         QString xAxisName = "X";
         QString yAxisName = "Y";

         if (mLabelStrings[BOTTOM] != "")
         {
            xAxisName = mLabelStrings[BOTTOM];
         }

         if (seriesIter.second->mIsSecondaryAxis)
         {
            if (mLabelStrings[RIGHT] != "")
            {
               yAxisName = mLabelStrings[RIGHT];
            }
         }
         else if (mLabelStrings[LEFT] != "")
         {
            yAxisName = mLabelStrings[LEFT];
         }

         out << seriesIter.second->Name() << endl;
         out << xAxisName << ",";
         seriesIter.second->WriteCSV_X(out);
         out << yAxisName << ",";
         seriesIter.second->WriteCSV_Y(out);
      }
   }
   else
   {
      retVal = false;
   }
   file.close();

   return retVal;
}

void UtQtGL2DPlot::SetTitle(QString aTitle)
{
   SetLabelText(TITLE, aTitle);
}

void UtQtGL2DPlot::SetTitle(QString aTitle, QColor aColor)
{
   SetLabelText(TITLE, aTitle, aColor);
}

void UtQtGL2DPlot::SetLabelXAxis(QString aLabel)
{
   SetLabelText(BOTTOM, aLabel);
}

void UtQtGL2DPlot::SetLabelXAxis(QString aLabel, QColor aColor)
{
   SetLabelText(BOTTOM, aLabel, aColor);
}

void UtQtGL2DPlot::SetLabelYAxis(QString aLabel)
{
   SetLabelText(LEFT, aLabel);
}

void UtQtGL2DPlot::SetLabelYAxis(QString aLabel, QColor aColor)
{
   SetLabelText(LEFT, aLabel, aColor);
}

void UtQtGL2DPlot::SetLabelFontSize(int aScale)
{
   mLabelFontSize = aScale;
}

void UtQtGL2DPlot::SetLabelText(LabelPos aLabel, QString aText)
{
   mLabelStrings[aLabel] = aText;
   // JLT I don't think we want to revert to default if no color is specified,
   //     I think we want to use the most recently specified color instead.
   //     Therefore do not remove the color from mLabelColors.
   //    std::map<LabelPos, QColor>::iterator iter = mLabelColors.find(aLabel);
   //    if (iter != mLabelColors.end())
   //    {
   //       mLabelColors.erase(iter);
   //    }
}

void UtQtGL2DPlot::SetLabelText(LabelPos aLabel, QString aText, QColor aColor)
{
   mLabelStrings[aLabel] = aText;
   mLabelColors[aLabel]  = aColor;
}

QString UtQtGL2DPlot::GetLabelText(LabelPos aLabel)
{
   return mLabelStrings[aLabel];
}

const QColor& UtQtGL2DPlot::GetLabelColor(LabelPos aLabel)
{
   auto iter = mLabelColors.find(aLabel);
   if (iter != mLabelColors.end())
   {
      return iter->second;
   }
   else
   {
      return mTextColor;
   }
}

void UtQtGL2DPlot::SetTickMarkDisplay(TickMarkPos aInput)
{
   if (aInput != mTickMarkPosition)
   {
      mTickMarkPosition = aInput;
   }
}

void UtQtGL2DPlot::SetTickIncrementX(double aInput)
{
   mUseTickMarkIncrementX = true;
   if (aInput >= 0.0)
   {
      mTickMarkIncrementX = aInput;
   }
}

void UtQtGL2DPlot::SetTickJustifiedX(bool aJustified)
{
   mLeftJustifiedXTicks = aJustified;
}

double UtQtGL2DPlot::GetTickIncrementX() const
{
   if (mUseTickMarkIncrementX)
   {
      return mTickMarkIncrementX;
   }
   else
   {
      return 0;
   }
}

void UtQtGL2DPlot::SetTickIncrementY(double aInput)
{
   mUseTickMarkIncrementY = true;
   if (aInput >= 0.0)
   {
      mTickMarkIncrementY = aInput;
   }
}

void UtQtGL2DPlot::SetTickJustifiedY(bool aJustified)
{
   mBottomJustifiedYTicks = aJustified;
}

void UtQtGL2DPlot::SetTickIncrementY2(double aInput)
{
   mUseTickMarkIncrementY2 = true;
   if (aInput >= 0.0)
   {
      mTickMarkIncrementY2 = aInput;
   }
}

void UtQtGL2DPlot::SetTickJustifiedY2(bool aJustified)
{
   mBottomJustifiedYTicks2 = aJustified;
}

double UtQtGL2DPlot::GetTickIncrementY() const
{
   if (mUseTickMarkIncrementY)
   {
      return mTickMarkIncrementY;
   }
   else
   {
      return 0;
   }
}

double UtQtGL2DPlot::GetTickIncrementY2() const
{
   if (mUseTickMarkIncrementY2)
   {
      return mTickMarkIncrementY2;
   }
   else
   {
      return 0;
   }
}

// Dont call SetNumberOfTicksX() and SetNumberOfTicksY() to reduce calls to UpdateTickMarks()
void UtQtGL2DPlot::SetTickCount(unsigned int aNumTicks)
{
   mUseTickMarkIncrementX  = false;
   mUseTickMarkIncrementY  = false;
   mUseTickMarkIncrementY2 = false;
   mTickMarkNumberX        = aNumTicks;
   mTickMarkNumberY        = aNumTicks;
   mTickMarkNumberY2       = aNumTicks;
}

void UtQtGL2DPlot::SetTickCountX(unsigned int aNumTicks)
{
   mUseTickMarkIncrementX = false;
   mTickMarkNumberX       = aNumTicks;
}

double UtQtGL2DPlot::GetTickCountX() const
{
   if (mUseTickMarkIncrementX)
   {
      return 0;
   }
   else
   {
      return mTickMarkNumberX;
   }
}

void UtQtGL2DPlot::SetTickCountY(unsigned int aNumTicks)
{
   mUseTickMarkIncrementY = false;
   mTickMarkNumberY       = aNumTicks;
}

void UtQtGL2DPlot::SetTickCountY2(unsigned int aNumTicks)
{
   mUseTickMarkIncrementY2 = false;
   mTickMarkNumberY2       = aNumTicks;
}

double UtQtGL2DPlot::GetTickCountY() const
{
   if (mUseTickMarkIncrementY)
   {
      return 0;
   }
   else
   {
      return mTickMarkNumberY;
   }
}

double UtQtGL2DPlot::GetTickCountY2() const
{
   if (mUseTickMarkIncrementY2)
   {
      return 0;
   }
   else
   {
      return mTickMarkNumberY2;
   }
}

void UtQtGL2DPlot::SetNumberOfSignificantDigitsOnLabels(unsigned int aNumberDigits)
{
   if (mSignificantDigits != aNumberDigits)
   {
      mSignificantDigits = aNumberDigits;
   }
}

float UtQtGL2DPlot::GetSeriesWidth(int aSeriesNum) const
{
   const SeriesBase* series = FindSeries(aSeriesNum);
   if (series)
   {
      return series->mWidth;
   }
   return 1.0f; // Default width
}

QColor UtQtGL2DPlot::GetSeriesColor(int aSeriesNum) const
{
   const SeriesBase* series = FindSeries(aSeriesNum);
   if (series)
   {
      return series->mColor;
   }
   else
   {
      return QColor(); // Default color
   }
}

UtQtGL2DPlot::StipplePattern UtQtGL2DPlot::GetSeriesStipple(int aSeriesNum) const
{
   const SeriesBase* series = FindSeries(aSeriesNum);
   if (series)
   {
      return series->mStipple;
   }
   else
   {
      return NO_STIPPLE; // Default Stipple
   }
}

// helper class to add data
class UtQtGLDPlot_PointAdder
{
public:
   // Load current min/max boundaries
   double                lMinX{std::numeric_limits<double>::max()};
   double                lMaxX{0.0};
   double                lMinY{std::numeric_limits<double>::max()};
   double                lMaxY{0.0};
   int                   mSeriesNum;
   UtQtGL2DPlot*         mPlot;
   UtQtGL2DPlot::Series* mSeriesPtr;
   bool                  mResize;
   bool                  mSecondaryAxis;
   // this is the first addition to the series
   bool mCreatedSeries;

   UtQtGLDPlot_PointAdder(UtQtGL2DPlot& aPlot, int aSeriesNum, bool aResize)
   {
      mSeriesNum     = aSeriesNum;
      mResize        = aResize;
      mPlot          = &aPlot;
      mSecondaryAxis = aPlot.GetSeriesUseSecondaryAxis(aSeriesNum);
      if (mResize)
      {
         lMinX = aPlot.mMinXBoundary;
         lMaxX = aPlot.mMaxXBoundary;
         lMinY = aPlot.GetYMinBoundary(mSecondaryAxis);
         lMaxY = aPlot.GetYMaxBoundary(mSecondaryAxis);
      }
      mSeriesPtr = (UtQtGL2DPlot::Series*)(&aPlot.FindOrMakeSeries(aSeriesNum)); // JEM NOTE: this could fail if it is
                                                                                 // not a standard series!
      mCreatedSeries = mSeriesPtr->data.empty();
   }

   void AddPoint(const UtQtGL2DPlot::DataPt& aPoint)
   {
      mSeriesPtr->data.push_back(aPoint);

      // If resizing is allowed
      if (mResize)
      {
         // expand the Axes Boundaries
         lMinX = std::min(aPoint.x, lMinX);
         lMaxX = std::max(aPoint.x, lMaxX);
         lMinY = std::min(aPoint.y, lMinY);
         lMaxY = std::max(aPoint.y, lMaxY);
      }
   }

   void Commit()
   {
      if (mResize)
      {
         // Set the new bounds
         if (mSecondaryAxis)
         {
            mPlot->SetAxesBounds2(lMinX, lMinY, lMaxX, lMaxY);
         }
         else
         {
            mPlot->SetAxesBounds(lMinX, lMinY, lMaxX, lMaxY);
         }
      }
   }
};

bool UtQtGL2DPlot::AddPoint(const DataPt& aPt, unsigned int aSeriesNum)
{
   if (!aPt.IsReal())
   {
      return false;
   }
   UtQtGLDPlot_PointAdder adder(*this, aSeriesNum, mAbleToBeAutoResized);
   adder.AddPoint(aPt);
   adder.Commit();
   return true;
}

bool UtQtGL2DPlot::AddPoint(double aX, double aY, unsigned int aSeriesNum)
{
   return AddPoint(DataPt(aX, aY), aSeriesNum);
}

bool UtQtGL2DPlot::AddPointWithColor(double aX, double aY, double aZ, unsigned int aSeriesNum)
{
   return AddPoint(DataPt(aX, aY, aZ), aSeriesNum);
}

bool UtQtGL2DPlot::AddPoints(const std::vector<DataPt>& aPoints, unsigned int aSeriesNum)
{
   bool                   pointsAreValid = true;
   UtQtGLDPlot_PointAdder adder(*this, aSeriesNum, mAbleToBeAutoResized);
   for (const DataPt& p : aPoints)
   {
      if (p.IsReal())
      {
         adder.AddPoint(p);
      }
      else
      {
         pointsAreValid = false;
      }
   }
   adder.Commit();
   return pointsAreValid;
}

bool UtQtGL2DPlot::AddPoints(const std::vector<std::pair<double, double>>& aPoints, unsigned int aSeriesNum, bool aFlipAxis)
{
   bool                   pointsAreValid = true;
   UtQtGLDPlot_PointAdder adder(*this, aSeriesNum, mAbleToBeAutoResized);
   for (const auto& aPoint : aPoints)
   {
      DataPt p;

      if (aFlipAxis)
      {
         p.x = aPoint.second;
         p.y = aPoint.first;
      }
      else
      {
         p.x = aPoint.first;
         p.y = aPoint.second;
      }

      if (p.IsReal())
      {
         adder.AddPoint(p);
      }
      else
      {
         pointsAreValid = false;
      }
   }
   adder.Commit();
   return pointsAreValid;
}

bool UtQtGL2DPlot::AddPoints(const std::map<double, double>& aPoints, unsigned int aSeriesNum, bool aFlipAxis)
{
   bool                   pointsAreValid = true;
   UtQtGLDPlot_PointAdder adder(*this, aSeriesNum, mAbleToBeAutoResized);

   for (const auto& aPoint : aPoints)
   {
      DataPt p;

      if (aFlipAxis)
      {
         p.x = aPoint.second;
         p.y = aPoint.first;
      }
      else
      {
         p.x = aPoint.first;
         p.y = aPoint.second;
      }

      if (p.IsReal())
      {
         adder.AddPoint(p);
      }
      else
      {
         pointsAreValid = false;
      }
   }
   adder.Commit();
   return pointsAreValid;
}

bool UtQtGL2DPlot::AddPoints(const std::vector<double>& aX, const std::vector<double>& aY, unsigned int aSeriesNum /*= 1*/)
{
   if (aX.size() != aY.size())
   {
      return false;
   }

   bool                   pointsAreValid = true;
   UtQtGLDPlot_PointAdder adder(*this, aSeriesNum, mAbleToBeAutoResized);
   for (size_t i = 0; i < aX.size(); ++i)
   {
      DataPt p;
      p.x = aX[i];
      p.y = aY[i];

      if (p.IsReal())
      {
         adder.AddPoint(p);
      }
      else
      {
         pointsAreValid = false;
      }
   }
   adder.Commit();
   return pointsAreValid;
}

// For backwards compatibility.  Prefer to use AddPoints()
bool UtQtGL2DPlot::AddPointsWithColor(const std::vector<std::pair<double, double>>& aPoints,
                                      const std::vector<double>&                    aZValues,
                                      unsigned int                                  aSeriesNum)
{
   if (aPoints.size() == aZValues.size())
   {
      std::vector<DataPt> pts;
      for (size_t i = 0; i < aPoints.size(); ++i)
      {
         pts.emplace_back(aPoints[i].first, aPoints[i].second, aZValues[i]);
      }
      return AddPoints(pts, aSeriesNum);
   }
   return false;
}

bool UtQtGL2DPlot::InsertPoint(unsigned int aIndex, double aX, double aY, unsigned int aSeriesNum)
{
   if (mData.count(aSeriesNum) != 0)
   {
      if (mData.at(aSeriesNum)->mType == SeriesBase::eStandardSeries)
      {
         Series*      ser   = (Series*)mData.at(aSeriesNum);
         unsigned int count = 0;
         for (auto iter = ser->data.begin(); iter != ser->data.end(); ++iter)
         {
            if (aIndex == count)
            {
               ser->data.insert(iter, DataPt(aX, aY));
               emit DataPointAdded(aSeriesNum, aIndex);
               return true;
            }
            count++;
         }
      }
   }
   return false;
}

bool UtQtGL2DPlot::ChangePoint(unsigned int aIndex, double aX, double aY, unsigned int aSeriesNum)
{
   if (mData.count(aSeriesNum) != 0)
   {
      if (mData.at(aSeriesNum)->mType == SeriesBase::eStandardSeries)
      {
         Series*      ser   = (Series*)mData.at(aSeriesNum);
         unsigned int count = 0;
         for (auto& iter : ser->data)
         {
            if (aIndex == count)
            {
               iter.x = aX;
               iter.y = aY;
               emit DataPointEdited(aSeriesNum, aIndex);
               return true;
            }
            count++;
         }
      }
   }
   return false;
}

bool UtQtGL2DPlot::RemovePoint(unsigned int aIndex, unsigned int aSeriesNum)
{
   if (mData.count(aSeriesNum) != 0)
   {
      if (mData.at(aSeriesNum)->mType == SeriesBase::eStandardSeries)
      {
         Series*      ser   = (Series*)mData.at(aSeriesNum);
         unsigned int count = 0;
         for (auto iter = ser->data.begin(); iter != ser->data.end(); ++iter)
         {
            if (aIndex == count)
            {
               ser->data.erase(iter);
               emit DataPointDeleted(aSeriesNum, aIndex);
               return true;
            }
            count++;
         }
      }
   }
   return false;
}

void UtQtGL2DPlot::TranslatePointFromRealToScene(unsigned int aSeriesNum,
                                                 double       aInputX,
                                                 double       aInputY,
                                                 double&      aOutputX,
                                                 double&      aOutputY)
{
   TranslatePointFromRealToScene(aInputX, aInputY, aOutputX, aOutputY, GetSeriesUseSecondaryAxis(aSeriesNum));
}

void UtQtGL2DPlot::TranslatePointFromRealToScene(const SeriesBase& aSeries,
                                                 double            aInputX,
                                                 double            aInputY,
                                                 double&           aOutputX,
                                                 double&           aOutputY)
{
   TranslatePointFromRealToScene(aInputX, aInputY, aOutputX, aOutputY, aSeries.mIsSecondaryAxis);
}

void UtQtGL2DPlot::TranslatePointFromRealToScene(double  aInputX,
                                                 double  aInputY,
                                                 double& aOutputX,
                                                 double& aOutputY,
                                                 bool    aUseSecondaryAxis)
{
   double realHeight, yMin;
   double realWidth = mMaxXBoundary - mMinXBoundary;

   if (aUseSecondaryAxis)
   {
      realHeight = mMaxYBoundary2 - mMinYBoundary2;
      yMin       = mMinYBoundary2;
   }
   else
   {
      realHeight = mMaxYBoundary - mMinYBoundary;
      yMin       = mMinYBoundary;
   }

   // Scale the point to fit within the Scene size
   if (realHeight == 0)
   {
      aOutputY = .5 * (mPlotTop_pixels - mPlotBottom_pixels) + mPlotBottom_pixels; // doesnt this always equal 0?
   }
   else
   {
      aOutputY = mPlotBottom_pixels + (((aInputY - yMin) / realHeight) * (mPlotTop_pixels - mPlotBottom_pixels));
   }

   if (realWidth == 0)
   {
      aOutputX = .5 * (mPlotRight_pixels - mPlotLeft_pixels) + mPlotLeft_pixels; // doesnt this always equal 0?
   }
   else
   {
      aOutputX = mPlotLeft_pixels + (((aInputX - mMinXBoundary) / realWidth) * (mPlotRight_pixels - mPlotLeft_pixels));
   }
}

QList<std::pair<double, double>> UtQtGL2DPlot::ComputeGridIntercept(double x1, double y1, double x2, double y2)
{
   QList<std::pair<double, double>> points;
   double                           slope = (y1 - y2) / (x1 - x2);

   double xLow, xHigh, yLow, yHigh;
   if (x2 < x1)
   {
      xLow  = std::max(x2, mMinXBoundary);
      xHigh = std::min(x1, mMaxXBoundary);
   }
   else
   {
      xLow  = std::max(x1, mMinXBoundary);
      xHigh = std::min(x2, mMaxXBoundary);
   }

   if (y2 < y1)
   {
      yLow  = std::max(y2, mMinYBoundary);
      yHigh = std::min(y1, mMaxYBoundary);
   }
   else
   {
      yLow  = std::max(y1, mMinYBoundary);
      yHigh = std::min(y2, mMaxYBoundary);
   }

   if (x2 > mMaxXBoundary)
   {
      // Test right side intercept
      double y = y1 - slope * (x1 - mMaxXBoundary);
      if (y >= yLow && y <= yHigh)
      {
         points.push_back(std::make_pair(mMaxXBoundary, y));
      }
   }
   if (x2 < mMinXBoundary)
   {
      // test left side intercept
      double y = y1 - slope * (x1 - mMinXBoundary);
      if (y >= yLow && y <= yHigh)
      {
         points.push_back(std::make_pair(mMinXBoundary, y));
      }
   }
   if (y2 > mMaxYBoundary)
   {
      // test top side intercept
      double x = x1 - (1 / slope) * (y1 - mMaxYBoundary);
      if (x >= xLow && x <= xHigh)
      {
         points.push_back(std::make_pair(x, mMaxYBoundary));
      }
   }
   if (y2 < mMinYBoundary)
   {
      // test bottom side intercept
      double x = x1 - (1 / slope) * (y1 - mMinYBoundary);
      if (x >= xLow && x <= xHigh)
      {
         points.push_back(std::make_pair(x, mMinYBoundary));
      }
   }

   QList<std::pair<double, double>>           retVal;
   QList<std::pair<double, double>>::iterator iter = points.begin();
   double                                     translatedX, translatedY;
   if (iter != points.end())
   {
      TranslatePointFromRealToScene((*iter).first, (*iter).second, translatedX, translatedY);
      retVal.push_back(std::make_pair(translatedX, translatedY));
      retVal.append(ComputeGridIntercept((*iter).first, (*iter).second, x1, y1));
   }
   return retVal;
}

void UtQtGL2DPlot::SetUseMultipleColorsForSeries(bool aInput)
{
   mUseDefaultPens = aInput;
}

int UtQtGL2DPlot::AddOverlayLine(double aSlope, double aIntercept, QColor aColor, int aWidth, StipplePattern aStipple)
{
   if (aSlope == 0)
   {
      return AddHorizontalOverlayLine(aIntercept, aColor, aWidth);
   }
   else
   {
      lineClass newLine(aSlope, aIntercept);
      newLine.mWidth   = aWidth;
      newLine.mColor   = aColor;
      newLine.mStipple = aStipple;
      mOverlayLines.push_back(newLine);
      return newLine.GetId();
   }
}

int UtQtGL2DPlot::AddHorizontalOverlayLine(double aYIntercept, QColor aColor, int aWidth, StipplePattern aStipple)
{
   lineClass newLine(0, aYIntercept);
   newLine.mWidth   = aWidth;
   newLine.mColor   = aColor;
   newLine.mStipple = aStipple;
   mOverlayLines.push_back(newLine);
   return newLine.GetId();
}

int UtQtGL2DPlot::AddVerticalOverlayLine(double aXIntercept, QColor aColor, int aWidth, StipplePattern aStipple)
{
   lineClass newLine(0, aXIntercept, true);
   newLine.mWidth   = aWidth;
   newLine.mColor   = aColor;
   newLine.mStipple = aStipple;
   mOverlayLines.push_back(newLine);
   return newLine.GetId();
}

void UtQtGL2DPlot::RemoveOverlayLine(int aId)
{
   auto iter = mOverlayLines.begin();
   for (; iter != mOverlayLines.end(); ++iter)
   {
      if ((*iter).GetId() == aId)
      {
         // Remove entry
         mOverlayLines.erase(iter);
         // exit for loop
         break;
      }
   }
}

void UtQtGL2DPlot::RemoveAllOverlayLines()
{
   mOverlayLines.clear();
}

int UtQtGL2DPlot::AddOverlayText(QString aText, double aX, double aY, QColor aColor, double aDegrees, int aSize, Qt::Alignment aAlign)
{
   textClass newText(aText, aX, aY);
   newText.mAngle = aDegrees;
   newText.mColor = aColor;
   newText.mAlign = aAlign;
   newText.mSize  = aSize;
   mOverlayText.push_back(newText);
   return newText.GetId();
}

bool UtQtGL2DPlot::ChangeOverlayTextString(int aId, QString aNewText)
{
   for (auto& iter : mOverlayText)
   {
      if (iter.GetId() == aId)
      {
         iter.mText = aNewText;
         return true;
      }
   }
   return false;
}

bool UtQtGL2DPlot::ChangeOverlayTextPosition(int aId, double aX, double aY)
{
   for (auto& iter : mOverlayText)
   {
      if (iter.GetId() == aId)
      {
         iter.mX = aX;
         iter.mY = aY;
         return true;
      }
   }
   return false;
}

bool UtQtGL2DPlot::ChangeOverlayTextColor(int aId, QColor aColor)
{
   for (auto& iter : mOverlayText)
   {
      if (iter.GetId() == aId)
      {
         iter.mColor = aColor;
         return true;
      }
   }
   return false;
}

bool UtQtGL2DPlot::ChangeOverlayTextRotation(int aId, double aDegrees)
{
   for (auto& iter : mOverlayText)
   {
      if (iter.GetId() == aId)
      {
         iter.mAngle = aDegrees;
         return true;
      }
   }
   return false;
}

bool UtQtGL2DPlot::ChangeOverlayTextSize(int aId, int aSize)
{
   for (auto& iter : mOverlayText)
   {
      if (iter.GetId() == aId)
      {
         iter.mSize = aSize;
         return true;
      }
   }
   return false;
}

void UtQtGL2DPlot::RemoveOverlayText(int aId)
{
   for (auto iter = mOverlayText.begin(); iter != mOverlayText.end(); ++iter)
   {
      if (iter->GetId() == aId)
      {
         mOverlayText.erase(iter);
         break;
      }
   }
}

void UtQtGL2DPlot::RemoveAllOverlayText()
{
   mOverlayText.clear();
}

void UtQtGL2DPlot::SetShowSecondaryAxis(bool aShow)
{
   mForceShowSecondaryAxis = aShow;
   UpdateSecondaryAxisVisibility();
}

bool UtQtGL2DPlot::GetShowSecondaryAxis() const
{
   return mForceShowSecondaryAxis;
}

bool UtQtGL2DPlot::IsSecondaryAxisVisible() const
{
   return mEnableSecondaryAxis;
}

void UtQtGL2DPlot::SetAxesBounds(double aMinX, double aMinY, double aMaxX, double aMaxY)
{
   if (aMaxX >= aMinX && aMaxY >= aMinY)
   {
      mMinXBoundary = aMinX;
      mMaxXBoundary = aMaxX;
      mMinYBoundary = aMinY;
      mMaxYBoundary = aMaxY;

      emit BoundsChanged();
   }
}

void UtQtGL2DPlot::SetAxesBounds(double aMinX, double aMinY1, double aMinY2, double aMaxX, double aMaxY1, double aMaxY2)
{
   if (aMaxX >= aMinX && aMaxY1 >= aMinY1 && aMaxY2 >= aMinY2)
   {
      mMinXBoundary  = aMinX;
      mMaxXBoundary  = aMaxX;
      mMinYBoundary  = aMinY1;
      mMaxYBoundary  = aMaxY1;
      mMinYBoundary2 = aMinY2;
      mMaxYBoundary2 = aMaxY2;

      emit BoundsChanged();
   }
}

void UtQtGL2DPlot::SetAxesBounds2(double aMinX, double aMinY, double aMaxX, double aMaxY)
{
   if (aMaxX >= aMinX && aMaxY >= aMinY)
   {
      mMinXBoundary  = aMinX;
      mMaxXBoundary  = aMaxX;
      mMinYBoundary2 = aMinY;
      mMaxYBoundary2 = aMaxY;

      emit BoundsChanged();
   }
}

void UtQtGL2DPlot::SetXAxisBounds(double aMinX, double aMaxX)
{
   if (aMaxX >= aMinX)
   {
      SetAxesBoundsP(aMinX, mMinYBoundary, aMaxX, mMaxYBoundary);
   }
}

void UtQtGL2DPlot::SetYAxisBounds(double aMinY, double aMaxY)
{
   if (aMaxY >= aMinY)
   {
      SetAxesBoundsP(mMinXBoundary, aMinY, mMaxXBoundary, aMaxY);
   }
}

void UtQtGL2DPlot::SetYAxisBounds2(double aMinY, double aMaxY)
{
   if (aMaxY >= aMinY)
   {
      mMinYBoundary2 = aMinY;
      mMaxYBoundary2 = aMaxY;

      emit BoundsChanged();
   }
}

void UtQtGL2DPlot::SetAxesBoundsP(double aMinX, double aMinY, double aMaxX, double aMaxY)
{
   mMinXBoundary = aMinX;
   mMinYBoundary = aMinY;
   mMaxXBoundary = aMaxX;
   mMaxYBoundary = aMaxY;

   emit BoundsChanged();
}

void UtQtGL2DPlot::GetXAxisBounds(double& aMinX, double& aMaxX) const
{
   aMinX = mMinXBoundary;
   aMaxX = mMaxXBoundary;
}

void UtQtGL2DPlot::GetYAxisBounds(double& aMinY, double& aMaxY) const
{
   aMinY = mMinYBoundary;
   aMaxY = mMaxYBoundary;
}

void UtQtGL2DPlot::GetYAxisBounds2(double& aMinY, double& aMaxY) const
{
   aMinY = mMinYBoundary2;
   aMaxY = mMaxYBoundary2;
}

bool UtQtGL2DPlot::GetDataMinMax(double& aMinX, double& aMinY, double& aMaxX, double& aMaxY) const
{
   double dummy1, dummy2;
   return GetDataMinMax(aMinX, aMinY, dummy1, aMaxX, aMaxY, dummy2);
}

bool UtQtGL2DPlot::GetDataMinMax(double& aMinX, double& aMinY1, double& aMinY2, double& aMaxX, double& aMaxY1, double& aMaxY2) const
{
   if (!ContainsData())
   {
      return false;
   }

   aMinX  = std::numeric_limits<double>::max();
   aMinY1 = std::numeric_limits<double>::max();
   aMinY2 = std::numeric_limits<double>::max();
   aMaxX  = std::numeric_limits<double>::lowest();
   aMaxY1 = std::numeric_limits<double>::lowest();
   aMaxY2 = std::numeric_limits<double>::lowest();

   for (const auto& series : mData)
   {
      if (series.second->mVisible)
      {
         double minx;
         double maxx;
         double miny;
         double maxy;
         series.second->GetBounds(minx, maxx, miny, maxy);
         if (minx < aMinX)
         {
            aMinX = minx;
         }
         if (maxx > aMaxX)
         {
            aMaxX = maxx;
         }
         if (series.second->mIsSecondaryAxis)
         {
            if (miny < aMinY2)
            {
               aMinY2 = miny;
            }
            if (maxy > aMaxY2)
            {
               aMaxY2 = maxy;
            }
         }
         else
         {
            if (miny < aMinY1)
            {
               aMinY1 = miny;
            }
            if (maxy > aMaxY1)
            {
               aMaxY1 = maxy;
            }
         }
      }
   }
   return true;
}

void UtQtGL2DPlot::RemoveSeries(int aSeriesNumber)
{
   if (FindSeries(aSeriesNumber))
   {
      SeriesBase* series = mData[aSeriesNumber];
      mData.erase(aSeriesNumber);
      // If there is no data left, clear the plot
      if (mData.empty())
      {
         ClearData();
      }
      delete series;
      emit SeriesRemoved(aSeriesNumber);
   }
}

void UtQtGL2DPlot::MakePlotPretty()
{
   double xMin, xMax, yMin, yMax, yMin2, yMax2;
   if (GetDataMinMax(xMin, yMin, yMin2, xMax, yMax, yMax2)) // returns false if there is no plot
   {
      MakePlotPrettyX(xMin, xMax);
      MakePlotPrettyY(yMin, yMax, yMin2, yMax2);
   }
}

void UtQtGL2DPlot::MakePlotPrettyX()
{
   double xMin, xMax, yMin, yMax, yMin2, yMax2;
   if (GetDataMinMax(xMin, yMin, yMin2, xMax, yMax, yMax2)) // returns false if there is no plot
   {
      MakePlotPrettyX(xMin, xMax);
   }
}

void UtQtGL2DPlot::MakePlotPrettyY()
{
   double xMin, xMax, yMin, yMax, yMin2, yMax2;
   if (GetDataMinMax(xMin, yMin, yMin2, xMax, yMax, yMax2)) // returns false if there is no plot
   {
      MakePlotPrettyY(yMin, yMax, yMin2, yMax2);
   }
}

void UtQtGL2DPlot::MakePlotPrettyX(double aMinX, double aMaxX)
{
   // This function can lock up if Max is actually less than Min.
   double stepSize;
   if (GetPrettyBounds(aMinX, aMaxX, stepSize))
   {
      SetTickIncrementX(stepSize);
      SetXAxisBounds(aMinX, aMaxX);
   }
}

void UtQtGL2DPlot::MakePlotPrettyY(double aMinY, double aMaxY, double aMinY2, double aMaxY2)
{
   double stepSize;

   if (GetPrettyBounds(aMinY, aMaxY, stepSize))
   {
      SetTickIncrementY(stepSize);
      SetYAxisBounds(aMinY, aMaxY);
   }

   if (GetPrettyBounds(aMinY2, aMaxY2, stepSize))
   {
      SetTickIncrementY2(stepSize);
      SetYAxisBounds2(aMinY2, aMaxY2);
   }
}

void UtQtGL2DPlot::SetSeriesPlotStyle(PlotStyle aStyle, unsigned int aSeriesNum)
{
   FindOrMakeSeries(aSeriesNum).mPlotStyle = aStyle;
}

bool UtQtGL2DPlot::SetSeriesPlotStyle(QString aName, PlotStyle aStyle)
{
   SeriesBase* series = FindSeriesP(aName);
   if (series)
   {
      series->mPlotStyle = aStyle;
      return true;
   }
   else
   {
      return false;
   }
}

UtQtGL2DPlot::PlotStyle UtQtGL2DPlot::GetSeriesPlotStyle(int aSeriesNum) const
{
   const SeriesBase* series = FindSeries(aSeriesNum);
   if (series)
   {
      return series->mPlotStyle;
   }
   return GetDefaultPlotStyle();
}

void UtQtGL2DPlot::SetBarWidth(double aPercentage)
{
   if (0 <= aPercentage && aPercentage <= 100)
   {
      mBarWidth = aPercentage;
   }
}

double UtQtGL2DPlot::GetBarWidth(int aSeriesNum)
{
   double      range;
   SeriesBase* series = FindSeriesP(aSeriesNum);
   if (series)
   {
      if (series->mPlotStyle == VERTICAL_BAR)
      {
         range = (mMaxXBoundary - mMinXBoundary);
      }
      else
      {
         range = (mMaxYBoundary - mMinYBoundary);
      }

      if (!UseDefaultBarWidth())
      {
         return range * mBarWidth;
      }
      else
      {
         // Otherwise compute a default Bar width
         // Take a guess at what width to make the bar.  This isn't perfect and will not be pretty in many cases.
         //  It is expected the user would provide a width.
         return range / (2 * series->Size() + 2);
      }
   }
   return 0;
}

bool UtQtGL2DPlot::GetSeriesFill(unsigned int aSeriesNum) const
{
   const SeriesBase* series = FindSeries(aSeriesNum);
   if (series)
   {
      return series->mFill;
   }
   return false;
}

QColor UtQtGL2DPlot::GetSeriesFillColor(unsigned int aSeriesNum) const
{
   const SeriesBase* series = FindSeries(aSeriesNum);
   if (series)
   {
      return series->mFillColor;
   }
   return QColor();
}

// static
bool UtQtGL2DPlot::GetPrettyBounds(double& aMin, double& aMax, double& aStepSize)
{
   // Define an epsilon value to compare range to, to prevent infinite loops.
   //  Problem occurs when aStepSize becomes near zero (10^(-17)) and plotMax only has resolution to 10^-16, thus
   //  plotMax = plotMax - aStepSize still equal plotMax because aStepSize is too small.
   //  This causes an infinite loop.
   constexpr double epsilon = .00000000001;
   if (aMin <= aMax)
   {
      // Compute coordinates
      double range = aMax - aMin;
      if (range < epsilon)
      {
         range = epsilon;
      }

      int count = 0;
      // map range into [1,10], count is the bit shift
      while (range > 10)
      {
         range /= 10;
         count++;
      }
      while (0 < range && range < 1)
      {
         range *= 10;
         count--;
      }

      double numSteps  = floor(range + 1);
      double plotRange = pow(10.0, count) * numSteps;

      while (numSteps <= 5)
      {
         numSteps *= 2;
      }

      aStepSize      = plotRange / numSteps;
      double plotMin = floor(aMin / aStepSize) * aStepSize;
      double plotMax = plotMin + plotRange;

      // If horizontal line, don't shrink the min/max X values as the chart wont look pretty with only 2 tick labels
      if (aMin != aMax)
      {
         while (plotMax >= (aMax + aStepSize))
         {
            plotMax -= aStepSize;
         }
         if (plotMax < aMax)
         {
            plotMax += aStepSize;
         }
      }
      else if (aMin == plotMin) // Special case for horizontal line on top of graph
      {
         plotMin = aMin - 5 * aStepSize;
         plotMax = aMin + 5 * aStepSize;
      }
      else if (aMax == plotMax) // Special case for horizontal line on bottom of graph
      {
         plotMin = aMax - 5 * aStepSize;
         plotMax = aMax + 5 * aStepSize;
      }

      aMin = plotMin;
      aMax = plotMax;
      // aStepSize already set
      return true;
   }
   return false;
}

// static
bool UtQtGL2DPlot::IsDoubleValid(double aNum)
{
   // return early for 0 -- common case for z coordinate
   if (!aNum)
   {
      return true;
   }
   const double maxDoubleVal = DBL_MAX;
   const double minDoubleVal = -maxDoubleVal;
   const bool   numIsNan     = (aNum != aNum);
   const bool   numIsInf     = !(minDoubleVal <= aNum && aNum <= maxDoubleVal);

   return (!numIsNan && !numIsInf);
}

bool UtQtGL2DPlot::AddGrid(const std::vector<double>&              aXValues,
                           const std::vector<double>&              aYValues,
                           const std::vector<std::vector<double>>& aDataValues,
                           unsigned int                            aSeriesNum)
{
   if (!aXValues.empty() && !aYValues.empty() && !aDataValues.empty())
   {
      SeriesBase& series       = FindOrMakeSeries(aSeriesNum);
      series.mPlotStyle        = MIDPOINT_GRID;
      mGridXValues[aSeriesNum] = aXValues;
      mGridYValues[aSeriesNum] = aYValues;
      AddPoint(aXValues.front(), aYValues.front());
      AddPoint(aXValues.front(), aYValues.back());
      AddPoint(aXValues.back(), aYValues.front());
      AddPoint(aXValues.back(), aYValues.back());
      mGridDataValues[aSeriesNum] = aDataValues;
      return true;
   }
   return false;
}

void UtQtGL2DPlot::AddColorInflectionPoint(double aValue, QColor aColor, unsigned int aSeriesNum)
{
   mUseZColor                           = true;
   UtQtGL2DPlot::SeriesBase& seriesBase = FindOrMakeSeries(aSeriesNum);
   if (seriesBase.mType == SeriesBase::eStandardSeries)
   {
      UtQtGL2DPlot::Series& series = (UtQtGL2DPlot::Series&)(seriesBase);
      series.mColorPoints[aValue]  = aColor;
   }
}

void UtQtGL2DPlot::AddColorInflectionPoint(double aValue, int aR, int aG, int aB, unsigned int aSeriesNum)
{
   AddColorInflectionPoint(aValue, QColor(aR, aG, aB), aSeriesNum);
}

QColor UtQtGL2DPlot::GetColorAt(int aSeriesNum, double aValue)
{
   SeriesBase* series = FindSeriesP(aSeriesNum);
   if (!series)
   {
      return QColor();
   }
   return series->GetColorAt(aValue);
}

void UtQtGL2DPlot::ReduceTopPadding(bool aReduced)
{
   mReduceTopPadding = aReduced;
}

void UtQtGL2DPlot::GenerateMidpointGridData(int aSeriesNum)
{
   const std::vector<double>& xValues    = mGridXValues[aSeriesNum];
   const std::vector<double>& yValues    = mGridYValues[aSeriesNum];
   const size_t               xSize      = xValues.size();
   const size_t               ySize      = yValues.size();
   std::vector<double>&       midXValues = mGridMidXValues[aSeriesNum];
   std::vector<double>&       midYValues = mGridMidYValues[aSeriesNum];

   midXValues.clear();
   midYValues.clear();

   for (size_t x = 0; x < xSize; ++x)
   {
      double midX = xValues[x];

      if (x > 0)
      {
         midX = (xValues[x - 1] + xValues[x]) / 2;
      }

      midXValues.push_back(midX);

      if (x == (xSize - 1))
      {
         midXValues.push_back(xValues[x]);
      }
   }

   for (size_t y = 0; y < ySize; ++y)
   {
      double midY = yValues[y];

      if (y > 0)
      {
         midY = (yValues[y - 1] + yValues[y]) / 2;
      }

      midYValues.push_back(midY);

      if (y == (ySize - 1))
      {
         midYValues.push_back(yValues[y]);
      }
   }
}

double UtQtGL2DPlot::GetBoundedX(double aX)
{
   if (aX < mMinXBoundary)
   {
      return mMinXBoundary;
   }
   if (aX > mMaxXBoundary)
   {
      return mMaxXBoundary;
   }
   return aX;
}

double UtQtGL2DPlot::GetBoundedY(double aY)
{
   if (aY < mMinYBoundary)
   {
      return mMinYBoundary;
   }
   if (aY > mMaxYBoundary)
   {
      return mMaxYBoundary;
   }
   return aY;
}

void UtQtGL2DPlot::EnableStippling(StipplePattern aStipple)
{
   if (aStipple == DASHED)
   {
      glLineStipple(1, 0x0F0F);
   }
   else if (aStipple == DOTTED)
   {
      glLineStipple(1, 0x1111);
   }
   else
   {
      glLineStipple(1, 0xFFFF);
   }
   glEnable(GL_LINE_STIPPLE);
}

void UtQtGL2DPlot::DisableStippling()
{
   glDisable(GL_LINE_STIPPLE);
}

void UtQtGL2DPlot::SetPlotBackgroundColor(QColor aColor)
{
   mDrawPlotBackground     = true;
   mPlotBackgroundGradient = false;
   mPlotBackgroundColor    = aColor;
}

void UtQtGL2DPlot::AddPlotBackgroundPoint(double aX, double aY, QColor aColor)
{
   mDrawPlotBackground     = true;
   mPlotBackgroundGradient = true;

   gradientPoint point(aX, aY, aColor);

   if (aX > 1.0)
   {
      point.x = 1.0;
   }
   else if (aX < -1.0)
   {
      point.x = -1.0;
   }

   if (aY > 1.0)
   {
      point.y = 1.0;
   }
   else if (aY < -1.0)
   {
      point.y = -1.0;
   }

   mPlotGradientPoints.push_back(point);
}

void UtQtGL2DPlot::ClearPlotBackground()
{
   mDrawPlotBackground     = false;
   mPlotBackgroundGradient = false;
   mPlotBackgroundColor    = QColor();
   mPlotGradientPoints.clear();
   mBackgroundImage = -1;
}

void UtQtGL2DPlot::SetPlotBackgroundTGA(QString aFilename)
{
   mDrawPlotBackground     = true;
   mPlotBackgroundGradient = false;

   TextureTGA image(aFilename.toStdString().c_str());
   mBackgroundImage = image.GLTexture();
}

void UtQtGL2DPlot::RemoveCurrentPlotBackgroundImage()
{
   mDrawPlotBackground = false;
   mBackgroundImage    = -1;
}

void UtQtGL2DPlot::GetPlotBoundaries(int& aPlotLeft, int& aPlotRight, int& aPlotBottom, int& aPlotTop)
{
   aPlotLeft   = mPlotLeft_pixels;
   aPlotRight  = mPlotRight_pixels;
   aPlotBottom = mPlotBottom_pixels;
   aPlotTop    = mPlotTop_pixels;
}

void UtQtGL2DPlot::UpdateSecondaryAxisVisibility()
{
   if (mForceShowSecondaryAxis)
   {
      mEnableSecondaryAxis = true;
      return;
   }

   for (const auto& series : mData)
   {
      if (series.second->mVisible && series.second->mIsSecondaryAxis)
      {
         mEnableSecondaryAxis = true;
         return;
      }
   }

   mEnableSecondaryAxis = false;
}

void UtQtGL2DPlot::SetShowLegend(bool aInput)
{
   mShowLegend = aInput;
}

void UtQtGL2DPlot::SetLegendPosition(double aX, double aY)
{
   if (aX < 0)
   {
      mLegendXPosition = 0;
   }
   else if (aX > 1)
   {
      mLegendXPosition = 1;
   }
   else
   {
      mLegendXPosition = aX;
   }

   if (aY < 0)
   {
      mLegendYPosition = 0;
   }
   else if (aY > 1)
   {
      mLegendYPosition = 1;
   }
   else
   {
      mLegendYPosition = aY;
   }
}

void UtQtGL2DPlot::SetSeriesShowDataPoints(bool aInput, unsigned int aSeriesNum)
{
   FindOrMakeSeries(aSeriesNum).mShowPoints = aInput;
}

bool UtQtGL2DPlot::GetSeriesShowDataPoints(unsigned int aSeriesNum) const
{
   if (FindSeries(aSeriesNum))
   {
      return FindSeries(aSeriesNum)->mShowPoints;
   }
   return false;
}

void UtQtGL2DPlot::SetSeriesSelected(bool aSelected, unsigned int aSeriesNum)
{
   // Remove all other series selection, only 1 series can be selected at a time
   RemoveAllSeriesSelections();

   SeriesBase* series = FindSeriesP(aSeriesNum);
   if (!series)
   {
      return;
   }

   // Set the series selected
   series->mSeriesSelected = aSelected;
   if (aSelected)
   {
      emit SeriesSelected(aSeriesNum);
   }
}

void UtQtGL2DPlot::RemoveAllSeriesSelections()
{
   for (auto& iter : mData)
   {
      iter.second->mSeriesSelected    = false;
      iter.second->mSelectedDataPoint = -1;
   }
}

void UtQtGL2DPlot::SetDataPointSelected(bool aSelected, unsigned int aIndex, unsigned int aSeriesNum)
{
   SeriesBase* series = FindSeriesP(aSeriesNum);
   if (series)
   {
      // series->seriesSelected = false;

      if (aSelected)
      {
         series->mSelectedDataPoint = aIndex;
         emit DataPointSelected(aSeriesNum, aIndex);
      }
      else
      {
         series->mSelectedDataPoint = -1;
      }
   }
}

void UtQtGL2DPlot::RemoveAllSeriesDataPointSelections()
{
   for (auto& iter : mData)
   {
      iter.second->mSelectedDataPoint = -1;
   }
}

int UtQtGL2DPlot::GetSelectedSeries()
{
   for (auto& iter : mData)
   {
      if (iter.second->mSeriesSelected)
      {
         return iter.first;
      }
   }
   return -1;
}

int UtQtGL2DPlot::GetSelectedDataPoint(unsigned int aSeriesNum)
{
   SeriesBase* series = FindSeriesP(aSeriesNum);
   if (series)
   {
      return series->mSelectedDataPoint;
   }
   return -1;
}

void UtQtGL2DPlot::SetShowCrosshairs(bool aEnable)
{
   mShowCrosshairs = aEnable;
}

void UtQtGL2DPlot::SetCrosshairsValueX(double aXValue)
{
   mUseCrosshairValue = true;
   mCrosshairsValue   = aXValue;
}

void UtQtGL2DPlot::SetCrosshairsPosition(double aPercentage)
{
   mUseCrosshairValue = false;
   mCrosshairsPercent = aPercentage;
}

void UtQtGL2DPlot::SetCrosshairsShowSeries(int aSeriesNum)
{
   mCrosshairShowAllSeries = false;
   mCrosshairSeriesNum     = aSeriesNum;
}

void UtQtGL2DPlot::CalculateValueForSeries(unsigned int aSeriesNum, double aX, QList<double>& aY)
{
   if (mData.count(aSeriesNum) != 0)
   {
      double       px = 0.0;
      double       py = 0.0;
      unsigned int i  = 0;
      if (i < mData.at(aSeriesNum)->Size())
      {
         mData.at(aSeriesNum)->Get(i, px, py);

         if (px == aX)
         {
            aY.push_back(py);
         }
         ++i;
         for (; i < mData.at(aSeriesNum)->Size(); ++i)
         {
            double x = 0.0;
            double y = 0.0;
            mData.at(aSeriesNum)->Get(i, x, y);
            if (aX == x)
            {
               aY.push_back(y);
            }
            else if (px > aX && x <= aX)
            {
               double x1 = x;
               double x2 = px;
               double y1 = y;
               double y2 = py;
               // Linearly extrapolate between the points
               aY.push_back(((aX - x1) / (x2 - x1)) * (y2 - y1) + y1);
            }
            else if (px < aX && x >= aX)
            {
               double x1 = px;
               double x2 = x;
               double y1 = py;
               double y2 = y;
               // Linearly extrapolate between the points
               aY.push_back(((aX - x1) / (x2 - x1)) * (y2 - y1) + y1);
            }
            px = x;
            py = y;
         }
      }
   }
}

void UtQtGL2DPlot::AddModelSeries(QAbstractItemModel* aModelPtr, int aColX, int aColY, unsigned int aSeriesNum)
{
   if (mData.find(aSeriesNum) != mData.end())
   {
      UtQtGL2DPlot::SeriesBase* sb = mData[aSeriesNum];
      delete sb;
   }
   // we just shove our way in here... should I check for vacancy first?
   UtQtAbstractItemModelSeries* series =
      ut::qt::make_qt_ptr<UtQtAbstractItemModelSeries>(aModelPtr, aColX, aColY, aSeriesNum, LINE);
   mData[aSeriesNum]         = series;
   mData[aSeriesNum]->mColor = GetAutoGeneratedColor(aSeriesNum);
   connect(series, &UtQtAbstractItemModelSeries::Redraw, this, &UtQtGL2DPlot::SeriesRedrawRequest);
}

void UtQtGL2DPlot::ClearModelSeries()
{
   std::vector<int> remSet;
   for (auto&& it : mData)
   {
      if (it.second->mType == SeriesBase::eModelViewSeries)
      {
         remSet.push_back(it.first);
      }
   }
   for (auto&& it : remSet)
   {
      RemoveSeries(it);
   }
}

void UtQtGL2DPlot::SeriesRedrawRequest()
{
   UtQtAbstractItemModelSeries* series = (UtQtAbstractItemModelSeries*)(sender());
   emit                         ItemModelSeriesUpdated(series->mSeriesNumber);
}

UtQtGL2DPlot::SeriesBase& UtQtGL2DPlot::FindOrMakeSeries(int aSeriesNumber)
{
   auto i = mData.find(aSeriesNumber);
   if (i != mData.end())
   {
      return *(i->second);
   }
   SeriesBase* series =
      mData.insert(SeriesMap::value_type(aSeriesNumber, new Series(aSeriesNumber, mDefaultPlotStyle))).first->second;
   if (mUseDefaultPens)
   {
      series->mColor = GetAutoGeneratedColor(aSeriesNumber);
   }

   return *series;
}

bool UtQtGL2DPlot::DataPt::IsReal() const
{
   return UtQtGL2DPlot::IsDoubleValid(x) && UtQtGL2DPlot::IsDoubleValid(y) && UtQtGL2DPlot::IsDoubleValid(z);
}

UtQtGL2DPlot::SeriesBase::SeriesBase(int aSeriesNumber, PlotStyle aPlotStyle, SeriesType aType)
   : mSeriesNumber(aSeriesNumber)
   , mVisible(true)
   , mSeriesSelected(false)
   , mShowPoints(false)
   , mFill(false)
   , mIsSecondaryAxis(false)
   , mSelectedDataPoint(-1)
   , mPlotStyle(aPlotStyle)
   , mWidth(1.0f)
   , mStipple(NO_STIPPLE)
   , mType(aType)
{
}

UtQtGL2DPlot::Series::Series(int aSeriesNumber, UtQtGL2DPlot::PlotStyle aStyle)
   : UtQtGL2DPlot::SeriesBase(aSeriesNumber, aStyle, eStandardSeries)
{
   SetName(QString("Series_") + QString::number(mSeriesNumber));
}

QColor UtQtGL2DPlot::Series::GetColorAt(double aValue)
{
   // If color points exist for the given series
   if (!mColorPoints.empty())
   {
      // If < first return first color
      if (aValue <= (*mColorPoints.begin()).first)
      {
         return (*mColorPoints.begin()).second;
      }
      // if > last return last color
      else if (aValue >= (*mColorPoints.rbegin()).first)
      {
         return (*mColorPoints.rbegin()).second;
      }
      // otherwise find the color
      else
      {
         auto curIter  = mColorPoints.begin();
         auto prevIter = curIter;
         for (; curIter != mColorPoints.end(); ++curIter)
         {
            if (aValue == (*curIter).first)
            {
               return (*curIter).second;
            }
            if ((aValue < (*curIter).first) && (aValue > (*prevIter).first))
            {
               double percentCurrent = (aValue - (*prevIter).first) / ((*curIter).first - (*prevIter).first);
               int    r              = (double)((*curIter).second.red() - (*prevIter).second.red()) * percentCurrent +
                       (*prevIter).second.red();
               int g = (double)((*curIter).second.green() - (*prevIter).second.green()) * percentCurrent +
                       (*prevIter).second.green();
               int b = (double)((*curIter).second.blue() - (*prevIter).second.blue()) * percentCurrent +
                       (*prevIter).second.blue();
               return QColor(r, g, b);
            }
            prevIter = curIter;
         }
      }
   }
   return mColor;
}

void UtQtGL2DPlot::Series::WriteCSV_X(QTextStream& aOut) const
{
   auto xDataIter = data.begin();
   while (xDataIter != data.end())
   {
      aOut << xDataIter->x;

      ++xDataIter;
      if (xDataIter != data.end())
      {
         aOut << ",";
      }
   }
   aOut << endl;
}

void UtQtGL2DPlot::Series::WriteCSV_Y(QTextStream& aOut) const
{
   auto yDataIter = data.begin();
   while (yDataIter != data.end())
   {
      aOut << yDataIter->y;

      ++yDataIter;
      if (yDataIter != data.end())
      {
         aOut << ",";
      }
   }
   aOut << endl;
}

void UtQtGL2DPlot::Series::GetBounds(double& aMinX, double& aMaxX, double& aMinY, double& aMaxY) const
{
   aMinX = std::numeric_limits<double>::max();
   aMinY = std::numeric_limits<double>::max();
   aMaxX = std::numeric_limits<double>::lowest();
   aMaxY = std::numeric_limits<double>::lowest();

   for (const auto& iter : data)
   {
      const double x = iter.x;
      const double y = iter.y;

      if (x < aMinX)
      {
         aMinX = x;
      }
      if (x > aMaxX)
      {
         aMaxX = x;
      }

      if (y < aMinY)
      {
         aMinY = y;
      }
      if (y > aMaxY)
      {
         aMaxY = y;
      }
   }
}

void UtQtGL2DPlot::Series::Get(size_t aIndex, double& aX, double& aY) const
{
   aX = data[aIndex].x;
   aY = data[aIndex].y;
}

void UtQtGL2DPlot::Series::GetZ(size_t aIndex, double& aZ) const
{
   aZ = data[aIndex].z;
}

void UtQtGL2DPlot::Series::GetRGBA(size_t aIndex, unsigned int& aRGBA) const
{
   aRGBA = data[aIndex].rgba;
}

UtQtAbstractItemModelSeries::UtQtAbstractItemModelSeries(QAbstractItemModel*     aItemModel,
                                                         int                     aColumnX,
                                                         int                     aColumnY,
                                                         int                     aSeriesNumber,
                                                         UtQtGL2DPlot::PlotStyle aPlotStyle)
   : SeriesBase(aSeriesNumber, aPlotStyle, eModelViewSeries)
   , mModelPtr(aItemModel)
   , mColumnX(aColumnX)
   , mColumnY(aColumnY)
{
   connect(mModelPtr, &QAbstractItemModel::rowsInserted, this, &UtQtAbstractItemModelSeries::rowsInserted);
   connect(mModelPtr, &QAbstractItemModel::rowsRemoved, this, &UtQtAbstractItemModelSeries::rowsRemoved);
   connect(mModelPtr, &QAbstractItemModel::modelReset, this, &UtQtAbstractItemModelSeries::modelReset);
}

bool UtQtAbstractItemModelSeries::IsEmpty() const
{
   return (mModelPtr->rowCount() <= 0);
}

size_t UtQtAbstractItemModelSeries::Size() const
{
   return ut::cast_to_size_t(mModelPtr->rowCount());
}

void UtQtAbstractItemModelSeries::WriteCSV_X(QTextStream& aOut) const
{
   size_t s = Size();
   for (unsigned int i = 0; i < s; ++i)
   {
      double x = 0.0;
      if (mColumnX > 0)
      {
         x = mModelPtr->data(mModelPtr->index(i, mColumnX), Qt::DisplayRole).toDouble();
      }
      else
      {
         x = mModelPtr->headerData(i, Qt::Horizontal, Qt::DisplayRole).toDouble();
      }
      aOut << x;

      if (i + 1 < s)
      {
         aOut << ",";
      }
   }
   aOut << endl;
}

void UtQtAbstractItemModelSeries::WriteCSV_Y(QTextStream& aOut) const
{
   size_t s = Size();
   for (unsigned int i = 0; i < s; ++i)
   {
      double y = 0.0;
      if (mColumnY > 0)
      {
         y = mModelPtr->data(mModelPtr->index(i, mColumnY), Qt::DisplayRole).toDouble();
      }
      else
      {
         y = mModelPtr->headerData(i, Qt::Horizontal, Qt::DisplayRole).toDouble();
      }
      aOut << y;

      if (i + 1 < s)
      {
         aOut << ",";
      }
   }
   aOut << endl;
}

void UtQtAbstractItemModelSeries::GetBounds(double& aMinX, double& aMaxX, double& aMinY, double& aMaxY) const
{
   aMinX = std::numeric_limits<double>::max();
   aMinY = std::numeric_limits<double>::max();
   aMaxX = std::numeric_limits<double>::lowest();
   aMaxY = std::numeric_limits<double>::lowest();
   for (size_t i = 0; i < Size(); ++i)
   {
      double x;
      double y;
      Get(i, x, y);
      if ((x != std::numeric_limits<double>::infinity()) && (x != -std::numeric_limits<double>::infinity()))
      {
         if (x < aMinX)
         {
            aMinX = x;
         }
         if (x > aMaxX)
         {
            aMaxX = x;
         }
      }
      if ((y != std::numeric_limits<double>::infinity()) && (y != -std::numeric_limits<double>::infinity()))
      {
         if (y < aMinY)
         {
            aMinY = y;
         }
         if (y > aMaxY)
         {
            aMaxY = y;
         }
      }
   }
}

void UtQtAbstractItemModelSeries::Get(size_t aIndex, double& aX, double& aY) const
{
   if (mColumnX >= 0)
   {
      aX = mModelPtr->data(mModelPtr->index(static_cast<unsigned int>(aIndex), mColumnX), Qt::DisplayRole).toDouble();
   }
   else
   {
      aX = mModelPtr->headerData(static_cast<unsigned int>(aIndex), Qt::Vertical, Qt::DisplayRole).toDouble();
   }

   if (mColumnY >= 0)
   {
      aY = mModelPtr->data(mModelPtr->index(static_cast<unsigned int>(aIndex), mColumnY), Qt::DisplayRole).toDouble();
   }
   else
   {
      aY = mModelPtr->headerData(static_cast<unsigned int>(aIndex), Qt::Vertical, Qt::DisplayRole).toDouble();
   }
}

QString UtQtAbstractItemModelSeries::Name() const
{
   if (mSeriesName.isEmpty())
   {
      return mModelPtr->headerData(mColumnY, Qt::Horizontal, Qt::DisplayRole).toString();
   }
   else
   {
      return mSeriesName;
   }
}

void UtQtAbstractItemModelSeries::modelReset()
{
   emit Redraw();
}

void UtQtAbstractItemModelSeries::rowsInserted(const QModelIndex& aParent, int aStart, int aEnd)
{
   emit Redraw();
}

void UtQtAbstractItemModelSeries::rowsRemoved(const QModelIndex& aParent, int aStart, int aEnd)
{
   emit Redraw();
}
