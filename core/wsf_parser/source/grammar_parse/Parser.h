// ****************************************************************************
// CUI
//
// The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
//
// The use, dissemination or disclosure of data in this file is subject to
// limitation or restriction. See accompanying README and LICENSE for details.
// ****************************************************************************

// NOTE: DO NOT HAND-EDIT THIS FILE! It is generated by the COCO/R compiler generator.
//       See util_script/source/script_parser/AAA_README.TXT.

#if !defined(WsfGrammar_COCO_PARSER_H__)
#define WsfGrammar_COCO_PARSER_H__

#include <string>

#include "Scanner.h"
#include "WsfParseGrammar.hpp"

namespace WsfGrammar
{


class Errors
{
public:
   int                      count; // number of errors detected
   std::vector<std::string> mErrors;
   Errors();
   virtual ~Errors() {}
   virtual void SynErr(int line, int col, int pos, int n);
   virtual void Error(int line, int col, int pos, const wchar_t* s);
   virtual void Warning(int line, int col, int pos, const wchar_t* s);
   virtual void Warning(const wchar_t* s);
   virtual void Exception(const wchar_t* s);

}; // Errors

class Parser
{
public:
   enum
   {
      _EOF            = 0,
      _string_literal = 1,
      _label          = 2,
      _word           = 3,
      _gt             = 4,
      _lt             = 5,
      _star           = 6,
      _question       = 7,
      _plus           = 8,
      _alternate      = 9,
      _colon          = 10,
      _comma          = 11,
      _assign         = 12,
      _dot            = 13
   };
   int maxT;

private:
   Token* dummyToken;
   int    errDist;
   int    minErrDist;

public:
   void SynErr(int n);
   void Get();
   void Expect(int n);
   bool StartOf(int s);
   void ExpectWeak(int n, int follow);
   bool WeakSeparator(int n, int syFol, int repFol);

public:
   Scanner* scanner;
   Errors*  errors;

   Token* t;  // last recognized token
   Token* la; // lookahead token

   static const int cLARGE_NUMBER = 0x7fffffff;
   // For resolving LL1 ambiguities
   bool HasVarAssign()
   {
      Token* tt = scanner->Peek();
      return tt->kind == _assign;
   }

   std::string Str(Token* t)
   {
      // max size of a wide char per element, plus null terminator
      auto              len = wcslen(t->val) * MB_CUR_MAX + 1;
      std::vector<char> str(len);
      std::wcstombs(str.data(), t->val, len);
      return std::string(str.data());
   }
   void Unescape(std::string& s)
   {
      for (size_t i = 0; i + 1 < s.size(); ++i)
      {
         if (s[i] == '\\')
         {
            s.erase(s.begin() + i);
         }
      }
   }
   std::string Strlit(Token* t)
   {
      std::string s = Str(t);
      Unescape(s);
      return s;
   }

public:
   M::Expr mRootRule;
   float   mPriority;

   void Clear()
   {
      mPriority = 0.0f;
      mRootRule.Clear();
      mRootRule.mRuleType = M::cRT_ROOT;
   }

   typedef std::vector<std::string> StringVector;


   Parser(Scanner* scanner);
   ~Parser();
   void SemErr(const wchar_t* msg);

   void StringLiteral(std::string& s);
   void PlainWord(std::string& s);
   void Parameter(M::Expr& p);
   void Rule(M::Expr& r);
   void SequencePart(M::Expr& s);
   void Sequence(M::Expr& s);
   void Action(M::Expr& r);
   void Alternates(M::Expr& a);
   void Recurrence(M::Expr& lhs);
   void RuleExpr(M::Expr& r);
   void ActionRHS(M::Expr& rhsRule);
   void ActionExpr(M::Expr& r);
   void WsfGrammar();

   void Parse();
   void InitParse();

}; // end Parser

} // namespace WsfGrammar


#endif
