// ****************************************************************************
// CUI
//
// The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
//
// The use, dissemination or disclosure of data in this file is subject to
// limitation or restriction. See accompanying README and LICENSE for details.
// ****************************************************************************

// NOTE: DO NOT HAND-EDIT THIS FILE! It is generated by the COCO/R compiler generator.
//       See util_script/source/script_parser/AAA_README.TXT.

#include "Parser.h"

#include <wchar.h>

#include "Scanner.h"


namespace WsfGrammar
{


void Parser::SynErr(int n)
{
   if (errDist >= minErrDist)
      errors->SynErr(la->line, la->col, la->pos, n);
   if (errDist == 0)
      Get();
   errDist = 0;
}

void Parser::SemErr(const wchar_t* msg)
{
   if (errDist >= minErrDist)
      errors->Error(t->line, t->col, t->pos, msg);
   errDist = 0;
}

void Parser::Get()
{
   for (;;)
   {
      t  = la;
      la = scanner->Scan();
      if (la->kind <= maxT)
      {
         ++errDist;
         break;
      }

      if (dummyToken != t)
      {
         dummyToken->kind = t->kind;
         dummyToken->pos  = t->pos;
         dummyToken->col  = t->col;
         dummyToken->line = t->line;
         dummyToken->next = nullptr;
         coco_string_delete(dummyToken->val);
         dummyToken->val = coco_string_create(t->val);
         t               = dummyToken;
      }
      la = t;
   }
}

void Parser::Expect(int n)
{
   if (la->kind == n)
      Get();
   else
   {
      SynErr(n);
   }
}

void Parser::ExpectWeak(int n, int follow)
{
   if (la->kind == n)
      Get();
   else
   {
      SynErr(n);
      while (!StartOf(follow))
         Get();
   }
}

bool Parser::WeakSeparator(int n, int syFol, int repFol)
{
   if (la->kind == n)
   {
      Get();
      return true;
   }
   else if (StartOf(repFol))
   {
      return false;
   }
   else
   {
      SynErr(n);
      while (!(StartOf(syFol) || StartOf(repFol) || StartOf(0)))
      {
         Get();
      }
      return StartOf(syFol);
   }
}

void Parser::StringLiteral(std::string& s)
{
   Expect(_string_literal);
   s = Strlit(t);
   s = s.substr(1, s.size() - 2);
}

void Parser::PlainWord(std::string& s)
{
   if (la->kind == _word)
   {
      Get();
      s = Strlit(t);
   }
   else if (la->kind == _string_literal)
   {
      StringLiteral(s);
   }
   else
      SynErr(22);
}

void Parser::Parameter(M::Expr& p)
{
   std::string lbl;
   if (la->kind == _label)
   {
      Get();
      lbl = Str(t);
   }
   Rule(p);
   if (!lbl.empty())
      p.mLabel = lbl.substr(1);
}

void Parser::Rule(M::Expr& r)
{
   using namespace M;
   Expr        te;
   M::Expr     tp;
   std::string text;
   if (la->kind == _string_literal || la->kind == _word)
   {
      PlainWord(text);
      r.SetLiteral(text);
   }
   else if (la->kind == _lt)
   {
      Get();
      if (la->kind == _word)
      {
         Get();
      }
      else if (la->kind == _label)
      {
         Get();
      }
      else
         SynErr(23);
      te.mRuleType = M::cRT_EXPRESSION;
      te.mType     = "rule_ref";
      tp.SetLiteral(Strlit(t));
      te.PushMove(tp);
      while (StartOf(1))
      {
         Parameter(tp);
         te.PushMove(tp);
      }
      Expect(_gt);
      r.Swap(te);
      if (la->kind == _star || la->kind == _question || la->kind == _plus)
      {
         Recurrence(r);
      }
   }
   else if (la->kind == 14 /* "(" */)
   {
      RuleExpr(r);
   }
   else if (la->kind == 16 /* "{" */)
   {
      Get();
      Alternates(r);
      Expect(17 /* "}" */);
      if (la->kind == _star || la->kind == _question || la->kind == _plus)
      {
         Recurrence(r);
      }
   }
   else
      SynErr(24);
}

void Parser::SequencePart(M::Expr& s)
{
   Rule(s);
}

void Parser::Sequence(M::Expr& s)
{
   s.Clear();
   s.mRuleType = M::cRT_SEQUENCE;
   M::Expr tr;
   if (la->kind == 18 /* "[" */)
   {
      Action(tr);
      s.PushMove(tr);
   }
   SequencePart(tr);
   s.PushMove(tr);
   if (la->kind == 18 /* "[" */)
   {
      Action(tr);
      s.PushMove(tr);
   }
   while (StartOf(2))
   {
      SequencePart(tr);
      s.PushMove(tr);
      if (la->kind == 18 /* "[" */)
      {
         Action(tr);
         s.PushMove(tr);
      }
   }
}

void Parser::Action(M::Expr& r)
{
   M::Expr subaction;
   Expect(18 /* "[" */);
   r.mRuleType = M::cRT_ACTION;
   ActionExpr(subaction);
   r.PushMove(subaction);
   subaction.Clear();
   while (la->kind == 19 /* ";" */)
   {
      Get();
      ActionExpr(subaction);
      r.PushMove(subaction);
      subaction.Clear();
   }
   Expect(20 /* "]" */);
}

void Parser::Alternates(M::Expr& a)
{
   a.Clear();
   M::Expr s;
   a.mRuleType = M::cRT_ALTERNATE;
   Sequence(s);
   a.PushMove(s);
   while (la->kind == _alternate)
   {
      Get();
      Sequence(s);
      a.PushMove(s);
   }
}

void Parser::Recurrence(M::Expr& lhs)
{
   if (la->kind == _star)
   {
      Get();
   }
   else if (la->kind == _plus)
   {
      Get();
   }
   else if (la->kind == _question)
   {
      Get();
   }
   else
      SynErr(25);
   M::Expr te;
   te.mRuleType = M::cRT_EXPRESSION;
   te.mType     = "recurrence";
   te += M::Expr::Literal(Strlit(t));
   te += lhs;
   lhs = te;
}

void Parser::RuleExpr(M::Expr& r)
{
   using namespace M;
   Expr te;
   te.mRuleType = M::cRT_EXPRESSION;
   M::Expr tp;
   Expect(14 /* "(" */);
   Expect(_word);
   te.mType = Strlit(t);
   while (StartOf(1))
   {
      Parameter(tp);
      te.PushMove(tp);
   }
   Expect(15 /* ")" */);
   r = te;
}

void Parser::ActionRHS(M::Expr& rhsRule)
{
   using namespace M;
   std::string text;
   M::Expr     arg;
   bool        isCall = false;
   PlainWord(text);
   if (la->kind == 14 /* "(" */)
   {
      Get();
      rhsRule.mRuleType = cRT_ACTION_CALL;
      rhsRule.mText     = text;
      isCall            = true;
      if (la->kind == _string_literal || la->kind == _word)
      {
         ActionRHS(arg);
         rhsRule.PushMove(arg);
         arg.Clear();
         while (la->kind == _comma)
         {
            Get();
            ActionRHS(arg);
            rhsRule.PushMove(arg);
            arg.Clear();
         }
      }
      Expect(15 /* ")" */);
   }
   if (!isCall)
   {
      rhsRule.SetLiteral(text);
   }
}

void Parser::ActionExpr(M::Expr& r)
{
   std::string text;
   M::Expr     rhs;
   if (HasVarAssign())
   {
      PlainWord(text);
      r.mText     = "=";
      r.mRuleType = M::cRT_ACTION_CALL;
      rhs.SetLiteral(text);
      r.PushMove(rhs);
      Expect(_assign);
      ActionRHS(rhs);
      r.PushMove(rhs);
   }
   else if (la->kind == _string_literal || la->kind == _word)
   {
      ActionRHS(r);
   }
   else
      SynErr(26);
}

void Parser::WsfGrammar()
{
   M::Expr r;
   mRootRule.mRuleType = M::cRT_ROOT;
   while (la->kind == 14 /* "(" */)
   {
      RuleExpr(r);
      mRootRule.PushMove(r);
   }
}


// If the user declared a method Init and a mehtod Destroy they should
// be called in the contructur and the destructor respctively.
//
// The following templates are used to recognize if the user declared
// the methods Init and Destroy.

template<typename T>
struct ParserInitExistsRecognizer
{
   template<typename U, void (U::*)() = &U::Init>
   struct ExistsIfInitIsDefinedMarker
   {
   };

   struct InitIsMissingType
   {
      char dummy1;
   };

   struct InitExistsType
   {
      char dummy1;
      char dummy2;
   };

   // exists always
   template<typename U>
   static InitIsMissingType is_here(...);

   // exist only if ExistsIfInitIsDefinedMarker is defined
   template<typename U>
   static InitExistsType is_here(ExistsIfInitIsDefinedMarker<U>*);

   enum
   {
      InitExists = (sizeof(is_here<T>(NULL)) == sizeof(InitExistsType))
   };
};

template<typename T>
struct ParserDestroyExistsRecognizer
{
   template<typename U, void (U::*)() = &U::Destroy>
   struct ExistsIfDestroyIsDefinedMarker
   {
   };

   struct DestroyIsMissingType
   {
      char dummy1;
   };

   struct DestroyExistsType
   {
      char dummy1;
      char dummy2;
   };

   // exists always
   template<typename U>
   static DestroyIsMissingType is_here(...);

   // exist only if ExistsIfDestroyIsDefinedMarker is defined
   template<typename U>
   static DestroyExistsType is_here(ExistsIfDestroyIsDefinedMarker<U>*);

   enum
   {
      DestroyExists = (sizeof(is_here<T>(NULL)) == sizeof(DestroyExistsType))
   };
};

// The folloing templates are used to call the Init and Destroy methods if they exist.

// Generic case of the ParserInitCaller, gets used if the Init method is missing
template<typename T, bool = ParserInitExistsRecognizer<T>::InitExists>
struct ParserInitCaller
{
   static void CallInit(T* t)
   {
      // nothing to do
   }
};

// True case of the ParserInitCaller, gets used if the Init method exists
template<typename T>
struct ParserInitCaller<T, true>
{
   static void CallInit(T* t) { t->Init(); }
};

// Generic case of the ParserDestroyCaller, gets used if the Destroy method is missing
template<typename T, bool = ParserDestroyExistsRecognizer<T>::DestroyExists>
struct ParserDestroyCaller
{
   static void CallDestroy(T* t)
   {
      // nothing to do
   }
};

// True case of the ParserDestroyCaller, gets used if the Destroy method exists
template<typename T>
struct ParserDestroyCaller<T, true>
{
   static void CallDestroy(T* t) { t->Destroy(); }
};

void Parser::InitParse()
{
   t  = nullptr;
   la = dummyToken = new Token();
   la->val         = coco_string_create(L"Dummy Token");
   Get();
}
void Parser::Parse()
{
   InitParse();
   WsfGrammar();
   Expect(0);
}

Parser::Parser(Scanner* scanner)
{
   maxT = 21;

   ParserInitCaller<Parser>::CallInit(this);
   dummyToken = nullptr;
   t = la        = nullptr;
   minErrDist    = 2;
   errDist       = minErrDist;
   this->scanner = scanner;
   errors        = new Errors();
}

bool Parser::StartOf(int s)
{
   const bool T = true;
   const bool x = false;

   static bool set[3][23] = {{T, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x, x},
                             {x, T, T, T, x, T, x, x, x, x, x, x, x, x, T, x, T, x, x, x, x, x, x},
                             {x, T, x, T, x, T, x, x, x, x, x, x, x, x, T, x, T, x, x, x, x, x, x}};


   return set[s][la->kind];
}

Parser::~Parser()
{
   ParserDestroyCaller<Parser>::CallDestroy(this);
   delete errors;
   delete dummyToken;
}

Errors::Errors()
{
   count = 0;
}

void Errors::SynErr(int line, int col, int pos, int n)
{
   wchar_t* s;
   switch (n)
   {
   case 0:
      s = coco_string_create(L"EOF expected");
      break;
   case 1:
      s = coco_string_create(L"string_literal expected");
      break;
   case 2:
      s = coco_string_create(L"label expected");
      break;
   case 3:
      s = coco_string_create(L"word expected");
      break;
   case 4:
      s = coco_string_create(L"gt expected");
      break;
   case 5:
      s = coco_string_create(L"lt expected");
      break;
   case 6:
      s = coco_string_create(L"star expected");
      break;
   case 7:
      s = coco_string_create(L"question expected");
      break;
   case 8:
      s = coco_string_create(L"plus expected");
      break;
   case 9:
      s = coco_string_create(L"alternate expected");
      break;
   case 10:
      s = coco_string_create(L"colon expected");
      break;
   case 11:
      s = coco_string_create(L"comma expected");
      break;
   case 12:
      s = coco_string_create(L"assign expected");
      break;
   case 13:
      s = coco_string_create(L"dot expected");
      break;
   case 14:
      s = coco_string_create(L"\"(\" expected");
      break;
   case 15:
      s = coco_string_create(L"\")\" expected");
      break;
   case 16:
      s = coco_string_create(L"\"{\" expected");
      break;
   case 17:
      s = coco_string_create(L"\"}\" expected");
      break;
   case 18:
      s = coco_string_create(L"\"[\" expected");
      break;
   case 19:
      s = coco_string_create(L"\";\" expected");
      break;
   case 20:
      s = coco_string_create(L"\"]\" expected");
      break;
   case 21:
      s = coco_string_create(L"??? expected");
      break;
   case 22:
      s = coco_string_create(L"invalid PlainWord");
      break;
   case 23:
      s = coco_string_create(L"invalid Rule");
      break;
   case 24:
      s = coco_string_create(L"invalid Rule");
      break;
   case 25:
      s = coco_string_create(L"invalid Recurrence");
      break;
   case 26:
      s = coco_string_create(L"invalid ActionExpr");
      break;

   default:
   {
      wchar_t format[20];
      coco_swprintf(format, 20, L"error %d", n);
      s = coco_string_create(format);
   }
   break;
   }
   wchar_t errorLine[1000];
   coco_swprintf(errorLine, 1000, L"-- line %d col %d: %ls\n", line, col, s);
   mErrors.push_back(coco_string_from_wchar(errorLine));
   coco_string_delete(s);
   count++;
}

void Errors::Error(int line, int col, int pos, const wchar_t* s)
{
   wchar_t errorLine[1000];
   coco_swprintf(errorLine, 1000, L"-- line %d col %d: %ls\n", line, col, s);
   mErrors.push_back(coco_string_from_wchar(errorLine));
   count++;
}

void Errors::Warning(int line, int col, int pos, const wchar_t* s)
{
   wchar_t errorLine[1000];
   coco_swprintf(errorLine, 1000, L"-- line %d col %d: %ls\n", line, col, s);
   mErrors.push_back(coco_string_from_wchar(errorLine));
}

void Errors::Warning(const wchar_t* s)
{
   wchar_t errorLine[1000];
   coco_swprintf(errorLine, 1000, L"%ls\n", s);
   mErrors.push_back(coco_string_from_wchar(errorLine));
}

void Errors::Exception(const wchar_t* s)
{
   wprintf(L"%ls", s);
   exit(1);
}

} // namespace WsfGrammar
