// ****************************************************************************
// CUI
//
// The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
//
// The use, dissemination or disclosure of data in this file is subject to
// limitation or restriction. See accompanying README and LICENSE for details.
// ****************************************************************************

// NOTE: DO NOT HAND-EDIT THIS FILE! It is generated by the COCO/R compiler generator.
//       See util_script/source/script_parser/AAA_README.TXT.

#include "Scanner.h"

#include <cstddef>
#include <cstring>
#include <memory>

#include "UtCast.hpp"

namespace WsfGrammar
{


// string handling, wide character


wchar_t* coco_string_create(const wchar_t* value)
{
   return coco_string_create(value, 0);
}

wchar_t* coco_string_create(const wchar_t* value, int startIndex)
{
   int valueLen = 0;
   int len      = 0;

   if (value)
   {
      valueLen = ut::cast_to_int(wcslen(value));
      len      = valueLen - startIndex;
   }

   return coco_string_create(value, startIndex, len);
}

wchar_t* coco_string_create(const wchar_t* value, int startIndex, int length)
{
   int      len = 0;
   wchar_t* data;

   if (value)
   {
      len = length;
   }
   data = new wchar_t[len + 1];
   wcsncpy(data, &(value[startIndex]), len);
   data[len] = 0;

   return data;
}

wchar_t* coco_string_create_upper(const wchar_t* data)
{
   if (!data)
   {
      return nullptr;
   }

   int dataLen = 0;
   if (data)
   {
      dataLen = ut::cast_to_int(wcslen(data));
   }

   wchar_t* newData = new wchar_t[dataLen + 1];

   for (int i = 0; i <= dataLen; i++)
   {
      if ((L'a' <= data[i]) && (data[i] <= L'z'))
      {
         newData[i] = data[i] + (L'A' - L'a');
      }
      else
      {
         newData[i] = data[i];
      }
   }

   newData[dataLen] = L'\0';
   return newData;
}

wchar_t* coco_string_create_lower(const wchar_t* data)
{
   if (!data)
   {
      return nullptr;
   }
   int dataLen = ut::cast_to_int(wcslen(data));
   return coco_string_create_lower(data, 0, dataLen);
}

wchar_t* coco_string_create_lower(const wchar_t* data, int startIndex, int dataLen)
{
   if (!data)
   {
      return nullptr;
   }

   wchar_t* newData = new wchar_t[dataLen + 1];

   for (int i = 0; i <= dataLen; i++)
   {
      wchar_t ch = data[startIndex + i];
      if ((L'A' <= ch) && (ch <= L'Z'))
      {
         newData[i] = ch - (L'A' - L'a');
      }
      else
      {
         newData[i] = ch;
      }
   }
   newData[dataLen] = L'\0';
   return newData;
}

wchar_t* coco_string_create_append(const wchar_t* data1, const wchar_t* data2)
{
   wchar_t* data;
   int      data1Len = 0;
   int      data2Len = 0;

   if (data1)
   {
      data1Len = ut::cast_to_int(wcslen(data1));
   }
   if (data2)
   {
      data2Len = ut::cast_to_int(wcslen(data2));
   }

   data = new wchar_t[data1Len + data2Len + 1];

   if (data1)
   {
      wcscpy(data, data1);
   }
   if (data2)
   {
      wcscpy(data + data1Len, data2);
   }

   data[data1Len + data2Len] = 0;

   return data;
}

wchar_t* coco_string_create_append(const wchar_t* target, const wchar_t appendix)
{
   int      targetLen = coco_string_length(target);
   wchar_t* data      = new wchar_t[targetLen + 2];
   wcsncpy(data, target, targetLen);
   data[targetLen]     = appendix;
   data[targetLen + 1] = 0;
   return data;
}

void coco_string_delete(wchar_t*& data)
{
   delete[] data;
   data = nullptr;
}

int coco_string_length(const wchar_t* data)
{
   if (data)
   {
      return ut::cast_to_int(wcslen(data));
   }
   return 0;
}

bool coco_string_endswith(const wchar_t* data, const wchar_t* end)
{
   int dataLen = ut::cast_to_int(wcslen(data));
   int endLen  = ut::cast_to_int(wcslen(end));
   return (endLen <= dataLen) && (wcscmp(data + dataLen - endLen, end) == 0);
}

int coco_string_indexof(const wchar_t* data, const wchar_t value)
{
   const wchar_t* chr = wcschr(data, value);

   if (chr)
   {
      return ut::safe_cast<int>(chr - data);
   }
   return -1;
}

int coco_string_lastindexof(const wchar_t* data, const wchar_t value)
{
   const wchar_t* chr = wcsrchr(data, value);

   if (chr)
   {
      return ut::safe_cast<int>(chr - data);
   }
   return -1;
}

void coco_string_merge(wchar_t*& target, const wchar_t* appendix)
{
   if (!appendix)
   {
      return;
   }
   wchar_t* data = coco_string_create_append(target, appendix);
   delete[] target;
   target = data;
}

bool coco_string_equal(const wchar_t* data1, const wchar_t* data2)
{
   return wcscmp(data1, data2) == 0;
}

int coco_string_compareto(const wchar_t* data1, const wchar_t* data2)
{
   return wcscmp(data1, data2);
}

unsigned int coco_string_hash(const wchar_t* data)
{
   unsigned int h = 0;
   if (!data)
   {
      return 0;
   }
   while (*data != 0)
   {
      h = (h * 7) ^ *data;
      ++data;
   }
   return h;
}

// string handling, ascii character

wchar_t* coco_string_create(const char* value)
{
   int len = 0;
   if (value)
   {
      len = ut::cast_to_int(strlen(value));
   }
   wchar_t* data = new wchar_t[len + 1];
   for (int i = 0; i < len; ++i)
   {
      data[i] = (wchar_t)value[i];
   }
   data[len] = 0;
   return data;
}

char* coco_string_create_char(const wchar_t* value)
{
   int   len = coco_string_length(value);
   char* res = new char[len + 1];
   for (int i = 0; i < len; ++i)
   {
      res[i] = (char)value[i];
   }
   res[len] = 0;
   return res;
}

void coco_string_delete(char*& data)
{
   delete[] data;
   data = nullptr;
}


Token::Token()
{
   kind = 0;
   pos  = 0;
   col  = 0;
   line = 0;
   val  = nullptr;
   next = nullptr;
}

Token::~Token()
{
   coco_string_delete(val);
}

Buffer::Buffer(Buffer* b)
{
   buf    = std::move(b->buf);
   bufLen = b->bufLen;
   bufPos = b->bufPos;
}

Buffer::Buffer(const unsigned char* buf, int len)
{
   this->buf.resize(len);
   std::copy(buf, buf + len, this->buf.begin());
   bufLen = len;
   bufPos = 0;
}

int Buffer::Read()
{
   if (bufPos < bufLen)
   {
      return buf[bufPos++];
   }
   else
   {
      return EoF;
   }
}

int Buffer::Peek()
{
   int curPos = GetPos();
   int ch     = Read();
   SetPos(curPos);
   return ch;
}

// beg .. begin, zero-based, inclusive, in byte
// end .. end, zero-based, exclusive, in byte
wchar_t* Buffer::GetString(int beg, int end)
{
   int      len    = 0;
   wchar_t* buf    = new wchar_t[end - beg];
   int      oldPos = GetPos();
   SetPos(beg);
   while (GetPos() < end)
      buf[len++] = (wchar_t)Read();
   SetPos(oldPos);
   wchar_t* res = coco_string_create(buf, 0, len);
   coco_string_delete(buf);
   return res;
}

int Buffer::GetPos()
{
   return bufPos;
}

void Buffer::SetPos(int value)
{
   if ((value < 0) || (value > bufLen))
   {
      wprintf(L"--- buffer out of bounds access, position: %d\n", value);
      exit(1);
   }

   if ((value >= 0) && (value < bufLen))
   { // already in buffer
      bufPos = value;
   }
   else
   {
      bufPos = bufLen; // make Pos return bufLen
   }
}

int UTF8Buffer::Read()
{
   int ch;
   do
   {
      ch = Buffer::Read();
      // until we find a utf8 start (0xxxxxxx or 11xxxxxx)
   } while ((ch >= 128) && ((ch & 0xC0) != 0xC0) && (ch != EoF));
   if (ch < 128 || ch == EoF)
   {
      // nothing to do, first 127 chars are the same in ascii and utf8
      // 0xxxxxxx or end of file character
   }
   else if ((ch & 0xF0) == 0xF0)
   {
      // 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx
      int c1 = ch & 0x07;
      ch     = Buffer::Read();
      int c2 = ch & 0x3F;
      ch     = Buffer::Read();
      int c3 = ch & 0x3F;
      ch     = Buffer::Read();
      int c4 = ch & 0x3F;
      ch     = (((((c1 << 6) | c2) << 6) | c3) << 6) | c4;
   }
   else if ((ch & 0xE0) == 0xE0)
   {
      // 1110xxxx 10xxxxxx 10xxxxxx
      int c1 = ch & 0x0F;
      ch     = Buffer::Read();
      int c2 = ch & 0x3F;
      ch     = Buffer::Read();
      int c3 = ch & 0x3F;
      ch     = (((c1 << 6) | c2) << 6) | c3;
   }
   else if ((ch & 0xC0) == 0xC0)
   {
      // 110xxxxx 10xxxxxx
      int c1 = ch & 0x1F;
      ch     = Buffer::Read();
      int c2 = ch & 0x3F;
      ch     = (c1 << 6) | c2;
   }
   return ch;
}

Scanner::Scanner(const unsigned char* buf, int len)
{
   buffer = new Buffer(buf, len);
   Init();
}

Scanner::~Scanner()
{
   char* cur = (char*)firstHeap;

   while (cur != nullptr)
   {
      cur = *(char**)(cur + COCO_HEAP_BLOCK_SIZE);
      free(firstHeap);
      firstHeap = cur;
   }
   delete[] tval;
   delete buffer;
}

void Scanner::Init()
{
   NewTokCb = nullptr;
   EOL      = '\n';
   eofSym   = 0;
   maxT     = 21;
   noSym    = 21;
   int i;
   for (i = 0; i <= 8; ++i)
      start.set(i, 5);
   for (i = 11; i <= 12; ++i)
      start.set(i, 5);
   for (i = 14; i <= 31; ++i)
      start.set(i, 5);
   for (i = 33; i <= 33; ++i)
      start.set(i, 5);
   for (i = 35; i <= 38; ++i)
      start.set(i, 5);
   for (i = 43; i <= 43; ++i)
      start.set(i, 5);
   for (i = 45; i <= 57; ++i)
      start.set(i, 5);
   for (i = 64; i <= 90; ++i)
      start.set(i, 5);
   for (i = 94; i <= 122; ++i)
      start.set(i, 5);
   for (i = 124; i <= 124; ++i)
      start.set(i, 5);
   for (i = 126; i <= 65535; ++i)
      start.set(i, 5);
   start.set(34, 1);
   start.set(58, 4);
   start.set(92, 7);
   start.set(62, 8);
   start.set(60, 9);
   start.set(42, 10);
   start.set(63, 11);
   start.set(44, 12);
   start.set(61, 13);
   start.set(40, 14);
   start.set(41, 15);
   start.set(123, 16);
   start.set(125, 17);
   start.set(91, 18);
   start.set(59, 19);
   start.set(93, 20);
   start.set(Buffer::EoF, -1);
   keywords.set(L"+", 8);
   keywords.set(L"|", 9);
   keywords.set(L":", 10);
   keywords.set(L".", 13);


   tvalLength = 128;
   tval       = new wchar_t[tvalLength]; // text of current token

   // COCO_HEAP_BLOCK_SIZE byte heap + pointer to next heap block
   heap      = malloc(COCO_HEAP_BLOCK_SIZE + sizeof(void*));
   firstHeap = heap;
   heapEnd   = (void**)(((char*)heap) + COCO_HEAP_BLOCK_SIZE);
   *heapEnd  = nullptr;
   heapTop   = heap;
   if (sizeof(Token) > COCO_HEAP_BLOCK_SIZE)
   {
      wprintf(L"--- Too small COCO_HEAP_BLOCK_SIZE\n");
      exit(1);
   }

   pos     = -1;
   line    = 1;
   col     = 0;
   charPos = -1;
   oldEols = 0;
   NextCh();
   if (ch == 0xEF)
   { // check optional byte order mark for UTF-8
      NextCh();
      int ch1 = ch;
      NextCh();
      int ch2 = ch;
      if (ch1 != 0xBB || ch2 != 0xBF)
      {
         wprintf(L"Illegal byte order mark at start of file");
         exit(1);
      }
      Buffer* oldBuf = buffer;
      buffer         = new UTF8Buffer(buffer);
      col            = 0;
      charPos        = -1;
      delete oldBuf;
      oldBuf = nullptr;
      NextCh();
   }


   pt = tokens = CreateToken(); // first token is a dummy
}

void Scanner::NextCh()
{
   if (oldEols > 0)
   {
      ch = EOL;
      oldEols--;
   }
   else
   {
      pos = buffer->GetPos();
      // buffer reads unicode chars, if UTF8 has been detected
      ch = buffer->Read();
      col++;
      charPos++;
      // replace isolated '\r' by '\n' in order to make
      // eol handling uniform across Windows, Unix and Mac
      if (ch == L'\r' && buffer->Peek() != L'\n')
         ch = EOL;
      if (ch == EOL)
      {
         line++;
         col = 0;
      }
   }
}

void Scanner::AddCh()
{
   if (tlen >= tvalLength)
   {
      tvalLength *= 2;
      wchar_t* newBuf = new wchar_t[tvalLength];
      memcpy(newBuf, tval, tlen * sizeof(wchar_t));
      delete[] tval;
      tval = newBuf;
   }
   if (ch != Buffer::EoF)
   {
      tval[tlen++] = ch;
      NextCh();
   }
}


bool Scanner::Comment0()
{
   int level = 1, line0 = line;
   NextCh();
   for (;;)
   {
      if (ch == 10)
      {
         level--;
         if (level == 0)
         {
            oldEols = line - line0;
            NextCh();
            return true;
         }
         NextCh();
      }
      else if (ch == buffer->EoF)
         return false;
      else
         NextCh();
   }
}


void Scanner::CreateHeapBlock()
{
   void* newHeap;
   char* cur = (char*)firstHeap;

   while (((char*)tokens < cur) || ((char*)tokens > (cur + COCO_HEAP_BLOCK_SIZE)))
   {
      cur = *((char**)(cur + COCO_HEAP_BLOCK_SIZE));
      free(firstHeap);
      firstHeap = cur;
   }

   // COCO_HEAP_BLOCK_SIZE byte heap + pointer to next heap block
   newHeap  = malloc(COCO_HEAP_BLOCK_SIZE + sizeof(void*));
   *heapEnd = newHeap;
   heapEnd  = (void**)(((char*)newHeap) + COCO_HEAP_BLOCK_SIZE);
   *heapEnd = nullptr;
   heap     = newHeap;
   heapTop  = heap;
}

Token* Scanner::CreateToken()
{
   Token* t;
   if (((char*)heapTop + (int)sizeof(Token)) >= (char*)heapEnd)
   {
      CreateHeapBlock();
   }
   t       = (Token*)heapTop;
   heapTop = (void*)((char*)heapTop + sizeof(Token));
   t->val  = nullptr;
   t->next = nullptr;
   return t;
}

void Scanner::AppendVal(Token* t)
{
   int reqMem = (tlen + 1) * sizeof(wchar_t);
   if (((char*)heapTop + reqMem) >= (char*)heapEnd)
   {
      if (reqMem > COCO_HEAP_BLOCK_SIZE)
      {
         wprintf(L"--- Too long token value\n");
         exit(1);
      }
      CreateHeapBlock();
   }
   t->val  = (wchar_t*)heapTop;
   heapTop = (void*)((char*)heapTop + reqMem);

   wcsncpy(t->val, tval, tlen);
   t->val[tlen] = L'\0';
   if (NewTokCb)
      (*NewTokCb)(t);
}

Token* Scanner::NextToken()
{
   while (ch == ' ' || (ch >= 9 && ch <= 10) || ch == 13)
      NextCh();
   if ((ch == L'#' && Comment0()))
      return NextToken();
   int recKind = noSym;
   int recEnd  = pos;
   t           = CreateToken();
   t->pos      = pos;
   t->col      = col;
   t->line     = line;
   t->charPos  = charPos;
   int state   = start.state(ch);
   tlen        = 0;
   AddCh();

   switch (state)
   {
   case -1:
   {
      t->kind = eofSym;
      break;
   } // NextCh already done
   case 0:
   {
   case_0:
      if (recKind != noSym)
      {
         tlen = recEnd - t->pos;
         SetScannerBehindT();
      }
      t->kind = recKind;
      break;
   } // NextCh already done
   case 1:
   case_1:
      if (ch <= L'!' || (ch >= L'#' && ch <= L'[') || (ch >= L']' && ch <= 65535))
      {
         AddCh();
         goto case_1;
      }
      else if (ch == L'"')
      {
         AddCh();
         goto case_3;
      }
      else if (ch == 92)
      {
         AddCh();
         goto case_2;
      }
      else
      {
         goto case_0;
      }
   case 2:
   case_2:
      if (ch == L'"')
      {
         AddCh();
         goto case_1;
      }
      else
      {
         goto case_0;
      }
   case 3:
   case_3:
   {
      t->kind = 1;
      break;
   }
   case 4:
   case_4:
      recEnd  = pos;
      recKind = 2;
      if (ch <= 8 || (ch >= 11 && ch <= 12) || (ch >= 14 && ch <= 31) || ch == L'!' || (ch >= L'#' && ch <= L'&') ||
          ch == L'+' || (ch >= L'-' && ch <= L'9') || (ch >= L'@' && ch <= L'Z') || (ch >= L'^' && ch <= L'z') ||
          ch == L'|' || (ch >= L'~' && ch <= 65535))
      {
         AddCh();
         goto case_4;
      }
      else
      {
         t->kind          = 2;
         wchar_t* literal = coco_string_create(tval, 0, tlen);
         t->kind          = keywords.get(literal, t->kind);
         coco_string_delete(literal);
         break;
      }
   case 5:
   case_5:
      recEnd  = pos;
      recKind = 3;
      if (ch <= 8 || (ch >= 11 && ch <= 12) || (ch >= 14 && ch <= 31) || ch == L'!' || (ch >= L'#' && ch <= L'&') ||
          ch == L'+' || (ch >= L'-' && ch <= L'9') || (ch >= L'@' && ch <= L'Z') || (ch >= L'^' && ch <= L'z') ||
          ch == L'|' || (ch >= L'~' && ch <= 65535))
      {
         AddCh();
         goto case_5;
      }
      else if (ch == 92)
      {
         AddCh();
         goto case_6;
      }
      else
      {
         t->kind          = 3;
         wchar_t* literal = coco_string_create(tval, 0, tlen);
         t->kind          = keywords.get(literal, t->kind);
         coco_string_delete(literal);
         break;
      }
   case 6:
   case_6:
      if (ch <= 8 || (ch >= 11 && ch <= 31) || (ch >= L'!' && ch <= 65535))
      {
         AddCh();
         goto case_5;
      }
      else
      {
         goto case_0;
      }
   case 7:
      if (ch <= 8 || (ch >= 11 && ch <= 31) || (ch >= L'!' && ch <= 65535))
      {
         AddCh();
         goto case_5;
      }
      else
      {
         goto case_0;
      }
   case 8:
   {
      t->kind = 4;
      break;
   }
   case 9:
   {
      t->kind = 5;
      break;
   }
   case 10:
   {
      t->kind = 6;
      break;
   }
   case 11:
   {
      t->kind = 7;
      break;
   }
   case 12:
   {
      t->kind = 11;
      break;
   }
   case 13:
   {
      t->kind = 12;
      break;
   }
   case 14:
   {
      t->kind = 14;
      break;
   }
   case 15:
   {
      t->kind = 15;
      break;
   }
   case 16:
   {
      t->kind = 16;
      break;
   }
   case 17:
   {
      t->kind = 17;
      break;
   }
   case 18:
   {
      t->kind = 18;
      break;
   }
   case 19:
   {
      t->kind = 19;
      break;
   }
   case 20:
   {
      t->kind = 20;
      break;
   }
   }
   AppendVal(t);
   return t;
}

void Scanner::SetScannerBehindT()
{
   buffer->SetPos(t->pos);
   NextCh();
   line    = t->line;
   col     = t->col;
   charPos = t->charPos;
   for (int i = 0; i < tlen; i++)
      NextCh();
}

// get the next token (possibly a token already seen during peeking)
Token* Scanner::Scan()
{
   if (tokens->next == nullptr)
   {
      return pt = tokens = NextToken();
   }
   else
   {
      pt = tokens = tokens->next;
      return tokens;
   }
}

// peek for the next token, ignore pragmas
Token* Scanner::Peek()
{
   do
   {
      if (pt->next == nullptr)
      {
         pt->next = NextToken();
      }
      pt = pt->next;
   } while (pt->kind > maxT); // skip pragmas

   return pt;
}

// make sure that peeking starts at the current scan position
void Scanner::ResetPeek()
{
   pt = tokens;
}

std::string coco_string_from_wchar(const wchar_t* value)
{
   // max size of a wide char per element, plus null terminator
   auto              len = wcslen(value) * MB_CUR_MAX + 1;
   std::vector<char> str(len);
   std::wcstombs(str.data(), value, len);
   return std::string(str.data());
}

} // namespace WsfGrammar
