// ****************************************************************************
// CUI
//
// The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
//
// Copyright 2017 Infoscitex, a DCS Company. All rights reserved.
//
// The use, dissemination or disclosure of data in this file is subject to
// limitation or restriction. See accompanying README and LICENSE for details.
// ****************************************************************************

#include "WsfCommDatalinkLayer.hpp"

#include "UtCast.hpp"
#include "UtInput.hpp"
#include "UtLog.hpp"
#include "UtStringUtil.hpp"
#include "WsfComm.hpp"
#include "WsfCommLayerEvent.hpp"
#include "WsfCommNetworkManager.hpp"
#include "WsfCommObserver.hpp"
#include "WsfCommProtocolInterface.hpp"
#include "WsfCommTransportLayer.hpp"
#include "WsfSimulation.hpp"

namespace wsf
{
namespace comm
{

// ============================================================================
LayerImp* DatalinkLayer::Clone() const
{
   return new DatalinkLayer(*this);
}

// ============================================================================
bool DatalinkLayer::ProcessInput(UtInput& aInput)
{
   bool        myCommand = true;
   std::string command(aInput.GetCommand());
   if (command == "queue_type")
   {
      std::string queueTypeStr;
      aInput.ReadValue(queueTypeStr);
      UtStringUtil::ToLower(queueTypeStr);
      Queue::QueueType queueType;
      if ("fifo" == queueTypeStr)
      {
         queueType = Queue::QueueType::cFIFO;
      }
      else if ("lifo" == queueTypeStr)
      {
         queueType = Queue::QueueType::cLIFO;
      }
      else if ("priority" == queueTypeStr)
      {
         queueType = Queue::QueueType::cPRIORITY;
      }
      else
      {
         throw UtInput::BadValue(aInput, "Invalid queue type " + queueTypeStr);
      }

      mQueue.SetQueueType(queueType);
   }
   else if (command == "queue_limit")
   {
      int queueLimit;
      aInput.ReadValue(queueLimit);
      auto safeLimit = ut::cast_to_size_t(queueLimit);
      mQueue.SetLimit(safeLimit);
   }
   else if (command == "purge_interval")
   {
      aInput.ReadValueOfType(mPurgeInterval, UtInput::cTIME);
      aInput.ValueGreaterOrEqual(mPurgeInterval, 0.0);
   }
   else if (command == "retransmit_attempts")
   {
      int maxAttempts;
      aInput.ReadValue(maxAttempts);
      aInput.ValueGreaterOrEqual(static_cast<double>(maxAttempts), 0.0);
      mMaximumTransmitAttempts = ut::cast_to_size_t(maxAttempts);
   }
   else if (command == "retransmit_delay")
   {
      aInput.ReadValueOfType(mReTransmitDelay, UtInput::cTIME);
      aInput.ValueGreaterOrEqual(mReTransmitDelay, 0.0);
   }
   else
   {
      myCommand = false;
   }
   return myCommand;
}

// ============================================================================
bool DatalinkLayer::Receive(double aSimTime, Comm* aXmtrPtr, Message& aMessage, bool& aNotifyNextLayer)
{
   bool notify  = true;
   bool success = true;
   bool halt    = false;

   auto protocols = Parent()->GetSortedProtocols();
   for (auto protocol : protocols)
   {
      auto result = protocol->DatalinkReceive(aSimTime, GetIndex(), aMessage);
      halt        = result.first;
      notify &= result.second;
      if (halt)
      {
         break;
      }
   }

   aNotifyNextLayer = notify;
   return success;
}

// ============================================================================
bool DatalinkLayer::Send(double aSimTime, size_t aLayerIndex, Message& aMessage, bool& aNotifyNextLayer)
{
   //! Note: We don't check to notify the next layer here, as we always
   //! wait at this layer for potential delays.
   bool notify  = true;
   bool success = true;
   bool halt    = false;

   auto protocols = Parent()->GetSortedProtocols();
   for (auto protocol : protocols)
   {
      auto result = protocol->DatalinkSend(aSimTime, GetIndex(), aMessage);
      halt        = result.first;
      notify &= result.second;
      if (halt)
      {
         break;
      }
   }

   if (notify)
   {
      // Queue the message
      success &= AddToQueue(aSimTime, aMessage);
   }

   // Don't immediately notify the next layer as the MAC sublayer needs
   // to be checked before transmission can occur
   aNotifyNextLayer = false;

   // If the message was successfully queued
   return success;
}

// ============================================================================
bool DatalinkLayer::ProcessLayerMessage(double aSimTime, layer::Message aLayerMessage, Message* aCommMessagePtr)
{
   bool success = true;
   switch (aLayerMessage.GetValue())
   {
   case layer::cDATALINK_READY.GetValue():
   {
      // Only generated by this layer on the send side.
      // Indicates a state where a new message (if it exists) should be processed.
      success = ReadyToTransmit(aSimTime);
      break;
   }
   case layer::cDATALINK_QUEUE_PURGE.GetValue():
   {
      // Only generated by this layer to handle queue purge intervals.
      success = PurgeQueue(aSimTime);
      break;
   }
   case layer::cDOWN_ACK_RECEIVE.GetValue():
   {
      break;
   }
   case layer::cDOWN_ACK_SEND.GetValue():
   {
      break;
   }
   case layer::cDOWN_NACK_RECEIVE.GetValue():
   {
      break;
   }
   case layer::cDOWN_NACK_SEND.GetValue():
   {
      break;
   }
   case layer::cUP_ACK_RECEIVE.GetValue():
   {
      break;
   }
   case layer::cUP_ACK_SEND.GetValue():
   {
      // Typically received from the physical layer indicating
      // that a message transmission was successful.
      success = TransmitComplete(aSimTime, aCommMessagePtr);
      break;
   }
   case layer::cUP_NACK_RECEIVE.GetValue():
   {
      break;
   }
   case layer::cUP_NACK_SEND.GetValue():
   {
      success = TransmitFailed(aSimTime, aCommMessagePtr);
      break;
   }
   default:
   {
      success = false;
      break;
   }
   }

   return success;
}

// ============================================================================
DatalinkLayer::DatalinkLayer(const DatalinkLayer& aSrc)
   : mQueue(aSrc.mQueue)
   , mPurgeInterval(aSrc.mPurgeInterval)
   , mMaximumTransmitAttempts(aSrc.mMaximumTransmitAttempts)
   , mReTransmitDelay(aSrc.mReTransmitDelay)
   , mCurTransmissions(aSrc.mCurTransmissions)
{
}

// ============================================================================
bool DatalinkLayer::AddToQueue(double aSimTime, Message& aMessage,
                               size_t aPreviousAttempts) // = 0
{
   Queue::Entry entry;
   entry.SetQueueTime(aSimTime);
   entry.SetMessage(&aMessage);
   entry.SetCounter(aPreviousAttempts);
   bool hadEntries = !mQueue.Empty();

   if (mQueue.Push(entry))
   {
      if (DebugEnabled())
      {
         auto out = ut::log::debug() << "Queued message for transmission.";
         out.AddNote() << "T = " << aSimTime;
         out.AddNote() << "Comm: " << Parent()->GetFullName();
         out.AddNote() << "Message: " << *aMessage.SourceMessage();
      }

      WsfObserver::MessageQueued(Parent()->GetSimulation())(aSimTime, Parent(), *aMessage.SourceMessage(), mQueue.Size());

      // The datalink layer can queue entries to its specified limit. However, it will only send as many
      // concurrent messages to lower levels as specified by the comm model's hardware channel limit.
      if (mCurTransmissions < Parent()->GetNumChannels())
      {
         if (DebugEnabled())
         {
            auto out = ut::log::debug() << "Scheduled transmission event.";
            out.AddNote() << "T = " << aSimTime;
            out.AddNote() << "Comm: " << Parent()->GetFullName();
            out.AddNote() << "Message: " << *aMessage.SourceMessage();
         }

         // This is scheduled for as many messages than can be handled by the parent's channel limit.
         LayerEvent::ScheduleCommLayerEvent(aSimTime, GetIndex(), Parent(), layer::cDATALINK_READY);
      }

      if (!hadEntries && (mPurgeInterval > 0.0))
      {
         auto purgeTime = aSimTime + mPurgeInterval;
         LayerEvent::ScheduleCommLayerEvent(purgeTime, GetIndex(), Parent(), layer::cDATALINK_QUEUE_PURGE);
      }

      return true;
   }
   else
   {
      WsfObserver::MessageDiscarded(
         Parent()->GetSimulation())(aSimTime, Parent(), *aMessage.SourceMessage(), "transmission_queue_limit_exceeded");
      return false;
   }
}

// ============================================================================
bool DatalinkLayer::ReadyToTransmit(double aSimTime)
{
   if (!mQueue.EmptyActiveEntries())
   {
      if (mCurTransmissions < Parent()->GetNumChannels())
      {
         auto entry = mQueue.Top();
         mQueue.Pop();

         LayerEvent::ScheduleCommLayerEvent(aSimTime, (GetIndex() - 1), Parent(), layer::cDOWN_ACK_SEND, entry.GetMessage());
         mCurTransmissions++;
         return true;
      }
   }
   return false;
}

// ============================================================================
bool DatalinkLayer::TransmitComplete(double aSimTime, Message* aMessagePtr)
{
   if (aMessagePtr)
   {
      if (DebugEnabled() && aMessagePtr->SourceMessage())
      {
         auto out = ut::log::debug() << "Message transmission completed.";
         out.AddNote() << "T = " << aSimTime;
         out.AddNote() << "Comm: " << Parent()->GetFullName();
         out.AddNote() << "Message: " << *aMessagePtr->SourceMessage();
      }

      LayerEvent::ScheduleCommLayerEvent(aSimTime, GetIndex(), Parent(), layer::cDATALINK_READY);

      // Transmission success. Remove the entry from the queue in totality.
      mQueue.EntryDropped(Message::Identifier(*aMessagePtr));
      mCurTransmissions--;

      return true;
   }

   return false;
}

// ============================================================================
bool DatalinkLayer::TransmitFailed(double aSimTime, Message* aMessagePtr)
{
   if (aMessagePtr && aMessagePtr->SourceMessage())
   {
      if (DebugEnabled())
      {
         auto out = ut::log::debug() << "Message transmission failed.";
         out.AddNote() << "T = " << aSimTime;
         out.AddNote() << "Comm: " << Parent()->GetFullName();
         out.AddNote() << "Message: " << *aMessagePtr->SourceMessage();
      }

      auto entryPtr = mQueue.Peek(Message::Identifier(*aMessagePtr));
      if (!entryPtr)
      {
         return false;
      }

      if (entryPtr->GetCounter() < mMaximumTransmitAttempts)
      {
         entryPtr->IncrementCounter();
         entryPtr->SetQueueTime(aSimTime + mReTransmitDelay);
         LayerEvent::ScheduleCommLayerEvent((aSimTime + mReTransmitDelay),
                                            (GetIndex() - 1),
                                            Parent(),
                                            layer::cDOWN_ACK_SEND,
                                            aMessagePtr);

         // Since we are retrying transmission, change status in the queue.
         mQueue.EntryReprocessed(aSimTime, Message::Identifier(*aMessagePtr));
      }
      else
      {
         LayerEvent::ScheduleCommLayerEvent(aSimTime, GetIndex(), Parent(), layer::cDATALINK_READY);

         // With no transmission attempts left, this is a failure. Inform the observer.
         WsfObserver::MessageDiscarded(Parent()->GetSimulation())(aSimTime,
                                                                  Parent(),
                                                                  *aMessagePtr->SourceMessage(),
                                                                  "Exceeded Retransmission Attempts Upon Failure");

         // No retransmission attempts, so remove the entry completely from the queue.
         mQueue.EntryDropped(Message::Identifier(*aMessagePtr));
         mCurTransmissions--;
      }
   }

   return true;
}

// ==========================================================================
bool DatalinkLayer::PurgeQueue(double aSimTime)
{
   auto removedEntries = mQueue.Remove(aSimTime - mPurgeInterval);

   for (const auto& entry : removedEntries)
   {
      if (DebugEnabled())
      {
         auto out = ut::log::debug() << "Time in transmission queue exceeded. Message discarded.";
         out.AddNote() << "T = " << aSimTime;
         out.AddNote() << "Address: " << Parent()->GetAddress();
         out.AddNote() << "Comm: " << Parent()->GetFullName();
         out.AddNote() << "Message: " << *entry.GetMessage()->SourceMessage();
      }

      WsfObserver::MessageDiscarded(Parent()->GetSimulation())(aSimTime,
                                                               Parent(),
                                                               *entry.GetMessage()->SourceMessage(),
                                                               "time_in_transmission_queue_exceeded");
   }

   if (!mQueue.Empty())
   {
      LayerEvent::ScheduleCommLayerEvent(aSimTime + mPurgeInterval, GetIndex(), Parent(), layer::cDATALINK_QUEUE_PURGE);
   }

   return true;
}

} // namespace comm
} // namespace wsf
