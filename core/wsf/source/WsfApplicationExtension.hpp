// ****************************************************************************
// CUI
//
// The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
//
// Copyright 2003-2015 The Boeing Company. All rights reserved.
//
// The use, dissemination or disclosure of data in this file is subject to
// limitation or restriction. See accompanying README and LICENSE for details.
// ****************************************************************************

#ifndef WSFAPPLICATIONEXTENSION_HPP
#define WSFAPPLICATIONEXTENSION_HPP

#include "wsf_export.h"

#include <iosfwd>
#include <string>

#include "UtMemory.hpp"
class WsfApplication;
#include "WsfExtension.hpp"
class WsfScenario;
class WsfScenarioExtension;
class WsfSimulation;
#include "WsfStandardApplication.hpp"

//! An application extension represents an optional capability that can be added to an application.
//!
//! An application extension provides an interface to add functionality to a scenario or simulation.
//! A program creates a WsfApplication object and registers the desired application extensions to
//! provide the capabilities it requires.
//!
//! The program registers application extensions using:
//! \code
//!    #include "MyApplicationExtension.hpp"
//!    app.RegisterExtension("my_extension", MyApplicationExtension);
//! \endcode
//!
//! This is acceptable if the program knows if the list of extensions is always the same. If, however,
//! the list varies then it becomes unwieldy to maintain not only the program but the associated CMake files.
//! To alleviate this problem a convention has been developed to allow the definition of 'optional'
//! extensions that can be automatically included or excluded from a build simply by their presence
//! or absence from the build directory. To make use of this capability:
//! <ul>
//! <li>
//! Prepare the extension directory according to conventions (described elsewhere). This means creating
//! a few files that allow CMake to include the extension in the build automatically.
//! <li>
//! Add the following code at the bottom of the main implementation file for the extension.
//! For example, at the bottom of the MyExtension.cpp the following would be inserted:
//! \code
//!     void Register_my_extension(WsfApplication& aApplication)
//!     {
//!        aApplication.RegisterExtension("my_extension", new MyExtension);
//!     }
//! \endcode
//! <li>
//! Add the following to the main program:
//! \code
//!    #include "wsf_extensions.hpp"             // This file automatically generated by 'CMake'.
//!    ...
//!    int main(int argc, char* argv[])
//!    {
//!       WsfApplication app;
//!       // Registers standard extensions available in all WSF applications (dis_interface, event_output, etc.)
//!       RegisterBuiltInExtensions(app);
//!       // Registers optional extensions that are present in the build directory
//!       RegisterOptionalExtensions(app);
//!       ...
//!    }
//! \endcode
//! </ul>
//! Following this convention allows the extension to be included or excluded from the application
//! based simply on its presence or absence from the build tree. Even if one does not want to use
//! the capability, it still simplifies the main program by eliminating the need for the include file:
//! \code
//!    int main(int argc, char* argv[])
//!    {
//!       WsfApplication app;
//!       WSF_REGISTER_EXTENSION(app, "my_extension");
//!       ...
//!    }
//! \endcode
class WSF_EXPORT WsfApplicationExtension : public WsfExtension
{
public:
   friend class WsfApplication;
   WsfApplicationExtension();
   ~WsfApplicationExtension() override;

   //! Returns the application to which this extension is registered.
   //! @note This is not valid until AddedToApplication() has been called.
   WsfApplication& GetApplication() const { return *mApplicationPtr; }

   //! @name Notifications from WsfApplication.
   //@{
   virtual void AddedToApplication(WsfApplication& aApplication);
   virtual void ScenarioCreated(WsfScenario& aScenario);
   virtual void SimulationCreated(WsfSimulation& aSimulation);
   //@}

   //! @name Notifications from WsfApplication to support 'standard application' methods.
   //@{
   virtual int  ProcessCommandLine(WsfStandardApplication::Options& aOptions, int aArgc, char* aArgv[]);
   virtual void PrintCommandLineArguments() const;
   virtual void PrintGrammar(std::ostream& aOut);
   virtual void ProcessCommandLineCommands();
   //@}
private:
   void AddedToApplicationP(const std::string& aName, WsfApplication& aApplication);

   //! Copy constructor declared but not defined to prevent use.
   WsfApplicationExtension(const WsfApplicationExtension& aSrc);
   //! Assignment operators declared but not defined to prevent use.
   WsfApplicationExtension operator=(const WsfApplicationExtension& aRhs) = delete;

   WsfApplication* mApplicationPtr;
};

// Eliminate include of WsfScenario.hpp
namespace WsfPrivate
{
WSF_EXPORT void RegisterScenarioExtension(WsfScenario&                          aScenario,
                                          const std::string&                    aName,
                                          std::unique_ptr<WsfScenarioExtension> aExtensionPtr);
}

//! An application extension which simply creates a scenario extension for each scenario
template<typename SCENARIO_EXTENSION>
class WsfDefaultApplicationExtension : public WsfApplicationExtension
{
public:
   void ScenarioCreated(WsfScenario& aScenario) override
   {
      ::WsfPrivate::RegisterScenarioExtension(aScenario, GetExtensionName(), ut::make_unique<SCENARIO_EXTENSION>());
   }
};

#endif
