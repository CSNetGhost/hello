// ****************************************************************************
// CUI
//
// The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
//
// Copyright 2003-2015 The Boeing Company. All rights reserved.
//
// The use, dissemination or disclosure of data in this file is subject to
// limitation or restriction. See accompanying README and LICENSE for details.
// ****************************************************************************

#ifndef WSFCOMPONENT_HPP
#define WSFCOMPONENT_HPP

#include <cassert>
#include <vector>

#include "UtException.hpp"
class UtInput;
#include "wsf_export.h"

#include "WsfComponentRoles.hpp"
class WsfPlatform;
#include "WsfStringId.hpp"

// *************************************************************************************************
// PROGRAMMING NOTE:
//
// Most of the methods within WsfComponent and WsfComponentList include the word 'Component' in the
// name to avoid name conflicts if this class is derived from by another class (e.g.: WsfPlatform).
// Also, some classes derive from both WsfComponent and WsfComponentList (i.e. they are a component,
// but they also support sub-components). Thus, there may be no name conflicts between them.
// *************************************************************************************************

//! A generic object with discoverable interfaces.
//! WsfComponent is the non-templated version of a component. This contains the items that are not
//! dependent on the type of object to which the component is attached.
class WSF_EXPORT WsfComponent
{
public:
   virtual ~WsfComponent() = default;

   //! @name Required interface.
   //! These methods must be implemented by the derived class.
   //@{

   //! Clones a component.
   //! May return null if component does not support clone.
   virtual WsfComponent* CloneComponent() const = 0;

   //! Returns the component's name.
   //! Each component in a component list has a unique name.  Names are usually defined by the user,
   //! but they may also be generated by code and prefixed with a '#' to guarantee no collisions with
   //! user-defined names.
   virtual WsfStringId GetComponentName() const = 0;

   //! Returns a zero-terminated array of component roles.
   //! Note that the array should be in decreasing order of specificity and should generally
   //! the inheritance hierarchy. The first entry should be the components 'primary' role.
   //! For example a sensor would do the following:
   //! \code
   //!    static const int roles[] = { cWSF_COMPONENT_SENSOR, cWSF_COMPONENT_ARTICULATED_PART,
   //!                                 cWSF_COMPONENT_PLATFORM_PART, 0 };
   //!    return roles;
   //! \endcode
   virtual const int* GetComponentRoles() const = 0;

   //! Requests a component's role interface.
   //! A component can support one or more roles.
   //! @param aRole The role whose interface is to be returned.
   //! @returns A pointer to the object if it supports the indicated role, or 'null' if it does not.
   //! Usage:
   //!    WsfProcessor* procPtrOrNull = (WsfProcessor*)componentPtr->QueryComponentInterface(cWSF_COMPONENT_PROCESSOR);
   virtual void* QueryInterface(int aRole) = 0;
   //@}

   //! Forces a specific initialization order.
   //! Components are initialized in increasing initialization order value.
   virtual int GetComponentInitializationOrder() const { return 0; }

   //! @name Additional query methods.
   //!@{
   //! A more type-safe version of QueryInterface.
   //! Usage:
   //! @code
   //!   WsfProcessor*  procPtr;
   //!   if (componentPtr->QueryInterfaceT(procPtr)) {
   //!      ... procPtr is valid
   //!   }
   //! @endcode
   template<typename T>
   bool QueryInterfaceT(T*& aRolePtr)
   {
      aRolePtr = static_cast<T*>(QueryInterface(cCOMPONENT_ROLE<T>()));
      return aRolePtr != nullptr;
   }

   //! Returns true if the component has the specified role.
   bool ComponentHasRole(int aRole) { return QueryInterface(aRole) != nullptr; }
   //@}

   //! @name Common methods that are widely used.
   //! These methods a needed by components in many contexts. They are completely optional and are
   //! are provided here as a convenience so derived classes do not have to define.
   //@{
   virtual bool PreInitialize(double aSimTime);
   virtual bool Initialize(double aSimTime);
   virtual bool Initialize2(double aSimTime);
   virtual void PreInput();
   virtual bool ProcessInput(UtInput& aInput);
   //@}
};

//! A templated version of a component that supports type-specific attachment.
//! This allows the WsfComponentList template to automatically maintain type-safe component attachments
//! in AddComponent and copy construction.
template<typename PARENT_TYPE>
class WsfComponentT : public WsfComponent
{
public:
   //! This is needed to support the WsfComponentList template.
   typedef PARENT_TYPE ParentType;

   WsfComponentT()
      : mParentPtr(nullptr)
   {
   }

   WsfComponentT(const WsfComponentT& /* aSrc */) noexcept
      : mParentPtr(nullptr)
   {
   }

   WsfComponentT& operator=(const WsfComponentT& /* aSrc */) noexcept
   {
      mParentPtr = nullptr;
      return *this;
   }

   ~WsfComponentT() override = default;

   //! @name Parent connection methods.
   //! Instances of this class will have their parent connects maintained through copy.
   //@{
   //! The parent to which the component is attached has been updated.
   //! This virtual method is called whenever the components parent attachment has been changed.
   //! This is provided so derived class receives notification of the change.
   //! @param aParentPtr Pointer to the new parent. The new parent may be null if the attachment
   //! was severed.
   virtual void ComponentParentChanged(ParentType* aParentPtr) {}

   //! Return the pointer to the parent.
   //! The return value will be zero if the component does not have a parent.
   ParentType* GetComponentParent() const { return mParentPtr; }

   //! Set the pointer to the parent.
   //! @param aParentPtr The pointer to the parent. This can be the null pointer if the component
   //! is being told it no longer has a parent.
   void SetComponentParent(ParentType* aParentPtr)
   {
      mParentPtr = aParentPtr;
      ComponentParentChanged(aParentPtr); // Inform of change of parent
   }
   //@}

private:
   ParentType* mParentPtr;
};

//! A convenient typedef for a platform component.
using WsfPlatformComponent = WsfComponentT<WsfPlatform>;

#endif
