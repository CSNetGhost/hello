// ****************************************************************************
// CUI
//
// The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
//
// Copyright 2003-2015 The Boeing Company. All rights reserved.
//
// The use, dissemination or disclosure of data in this file is subject to
// limitation or restriction. See accompanying README and LICENSE for details.
// ****************************************************************************

#include "WsfTrack.hpp"

#include <algorithm>
#include <cassert>
#include <iostream>
#include <memory>
#include <sstream>

#include "UtDCM.hpp"
#include "UtEllipsoidalEarth.hpp"
#include "UtEntity.hpp"
#include "UtInput.hpp"
#include "UtInputBlock.hpp"
#include "UtMath.hpp"
#include "UtMeasurementUtil.hpp"
#include "UtSphericalEarth.hpp"
#include "UtVec3.hpp"
#include "WsfFilter.hpp"
#include "WsfObject.hpp"
#include "WsfPlatform.hpp"
#include "WsfProcessor.hpp"
#include "WsfScenario.hpp"
#include "WsfSensor.hpp"
#include "WsfSimulation.hpp"
#include "WsfStringId.hpp"
#include "WsfTerrain.hpp"
#include "WsfTrackId.hpp"

// =================================================================================================
//! Use this constructor if the track is a 'predefined track'.
WsfTrack::WsfTrack()
{
   ConstructInformation();
   InitializeMemberData();
   mTrackType         = cPREDEFINED;
   mIsFusible         = false;
   mIsPurgeable       = false;
   mGlobalTrackNumber = 0;
}

// =================================================================================================
//! Use this constructor if the track is a 'predefined track'.
WsfTrack::WsfTrack(WsfStringId aOriginatorNameId, WsfStringId aOriginatorTypeId)
{
   ConstructInformation();
   InitializeMemberData();
   mTrackType               = cPREDEFINED;
   mIsFusible               = false;
   mIsPurgeable             = false;
   mOriginatorNameId        = aOriginatorNameId;
   mOriginatorPlatformIndex = 0;
   mOriginatorTypeId        = aOriginatorTypeId;
   mGlobalTrackNumber       = 0;
}

// =================================================================================================
//! Use this constructor for tracks generated by a platform part.
WsfTrack::WsfTrack(TrackType aTrackType, WsfObject* aOriginatingProcessorOrSensor, WsfPlatform* aOriginatingPlatform)
{
   assert(aOriginatingProcessorOrSensor != nullptr);
   ConstructInformation();
   InitializeMemberData();
   mTrackType         = aTrackType;
   mIsFusible         = true;
   mIsPurgeable       = true;
   mGlobalTrackNumber = 0;

   mTrackId.SetOwningPlatformId(aOriginatingPlatform->GetNameId());
   mOriginatorNameId        = aOriginatingPlatform->GetNameId();
   mOriginatorPlatformIndex = aOriginatingPlatform->GetIndex();
   mOriginatorTypeId        = aOriginatingPlatform->GetTypeId();

   if (aTrackType == cUNFILTERED_SENSOR)
   {
      assert(dynamic_cast<WsfSensor*>(aOriginatingProcessorOrSensor) != nullptr);
      double WCS_ToPCS_Transform[3][3];
      static_cast<WsfSensor*>(aOriginatingProcessorOrSensor)->GetWCSToPCSTransform(WCS_ToPCS_Transform);

      SetOriginatorTransformWCS(WCS_ToPCS_Transform);
      mSensorNameId = aOriginatingProcessorOrSensor->GetNameId();
      mSensorTypeId = aOriginatingProcessorOrSensor->GetTypeId();
   }
   else if (dynamic_cast<WsfProcessor*>(aOriginatingProcessorOrSensor) != nullptr)
   {
      mProcessorNameId = aOriginatingProcessorOrSensor->GetNameId();
      mProcessorTypeId = aOriginatingProcessorOrSensor->GetTypeId();
   }
}

// =================================================================================================
WsfTrack::WsfTrack(const WsfTrack& aSrc)
   : UtScriptAccessible(aSrc)
   , UtReferenceTracked()
   , WsfMeasurement(aSrc)
   , WsfAuxDataEnabled(aSrc)
{
   ConstructInformation();
   CopyMemberData(aSrc, cCC_COPY_CONSTRUCTOR);
}

void WsfTrack::ConstructInformation()
{
   // Initialize optional pointer values
   mSignalListPtr.Get()         = nullptr;
   mResidualCovariancePtr.Get() = nullptr;
}

// =================================================================================================
//! Initializes all the member data
void WsfTrack::InitializeMemberData()
{
   mSimulationPtr           = nullptr;
   mTrackType               = cPROCESSED;
   mOriginatorNameId        = nullptr;
   mOriginatorPlatformIndex = 0;
   mOriginatorTypeId        = nullptr;
   mProcessorNameId         = nullptr;
   mProcessorTypeId         = nullptr;
   mSensorNameId            = nullptr;
   mSensorTypeId            = nullptr;
   mSensorModeId            = nullptr;
   mUpdateCount             = 0;
   mStartTime               = 0.0;
   mMessageDataTag          = 0.0;

   mUpdateTime.Set(0.0);
   mLastUpdateTime.Set(0.0);
   mOriginatorLocationWCS.Get().Set(0.0); // Sets are performed on the UtVec3d object.
   mLocationWCS.Get().Set(0.0);
   mVelocityWCS.Get().Set(0.0);
   mLocationLLA.Get().Set(0.0);
   mRange.Set(0.0);
   mBearing.Set(0.0);
   mElevation.Set(0.0);
   mRangeRate.Set(0.0);
   mTrackQuality.Set(0.5);
   mSignalToNoise.Set(0.0);
   mPixelCount.Set(0.0);
   for (UtStringIdInformation& typeId : mTypeIds)
   {
      typeId.Set(WsfStringId(nullptr));
   }
   mSideId.Set(WsfStringId(nullptr));
   mIFF_Status.Set(cIFF_UNKNOWN);
   mSpatialDomain.Set(WSF_SPATIAL_DOMAIN_UNKNOWN);
   mIsFusible      = true;
   mIsPurgeable    = true;
   mIsPurgeable    = false;
   mIsStale        = false;
   mIs3D           = false;
   mIsReportable   = true;
   mIsCandidate    = false;
   mIsStrobe       = false;
   mIsFalseTarget  = false;
   mFalseTargetId  = 0;
   mTargetIndex    = 0;
   mTargetName     = nullptr;
   mTargetType     = nullptr;
   mLastSourceName = nullptr;

   mGlobalTrackNumber = 0;
}

// =================================================================================================
//! Copies the provided track's member data.
//!
//! @param aSrc    The source track to copy.
//! @param aCaller The indication of who is calling this function. The operation is slightly different
//!                depending on the source of the call (copy constructor, assignment or replacement update).
// private
void WsfTrack::CopyMemberData(const WsfTrack& aSrc, CopyCaller aCaller)
{
   // NOTE: A 'Replacement Update' only replaces the 'reported data'. The track identity in the
   // receiving track (track ID, track type, and originator) and the update count/time are left
   // so they can be updated by the caller.
   //
   // 'Replacement Update' is called by WsfDefaultFusion::UpdateLocalTrackFromNonLocalTrack to
   // update a 'mirror track' which is a local track that mirrors a non-local track. The identity
   // of the local track MUST be preserved as it is a local product (in fact, the daily test
   // auto_trackmanager/test_task_quality.txt fails if the track type is changed from cPROCESSED).

   if (aCaller != cCC_REPLACEMENT_UPDATE)
   {
      mSimulationPtr           = aSrc.mSimulationPtr;
      mTrackId                 = aSrc.mTrackId;
      mTrackType               = aSrc.mTrackType;
      mOriginatorNameId        = aSrc.mOriginatorNameId;
      mOriginatorPlatformIndex = aSrc.mOriginatorPlatformIndex;
      mOriginatorTypeId        = aSrc.mOriginatorTypeId;
      mProcessorNameId         = aSrc.mProcessorNameId;
      mProcessorTypeId         = aSrc.mProcessorTypeId;
      mSensorNameId            = aSrc.mSensorNameId;
      mSensorTypeId            = aSrc.mSensorTypeId;
      mSensorModeId            = aSrc.mSensorModeId;
      mUpdateCount             = aSrc.mUpdateCount;
      mStartTime               = aSrc.mStartTime;
      mUpdateTime              = aSrc.mUpdateTime;
      mLastUpdateTime          = aSrc.mLastUpdateTime;
      mGlobalTrackNumber       = aSrc.mGlobalTrackNumber;
   }
   mMessageDataTag  = aSrc.mMessageDataTag;
   mRange           = aSrc.mRange;
   mBearing         = aSrc.mBearing;
   mElevation       = aSrc.mElevation;
   mSensorAzimuth   = aSrc.mSensorAzimuth;
   mSensorElevation = aSrc.mSensorElevation;
   mRangeRate       = aSrc.mRangeRate;
   mTrackQuality    = aSrc.mTrackQuality;
   mSignalToNoise   = aSrc.mSignalToNoise;
   mPixelCount      = aSrc.mPixelCount;
   mTypeIds         = aSrc.mTypeIds;
   mSideId          = aSrc.mSideId;
   mIFF_Status      = aSrc.mIFF_Status;
   mSpatialDomain   = aSrc.mSpatialDomain;
   mIsFusible       = aSrc.mIsFusible;
   mIsPurgeable     = aSrc.mIsPurgeable;
   mIsStale         = aSrc.mIsStale;
   mIs3D            = aSrc.mIs3D;
   mIsReportable    = aSrc.mIsReportable;
   mIsCandidate     = aSrc.mIsCandidate;
   mIsStrobe        = aSrc.mIsStrobe;
   mIsFalseTarget   = aSrc.mIsFalseTarget;
   mFalseTargetId   = aSrc.mFalseTargetId;
   mTargetIndex     = aSrc.mTargetIndex;
   mTargetName      = aSrc.mTargetName;
   mTargetType      = aSrc.mTargetType;
   mLastSourceName  = aSrc.mLastSourceName;

   // TODO partial template specialization for copy construction
   mOriginatorLocationWCS  = aSrc.mOriginatorLocationWCS;
   mOriginatorTransformWCS = aSrc.mOriginatorTransformWCS;
   mLocationWCS            = aSrc.mLocationWCS;
   mVelocityWCS            = aSrc.mVelocityWCS;
   mLocationLLA            = aSrc.mLocationLLA;

   // Handle the members that are pointers.
   //
   // 1) If the caller is the copy constructor then the pointers are not valid. The data is simply copied
   //    from the source if it exists.
   // 2) If the caller is the assignment operator then any existing value is deleted and the data is copied
   //    from the source if it exists.
   // 3) If the caller is the replacement update, it is treated like assignment except for aux_data, which
   //    is left as-is.

   if (aCaller != cCC_COPY_CONSTRUCTOR)
   {
      mSignalListPtr.Reset();
   }
   mSignalListPtr.CopyFrom(aSrc.mSignalListPtr);

   if (aCaller != cCC_COPY_CONSTRUCTOR)
   {
      mEmitterTypeIdListPtr.Reset();
   }
   mEmitterTypeIdListPtr.CopyFrom(aSrc.mEmitterTypeIdListPtr);

   if (aCaller != cCC_COPY_CONSTRUCTOR)
   {
      mMeasurementCovariancePtr.Reset();
   }
   mMeasurementCovariancePtr.CopyFrom(aSrc.mMeasurementCovariancePtr);

   if (aCaller != cCC_COPY_CONSTRUCTOR)
   {
      mStateCovariancePtr.Reset();
   }
   mStateCovariancePtr.CopyFrom(aSrc.mStateCovariancePtr);

   if (aCaller != cCC_COPY_CONSTRUCTOR)
   {
      mResidualCovariancePtr.Reset();
   }
   mResidualCovariancePtr.CopyFrom(aSrc.mResidualCovariancePtr);

   // Preferentially clear the local track history and copy any source track history.
   if (!aSrc.mHistory.empty())
   {
      // Only clear local track history if source track history is available,
      // as the Track Manager may be keeping a history that should otherwise be preserved.
      mHistory.clear();

      for (const auto& meas : aSrc.mHistory)
      {
         GetHistory().emplace_back(meas->Clone());
      }
   }
}

// =================================================================================================
// virtual
WsfTrack::~WsfTrack()
{
   UtReferenceTracked::FreeReference();
}

// =================================================================================================
//! Set the 'track type'.
//! @note This only allows switching between filtered and unfiltered sensor types.
void WsfTrack::SetTrackType(TrackType aTrackType)
{
   if ((aTrackType == cUNFILTERED_SENSOR) || (aTrackType == cFILTERED_SENSOR) || (aTrackType == cSTATIC_IMAGE) ||
       (aTrackType == cPSEUDO_SENSOR))
   {
      // Prohibit switching from a non-sensor track to a sensor track as the sensor name and type are not defined.
      if ((mTrackType == cUNFILTERED_SENSOR) || (mTrackType == cFILTERED_SENSOR) || (mTrackType == cSTATIC_IMAGE) ||
          (mTrackType == cPSEUDO_SENSOR))
      {
         mTrackType = aTrackType;
      }
   }
   else
   {
      // New track type is not a sensor track.
      mTrackType    = aTrackType;
      mSensorNameId = nullptr;
      mSensorTypeId = nullptr;
      mSensorModeId = nullptr;
   }
}

// =================================================================================================
//! Check for and process a track-related command.
//! @param aInput The input stream object.
//! @returns true if the command was understood and processed or false if the command
//! was not recognized.
//! @note The base class method does not check for the 'position', 'altitude', 'speed' or 'heading'
//! commands because they require additional processing after the entire track has been read.
//! These command are processed directly by ProcessInputBlock() and the required additional processing
//! is done after the block terminator is processed.
bool WsfTrack::ProcessInput(UtInput& aInput)
{
   bool        myCommand = true;
   std::string command(aInput.GetCommand());
   if (command == "range")
   {
      double range;
      aInput.ReadValueOfType(range, UtInput::cLENGTH);
      aInput.ValueGreater(range, 0.0);
      mRange.Set(range);
      mRange.SetValid(true);
   }
   else if (command == "bearing")
   {
      double bearing;
      aInput.ReadValueOfType(bearing, UtInput::cANGLE);
      aInput.ValueInClosedRange(bearing, 0.0, UtMath::cTWO_PI);
      mBearing.Set(bearing);
      mBearing.SetValid(true);
   }
   else if (command == "elevation")
   {
      double elevation;
      aInput.ReadValueOfType(elevation, UtInput::cANGLE);
      aInput.ValueInClosedRange(elevation, -UtMath::cPI_OVER_2, UtMath::cPI_OVER_2);
      mElevation.Set(elevation);
      mElevation.SetValid(true);
   }
   else if (command == "frequency")
   {
      double frequency;
      aInput.ReadValueOfType(frequency, UtInput::cFREQUENCY);
      aInput.ValueGreaterOrEqual(frequency, 0.0);
      SetFrequency(frequency);
   }
   else if (command == "side")
   {
      std::string sideName;
      aInput.ReadValue(sideName);
      mSideId.Set(WsfStringId(sideName));
      mSideId.SetValid(true);
   }
   else if (command == "type")
   {
      std::string typeName;
      aInput.ReadValue(typeName);
      SetTypeId(WsfStringId(typeName));
      SetTypeIdValid(true);
   }
   else if (command == "platform")
   {
      aInput.ReadValue(mTargetName);
   }
   else if (command == "quality")
   {
      double trackQuality;
      aInput.ReadValue(trackQuality);
      aInput.ValueInClosedRange(trackQuality, 0.0, 1.0);
      mTrackQuality.Set(trackQuality);
   }
   else if (command == "reportable")
   {
      mIsReportable = true;
   }
   else if (command == "non_reportable")
   {
      mIsReportable = false;
   }
   else if (WsfAuxDataEnabled::ProcessInput(aInput))
   {
   }
   else if (WsfMeasurement::ProcessInput(aInput))
   {
   }
   else
   {
      myCommand = false;
   }

   return myCommand;
}

// =================================================================================================
//! Read a block of track commands up to 'end_' token defined for the input block.
//! This is the preferred mechanism for reading a block that defines a track. The caller
//! should have read the command that introduced the track block (e.g.: 'track') and
//! then created a UtInputBlock that defines the terminator (e.g.: 'end_track'). This
//! method will then repeatedly invoke ProcessInput() to read and process commands.
//! A derived class can provide additional commands via their implementation of ProcessInput().
//!
//! @param aScenario   The scenario
//! @param aInputBlock The input block stream object.
//!
//! @note In general this method should not be overridden unless a derived class intends on
//! completely reimplementing whatever functionality is desired.
void WsfTrack::ProcessInputBlock(const WsfScenario& aScenario, UtInputBlock& aInputBlock)
{
   double      speed       = 0.0;
   double      heading     = 0.0;
   bool        haveLatLon  = false;
   bool        haveAlt     = false;
   bool        altIsAGL    = false;
   bool        haveSpeed   = false;
   bool        haveHeading = false;
   std::string command;
   while (aInputBlock.ReadCommand(command))
   {
      if (command == "position")
      {
         double lat = 0.0;
         double lon = 0.0;
         aInputBlock.GetInput().ReadValueOfType(lat, UtInput::cLATITUDE);
         aInputBlock.GetInput().ReadValueOfType(lon, UtInput::cLONGITUDE);
         mLocationLLA.Get()[0] = lat;
         mLocationLLA.Get()[1] = lon;
         haveLatLon            = true;
      }
      else if (command == "mgrs_coordinate")
      {
         std::string mgrs;
         aInputBlock.GetInput().ReadValue(mgrs);

         if (!UtEllipsoidalEarth::ConvertMGRSToLL(mgrs, mLocationLLA.Get()[0], mLocationLLA.Get()[1]))
         {
            throw UtInput::BadValue(aInputBlock.GetInput(), "Unable to convert MGRS location: " + mgrs);
         }
         haveLatLon = true;
      }
      else if (command == "altitude")
      {
         double alt = 0.0;
         aInputBlock.GetInput().ReadValueOfType(alt, UtInput::cLENGTH);
         mLocationLLA.Get()[2] = alt;
         haveAlt               = true;
      }
      else if (command == "agl")
      {
         altIsAGL = true;
      }
      else if (command == "msl")
      {
         altIsAGL = false;
      }
      else if (command == "speed")
      {
         aInputBlock.GetInput().ReadValueOfType(speed, UtInput::cSPEED);
         aInputBlock.GetInput().ValueGreaterOrEqual(speed, 0.0);
         haveSpeed = true;
      }
      else if (command == "heading")
      {
         aInputBlock.GetInput().ReadValueOfType(heading, UtInput::cANGLE);
         aInputBlock.GetInput().ValueInClosedRange(heading, 0.0, UtMath::cTWO_PI);
         haveHeading = true;
      }
      else if (!ProcessInput(aInputBlock.GetInput()))
      {
         throw UtInput::UnknownCommand(aInputBlock.GetInput());
      }
   }

   // Ensure the consistency of position information.

   if (haveLatLon)
   {
      if (mRange.IsValid() || mBearing.IsValid())
      {
         throw UtInput::BadValue(aInputBlock.GetInput(),
                                 "'range' and 'bearing' cannot be specified with 'position' or 'mgrs_coordinate'");
      }

      double lat, lon, alt;
      mLocationLLA.Get().Get(lat, lon, alt);

      // If an altitude wasn't supplied then put it 1 meter above the ground
      if (!haveAlt)
      {
         alt      = 1.0;
         altIsAGL = true;
      }
      if (altIsAGL)
      {
         wsf::Terrain terrain(wsf::TerrainInterface::Get(aScenario));
         float        elev;
         terrain.GetElevInterp(lat, lon, elev);
         alt += elev;
      }

      mLocationLLA.Get().Set(lat, lon, alt);
      mLocationLLA.SetValid(true);

      WsfPlatform::ConvertLLAToWCS(lat, lon, alt, mLocationWCS.Get().GetData());
      mLocationWCS.SetValid(true);
      mIs3D = haveAlt;
   }
   else if ((!mRange.IsValid()) && (!mBearing.IsValid()))
   {
      // A predefined track can specify a platform ID, and truth data
      // from the platform will be populated during Initialize()
      bool preBriefed = (mTrackType == WsfTrack::cPREDEFINED) && !mTargetName.Empty();
      if (!preBriefed)
      {
         throw UtInput::BadValue(aInputBlock.GetInput(), "A position, range or bearing must be provided");
      }

      if (aScenario.GetInputPlatformByName(mTargetName) == nullptr)
      {
         std::ostringstream oss;
         oss << "Target platform '" << mTargetName
             << "' of pre-briefed track was not defined prior to the track definition.";
         throw UtInput::BadValue(aInputBlock.GetInput(), oss.str());
      }
   }

   if (haveSpeed && haveHeading)
   {
      double   velocityNED[3] = {cos(heading) * speed, sin(heading) * speed, 0.0};
      UtEntity entity;
      entity.SetLocationWCS(mLocationWCS.Get().GetData());
      entity.SetVelocityNED(velocityNED);
      entity.GetVelocityWCS(mVelocityWCS.Get().GetData());
      mVelocityWCS.SetValid(true);
   }
   else if (haveSpeed && (!haveHeading))
   {
      throw UtInput::BadValue(aInputBlock.GetInput(), "speed and heading must be provided together");
   }
}

// =================================================================================================
//! Load an initial track from an input stream.
//! @param aScenario The Scenario
//! @param aInput [input] The input stream.
//! @param aPlatformPtr [input] The platform that is the 'owner' of the track
//! (needed for relative geometry calculations and such).
//! @param aTrackPtr [output] Pointer to the track if the current command was a
//! a track definition.
//! @returns true if the current command was a track definition or false if not.
// static
bool WsfTrack::LoadTrackInstance(const WsfScenario& aScenario, UtInput& aInput, WsfPlatform* aPlatformPtr, WsfTrack*& aTrackPtr)
{
   bool myCommand = false;
   if (aInput.GetCommand() == "track")
   {
      myCommand = true;
      aTrackPtr = nullptr;
      WsfStringId nameId;
      WsfStringId typeId;
      if (aPlatformPtr != nullptr)
      {
         nameId = aPlatformPtr->GetNameId();
         typeId = aPlatformPtr->GetTypeId();
      }
      std::unique_ptr<WsfTrack> trackPtr(new WsfTrack(nameId, typeId));
      if (aPlatformPtr != nullptr)
      {
         double originatorWCS[3];
         aPlatformPtr->GetLocationWCS(originatorWCS);
         trackPtr->SetOriginatorLocationWCS(originatorWCS);
      }
      UtInputBlock inputBlock(aInput);
      trackPtr->ProcessInputBlock(aScenario, inputBlock);
      aTrackPtr = trackPtr.get();
      trackPtr.release();
   }
   return myCommand;
}

// =================================================================================================
//! Make a copy (clone) of the track.
//! @return A pointer to the newly created track.
// virtual
WsfTrack* WsfTrack::Clone() const
{
   return new WsfTrack(*this);
}

// =================================================================================================
//! Initialize a new track.
//!
//!   This ONLY sets the track ID, track start and update times and update count.
//!   All other fields remain at their previous values.
//!   @param aSimTime The current simulation time. The start time and last update
//!   time of the track will be set to this value.
//!   @param aTrackId The track ID to be associated with the new track.
//!   @param aSimulation The Simulation
// virtual
void WsfTrack::Initialize(double aSimTime, const WsfTrackId& aTrackId, WsfSimulation& aSimulation)
{
   WsfMeasurement::SetSimulation(aSimulation);

   // If the originator index isn't set, find it now.  Usually only necessary for predefined tracks.
   if (!mOriginatorPlatformIndex && !mOriginatorNameId.IsNull())
   {
      WsfPlatform* originatorPtr = aSimulation.GetPlatformByName(mOriginatorNameId);
      if (originatorPtr != nullptr)
      {
         mOriginatorPlatformIndex = originatorPtr->GetIndex();
      }
   }

   if ((mUpdateTime.Get() != 0.0) && (mUpdateTime.Get() < aSimTime) && (mLocationWCS.IsValid() && mVelocityWCS.IsValid()))
   {
      // Just in case we are re-initializing a clone of a track,
      // or from an older time stamp, propagate the velocity forward.
      double locWCS[3];
      mLocationWCS.Get().Get(locWCS);
      GetExtrapolatedLocationWCS(aSimTime, locWCS);
   }

   // If this is a predefined track that references a specific target AND if no position information
   // has been provided, then use the truth location as the location.
   //
   // This is a convenience so people can do things like:
   //
   //    platform ...
   //       track
   //          platform target-1
   //       end_track
   //    end_platform
   //
   // NOTE: this only works if the target platform appears before the platform containing the track definition.

   if (IsPredefinedTrack() && (GetTargetIndex() != 0))
   {
      bool havePositionData = mLocationWCS.IsValid() || mLocationLLA.IsValid() || mRange.IsValid() ||
                              mBearing.IsValid() || mElevation.IsValid();
      if (!havePositionData && mSimulationPtr)
      {
         size_t       targetIndex = GetTargetIndex();
         WsfPlatform* platformPtr = mSimulationPtr->GetPlatformByIndex(targetIndex);
         if (platformPtr != nullptr)
         {
            double locWCS[3] = {0.0};
            platformPtr->GetLocationWCS(locWCS);
            SetLocationWCS(locWCS);
         }
      }
   }

   mTrackId   = aTrackId;
   mStartTime = aSimTime;
   mUpdateTime.SetAndValidate(aSimTime);
   mUpdateCount = 0;
}

// =================================================================================================
//! Indicate the track is being updated.
//!
//! This ONLY updates the update time and update count.
//! All other fields remain at their previous values.
//!
//! @param aSimTime The current simulation time. This last update time of the track will be set to this value.
// virtual
void WsfTrack::Update(double aSimTime)
{
   // The count is updated only if time is moved forward. This prevents the unnecessary increment
   // if Update() is called immediately after Initialize(). (An update count of 0 indicates the
   // track is newly created with its initial data).
   if (aSimTime > mUpdateTime.Get())
   {
      ++mUpdateCount;
   }
   mLastUpdateTime = mUpdateTime;
   mUpdateTime.SetAndValidate(aSimTime);
}

// =================================================================================================
//! Update a track from an existing measurement.
//! Only measurement information are copied (no track fusion occurs).
//! "Invariant" data such as track type and track id are not copied.
void WsfTrack::UpdateFromMeasurement(double aSimTime, const WsfTrack& aMeasurement)
{
   Update(aSimTime);

   mUpdateTime = aMeasurement.mUpdateTime;

   mRange         = aMeasurement.mRange;
   mBearing       = aMeasurement.mBearing;
   mElevation     = aMeasurement.mElevation;
   mRangeRate     = aMeasurement.mRangeRate;
   mTrackQuality  = aMeasurement.mTrackQuality;
   mSignalToNoise = aMeasurement.mSignalToNoise;
   mPixelCount    = aMeasurement.mPixelCount;
   mTypeIds       = aMeasurement.mTypeIds;
   mSideId        = aMeasurement.mSideId;
   mIFF_Status    = aMeasurement.mIFF_Status;
   mSpatialDomain = aMeasurement.mSpatialDomain;

   mIsFalseTarget = aMeasurement.mIsFalseTarget;
   mIsStale       = aMeasurement.mIsStale;
   mFalseTargetId = aMeasurement.mFalseTargetId;
   mTargetIndex   = aMeasurement.mTargetIndex;
   mTargetName    = aMeasurement.mTargetName;
   mTargetType    = aMeasurement.mTargetType;

   mOriginatorLocationWCS = aMeasurement.mOriginatorLocationWCS;
   mLocationWCS           = aMeasurement.mLocationWCS;
   mVelocityWCS           = aMeasurement.mVelocityWCS;
   mLocationLLA           = aMeasurement.mLocationLLA;

   if (aMeasurement.mSignalListPtr.IsValid())
   {
      mSignalListPtr.Set(aMeasurement.mSignalListPtr);
   }

   if (aMeasurement.mEmitterTypeIdListPtr.IsValid())
   {
      mEmitterTypeIdListPtr.Set(aMeasurement.mEmitterTypeIdListPtr);
   }

   if (aMeasurement.mStateCovariancePtr.IsValid())
   {
      mStateCovariancePtr.Set(aMeasurement.mStateCovariancePtr);
   }

   if (aMeasurement.mResidualCovariancePtr.IsValid())
   {
      mResidualCovariancePtr.Set(aMeasurement.mResidualCovariancePtr);
   }

   if (aMeasurement.HasAuxData())
   {
      SetAuxData(aMeasurement.GetAuxDataConst());
   }
}

// =================================================================================================
//! Set the track reportable flag used by the local track manager to support reporting decision.
// ! @note Will not change if the track type is predefined.
void WsfTrack::IsReportable(bool aIsReportable)
{
   if (!IsPredefinedTrack())
   {
      mIsReportable = aIsReportable;
   }
}

// =================================================================================================
//! Does the track have sufficient data to be considered a "3D" track.
//! For a fused track this flag is set if there were sufficient data to create a
//! 3D location estimate (for example, if range, bearing, and elevation are all available from the
//! same sensor).  This flag should be set false if some part of the solution is guessed
//! (for example, altitude guessed in conjunction with a range-bearing report).
//! This method may return a different result from WsfTrack::LocationValid, as the location may
//! be valid without a true "3D" solution available.
bool WsfTrack::Is3D() const
{
   return mIs3D;
}

// =================================================================================================
// Fetch relative line of sight rates, from the Observer's perspective,
// for Intercept guidance.  Will return true if the results are valid.
bool WsfTrack::LineOfSightRatesFrom(double aSimTime, WsfPlatform* aObserver, double& aLOSR_Az, double& aLOSR_El)
{
   // This is self-documenting code.  :-)
   if (!(LocationValid() && VelocityValid()))
   {
      return false;
   }
   aObserver->Update(aSimTime);
   UtVec3dX obLoc, obVel, tgtLoc, tgtVel;
   aObserver->GetLocationWCS(obLoc.GetData());
   aObserver->GetVelocityWCS(obVel.GetData());
   GetExtrapolatedLocationWCS(aSimTime, tgtLoc.GetData());
   GetVelocityWCS(tgtVel.GetData());
   UtVec3dX losrI   = UtVec3dX::LineOfSightRates(obLoc, obVel, tgtLoc, tgtVel);
   UtVec3dX losrECS = losrI * aObserver->GetDcmWCStoECS();
   aLOSR_Az         = losrECS[2];
   aLOSR_El         = losrECS[1];
   return true;
}

// =================================================================================================
//! Identify the specified platform as the originator.
void WsfTrack::SetPlatformOriginator(WsfPlatform* aOriginatorPtr)
{
   if (aOriginatorPtr != nullptr)
   {
      mOriginatorNameId        = aOriginatorPtr->GetNameId();
      mOriginatorPlatformIndex = aOriginatorPtr->GetIndex();
      mOriginatorTypeId        = aOriginatorPtr->GetTypeId();
      mTrackId.SetOwningPlatformId(mOriginatorNameId);
   }
   else
   {
      mOriginatorNameId        = nullptr;
      mOriginatorPlatformIndex = 0;
      mOriginatorTypeId        = nullptr;
      mTrackId.SetOwningPlatformId(nullptr);
   }
}

// =================================================================================================
//! Identify the specified processor as the originator.
void WsfTrack::SetProcessorOriginator(WsfObject* aProcessorPtr, WsfPlatform* aPlatform)
{
   SetPlatformOriginator(aPlatform);
   mTrackType   = cPROCESSED;
   mIsFusible   = true;
   mIsPurgeable = true;

   if (aProcessorPtr != nullptr)
   {
      mProcessorNameId = aProcessorPtr->GetNameId();
      mProcessorTypeId = aProcessorPtr->GetTypeId();
   }
   else
   {
      mProcessorNameId = nullptr;
      mProcessorTypeId = nullptr;
   }
}

// =================================================================================================
//! Identify the specified sensor as the originator.
void WsfTrack::SetSensorOriginator(WsfObject* aSensorPtr, WsfPlatform* aPlatformPtr)
{
   SetPlatformOriginator(aPlatformPtr);
   if (aSensorPtr != nullptr)
   {
      SetSensorOriginator(aSensorPtr->GetNameId(), aSensorPtr->GetTypeId());
   }
   else
   {
      SetSensorOriginator(nullptr, nullptr);
   }
}

// =================================================================================================
//! Identify the specified sensor as the originator.
//!
//! This is a special form typically used by image processors which create tracks from the image.
//! It sets the producing sensor name and type, even though this isn't a direct sensor measurement.
//! (This is a sort of 'hybrid' track in which the characteristics of the sensor are maintained).
void WsfTrack::SetSensorOriginator(WsfStringId aSensorNameId, WsfStringId aSensorTypeId)
{
   mTrackType    = cUNFILTERED_SENSOR;
   mIsFusible    = true;
   mIsPurgeable  = true;
   mSensorNameId = aSensorNameId;
   mSensorTypeId = aSensorTypeId;
}

//! Set the track quality.
void WsfTrack::SetTrackQuality(double aTrackQuality)
{
   mTrackQuality.Set(aTrackQuality);
}

// =================================================================================================
// virtual
//! Update the track to the given time based on the current kinematic state estimate.
//! This state estimate will be based on the associated filter, if present, or a
//! simple velocity-based approximation, if no filter is present.
//! The track's location, velocity, and covariance matrix may all be updated.
void WsfTrack::KinematicUpdate(double aSimTime)
{
   // If possible update the location and velocity to the current time.

   if (aSimTime > GetUpdateTime())
   {
      auto* filterPtr = GetFilter();
      if (filterPtr != nullptr)
      {
         WsfMeasurement estimate;
         filterPtr->NoDetectUpdate(aSimTime, estimate);
         if (estimate.LocationValid())
         {
            SetLocationWCS(estimate.GetLocationWCS().GetData());
         }
         if (estimate.VelocityValid())
         {
            SetVelocityWCS(estimate.GetVelocityWCS().GetData());
         }

         UtCovariance predictedCovar;

         if (filterPtr->GetPredictedStateCovariance(aSimTime, predictedCovar))
         {
            SetStateCovariance(aSimTime, predictedCovar);
            SetStateCovarianceValid(true);
         }
         else if (StateCovarianceValid())
         {
            predictedCovar.ComputePredictedState(aSimTime, *GetStateCovariance(), *this);
            SetStateCovariance(aSimTime, predictedCovar);
         }
      }
      else // No filter
      {
         WsfMeasurement::KinematicUpdate(aSimTime);
      }
      if (mStateCovariancePtr.IsValid() && (UseQuantitativeTrackQuality()))
      {
         mTrackQuality.Set(UtMeasurementUtil::GetQuantitativeMeasurementQuality(aSimTime, *this));
      }
   }

   // update time and count.
   WsfTrack::Update(aSimTime);
}

// =================================================================================================
// virtual
void WsfTrack::ReplacementUpdate(const WsfTrack& aSource)
{
   // Copy the required data from the source. This is pretty much everything except the track ID,
   // start and update times, and update count.
   CopyMemberData(aSource, cCC_REPLACEMENT_UPDATE);

   // Call the base class update, which updates the "update" time and count.
   WsfTrack::Update(aSource.GetUpdateTime());
}

// =================================================================================================
//! Adds a signal to the list of detected signals.
//! The signal will not be added if it is already in the list.
//! @param aSignal The signal to be added
void WsfTrack::AddSignal(const Signal& aSignal)
{
   if (mSignalListPtr.Get() == nullptr)
   {
      mSignalListPtr.Get() = new SignalList();
      mSignalListPtr.Get()->mSignalList.push_back(aSignal);
      mSignalListPtr.SetValid(true);
   }
   else
   {
      // Maintain list in increasing lower frequency order with no duplicates
      std::vector<Signal>& signalList = mSignalListPtr.Get()->mSignalList;
      auto                 sli        = signalList.begin();
      while (sli != signalList.end())
      {
         Signal& signal = *sli;
         if (aSignal.mLowerFrequency == signal.mLowerFrequency)
         {
            if (aSignal.mUpperFrequency == signal.mUpperFrequency)
            {
               return; // Duplicate
            }
            else if (aSignal.mUpperFrequency < signal.mUpperFrequency)
            {
               break; // Found the insert location
            }
         }
         else if (aSignal.mLowerFrequency < signal.mLowerFrequency)
         {
            break; // Found the insert location
         }
         ++sli;
      }
      signalList.insert(sli, aSignal);
   }
}

// =================================================================================================
//! Get the number of entries in the detected signal list.
//! @returns The number of entries in the detected signal list.
unsigned int WsfTrack::GetSignalCount() const
{
   unsigned int count = 0;
   if (mSignalListPtr.Get() != nullptr)
   {
      count = static_cast<unsigned int>(mSignalListPtr.Get()->mSignalList.size());
   }
   return count;
}

// =================================================================================================
//! Get the i'th signal from the list of detected signal.
//! @param aIndex [input] The index of the desired entry. This must be in the range [0..GetSignalCount()-1].
//! @param aSignal [output] The desired entry. This is not modified if the aIndex is not in range.
void WsfTrack::GetSignalEntry(unsigned int aIndex, Signal& aSignal) const
{
   if ((mSignalListPtr.Get() != nullptr) && (aIndex < mSignalListPtr.Get()->mSignalList.size()))
   {
      aSignal = mSignalListPtr.Get()->mSignalList[aIndex];
   }
   else
   {
      aSignal = Signal();
   }
}

// =================================================================================================
//! Merge a signal list from another track into this track.
//! Duplicates will be omitted.
//! @param aOtherTrack A reference to the other track.
void WsfTrack::MergeSignalLists(const WsfTrack& aOtherTrack)
{
   if ((aOtherTrack.mSignalListPtr.Get() == nullptr) || (aOtherTrack.mSignalListPtr.Get()->mSignalList.empty()))
   {
      return;
   }

   const std::vector<Signal>& otherList = aOtherTrack.mSignalListPtr.Get()->mSignalList;
   for (auto& signal : otherList)
   {
      AddSignal(signal);
   }
}

// =================================================================================================
//! Set the list of detected signals associated with the track.
//! @param aSignalList The list of detected frequencies.
void WsfTrack::SetSignalList(const std::vector<Signal>& aSignalList)
{
   if (aSignalList.empty())
   {
      delete mSignalListPtr.Get();
      mSignalListPtr.Get() = nullptr;
      mSignalListPtr.SetValid(false);
   }
   else
   {
      // Entries are added one at a time to ensure ascending order and no duplicates.
      if (mSignalListPtr.Get() != nullptr)
      {
         delete mSignalListPtr.Get();
         mSignalListPtr.Get() = nullptr;
      }
      for (auto& signal : aSignalList)
      {
         AddSignal(signal);
      }
   }
}

// =================================================================================================
//! Get the frequency of the detected emitter.
//!
//! @returns The detected frequency (Hertz).
//! @note This is for compatibility with code that existed prior to the implementation of frequency lists.
//! lists. It will return the first frequency from the frequency list.
double WsfTrack::GetFrequency() const
{
   Signal signal;
   GetSignalEntry(0, signal);
   return (signal.mLowerFrequency + ((signal.mUpperFrequency - signal.mLowerFrequency) / 2));
}

// =================================================================================================
//! Set the frequency of the detected emitter.
//!
//! @param aFrequency The detected frequency (Hertz).
//! @note This is for compatibility with code that existed prior to the implementation of frequency lists.
//! lists. It will create a frequency list with a single frequency.
void WsfTrack::SetFrequency(double aFrequency)
{
   Signal              signal(aFrequency);
   std::vector<Signal> signalList;
   signalList.push_back(signal);
   SetSignalList(signalList);
}

// =================================================================================================
//! Is detected frequency attribute valid?
bool WsfTrack::FrequencyValid() const
{
   return mSignalListPtr.IsValid();
}

// =================================================================================================
//! Define whether or not the detected frequency attribute is valid.
//! Note: This function is deprecated.  Frequency is not valid unless there is at least one
//! item in the signal list.  Previously, the sensor input "reports_fequency" could be specified,
//! but if the sensor couldn't actually report it, there was a mismatch ("valid" == true when it
//! really is not), leading to undefined behavior in the copy constructor (now fixed).
void WsfTrack::SetFrequencyValid(bool aFrequencyValid)
{
   // Do nothing; only adding to the signal list produces a valid result.
}

// =================================================================================================
//! Adds a emitter type data to the list of emitter type data.
//! The emitter data will not be added if it is already in the list.
//! @param aEmitterTypeData The emitter type data to be added
void WsfTrack::AddEmitterTypeId(const EmitterTypeData& aEmitterTypeData)
{
   bool                                   duplicate = false;
   std::vector<EmitterTypeData>::iterator eti;
   if (mEmitterTypeIdListPtr.Get() == nullptr)
   {
      mEmitterTypeIdListPtr.Get() = new EmitterTypeIdList();
      mEmitterTypeIdListPtr.Get()->mEmitterTypeIdList.push_back(aEmitterTypeData);
      eti = mEmitterTypeIdListPtr.Get()->mEmitterTypeIdList.begin();
   }
   else
   {
      // Maintain list
      std::vector<EmitterTypeData>& emitterTypeIdList = mEmitterTypeIdListPtr.Get()->mEmitterTypeIdList;
      eti                                             = emitterTypeIdList.begin();
      while (eti != emitterTypeIdList.end())
      {
         EmitterTypeData& emitterTypeData = *eti;
         if (aEmitterTypeData.mEmitterTruthId == emitterTypeData.mEmitterTruthId)
         {
            duplicate = true;
            break;
         }
         ++eti;
      }
      if (!duplicate)
      {
         eti = emitterTypeIdList.insert(eti, aEmitterTypeData);
      }
   }

   if (!duplicate)
   {
      eti->mSignalIndices.clear();
      if (mSignalListPtr.Get() != nullptr)
      {
         for (unsigned int sle = 0; sle < mSignalListPtr.Get()->mSignalList.size(); ++sle)
         {
            if ((mSignalListPtr.Get()->mSignalList[sle].mEmitterTruthId != 0) && (aEmitterTypeData.mEmitterTruthId != 0) &&
                (mSignalListPtr.Get()->mSignalList[sle].mEmitterTruthId == eti->mEmitterTruthId))
            {
               mSignalListPtr.Get()->mSignalList[sle].mEmitterDerivedId = eti->mEmitterDerivedId;
               eti->mSignalIndices.push_back(sle);
            }
         }
      }
   }
}

// =================================================================================================
//! Adds a emitter type to the list of emitter types.
//! The emitter will not be added if it is already in the list.
//! @param aTruthEmitterTypeId The truth emitter type to be added
//! @param aEmitterTypeId The derived emitter type to be added
void WsfTrack::AddEmitterTypeId(WsfStringId aTruthEmitterTypeId, WsfStringId aEmitterTypeId)
{
   AddEmitterTypeId(EmitterTypeData(aTruthEmitterTypeId, aEmitterTypeId));
}

// =================================================================================================
//! Get the number of entries in the detected signal list.
//! @returns The number of entries in the detected signal list.
unsigned int WsfTrack::GetEmitterTypeIdCount() const
{
   unsigned int count = 0;
   if (mEmitterTypeIdListPtr.Get() != nullptr)
   {
      count = static_cast<unsigned int>(mEmitterTypeIdListPtr.Get()->mEmitterTypeIdList.size());
   }
   return count;
}

// =================================================================================================
//! Get the i'th emitter type from the list of emitter types.
//! @param aIndex [input] The index of the desired entry. This must be in the range [0..GetEmitterTypeCount()-1].
//! @param aEmitterTypeData [output] The desired entry. This is not modified if the aIndex is not in range.
void WsfTrack::GetEmitterTypeIdEntry(unsigned int aIndex, EmitterTypeData& aEmitterTypeData) const
{
   if ((mEmitterTypeIdListPtr.Get() != nullptr) && (aIndex < mEmitterTypeIdListPtr.Get()->mEmitterTypeIdList.size()))
   {
      aEmitterTypeData = mEmitterTypeIdListPtr.Get()->mEmitterTypeIdList[aIndex];
   }
   else
   {
      aEmitterTypeData = EmitterTypeData();
   }
}

// =================================================================================================
//! Merge a emitter type list from another track into this track.
//! Duplicates will be omitted.
//! @param aOtherTrack A reference to the other track.
void WsfTrack::MergeEmitterTypeIdLists(const WsfTrack& aOtherTrack)
{
   if ((aOtherTrack.mEmitterTypeIdListPtr.Get() == nullptr) ||
       (aOtherTrack.mEmitterTypeIdListPtr.Get()->mEmitterTypeIdList.empty()))
   {
      return;
   }

   const std::vector<EmitterTypeData>& otherList = aOtherTrack.mEmitterTypeIdListPtr.Get()->mEmitterTypeIdList;
   for (auto& etid : otherList)
   {
      AddEmitterTypeId(etid);
   }
}

// =================================================================================================
//! Set the list of detected emitter types associated with the track.
//! @param aEmitterTypeIdList The list of detected emitter IDs.
void WsfTrack::SetEmitterTypeIdList(const std::vector<EmitterTypeData>& aEmitterTypeIdList)
{
   if (aEmitterTypeIdList.empty())
   {
      delete mEmitterTypeIdListPtr.Get();
      mEmitterTypeIdListPtr.Get() = nullptr;
   }
   else
   {
      // Entries are added one at a time to ensure ascending order and no duplicates.
      if (mEmitterTypeIdListPtr.Get() != nullptr)
      {
         delete mEmitterTypeIdListPtr.Get();
         mEmitterTypeIdListPtr.Get() = nullptr;
      }
      for (auto& etid : aEmitterTypeIdList)
      {
         AddEmitterTypeId(etid);
      }
   }
}

// =================================================================================================
//! Get the residual covariance matrix
const UtMatrixd* WsfTrack::GetResidualCovarianceMatrix() const
{
   return mResidualCovariancePtr.Get();
}

// =================================================================================================
//! Set the residual covariance matrix.
void WsfTrack::SetResidualCovarianceMatrix(const UtMatrixd& aResidualCovarianceMatrix)
{
   if (mResidualCovariancePtr.Get() == nullptr)
   {
      mResidualCovariancePtr.Get() = new UtCovariance(aResidualCovarianceMatrix);
   }
   else
   {
      *(mResidualCovariancePtr.Get()) = aResidualCovarianceMatrix;
   }
}

// =================================================================================================
//! Set the residual state covariance matrix.
void WsfTrack::SetResidualCovariance(const UtCovariance& aResidualCovarianceMatrix)
{
   SetResidualCovarianceMatrix(aResidualCovarianceMatrix);
   mResidualCovariancePtr.SetValid(true);
}

// =================================================================================================
//! Set the residual state covariance matrix.
//! The track instance owns the parameter.
void WsfTrack::SetResidualCovariance(UtCovariance* aResidualCovariancePtr)
{
   if (mResidualCovariancePtr.Get() != nullptr)
   {
      delete mResidualCovariancePtr.Get();
   }
   mResidualCovariancePtr.Get() = aResidualCovariancePtr;
   mResidualCovariancePtr.SetValid(aResidualCovariancePtr != nullptr);
}

//! Is the residual covariance matrix attribute valid?
bool WsfTrack::ResidualCovarianceValid() const
{
   return false;
}

//! Define whether the state covariance matrix attribute is valid.
void WsfTrack::SetResidualCovarianceValid(bool aStateCovarianceValid)
{
   mResidualCovariancePtr.SetValid(aStateCovarianceValid);
}

void WsfTrack::SetTarget(const WsfPlatform& aTarget)
{
   mTargetIndex = aTarget.GetIndex();
   mTargetName  = aTarget.GetNameId();
   mTargetType  = aTarget.GetTypeId();
}

// =================================================================================================
//! Get the platform index of the target.
//!   This index can be 0 if the track is not associated with a target.
size_t WsfTrack::GetTargetIndex() const
{
   // NOTE: GetTargetType also calls this method to populate mTargetType.

   // This is something of a kludge.  A predefined target from an input file may have been given
   // a target name (because we don't have platform indices yet).  The first time we call
   // GetTargetIndex() we'll try to resolve this to a target index.

   if ((mTargetIndex == 0) && (mTargetName != 0))
   {
      if (GetSimulation())
      {
         WsfPlatform* platformPtr = GetSimulation()->GetPlatformByName(mTargetName);
         if (platformPtr != nullptr)
         {
            mTargetIndex = platformPtr->GetIndex();
            mTargetType  = platformPtr->GetTypeId();
         }
      }
   }
   return mTargetIndex;
}

// =================================================================================================
//! Return the string id corresponding with the target platform's type.
WsfStringId WsfTrack::GetTargetType() const
{
   // This can't be a simple inline accessor because of issues with pre-briefed tracks.
   //
   // If the user provided 'platform' command in the input then we want to use the truth type of that
   // platform. If the has never existed then the return value will be an empty string. Once the platform
   // is seen then we'll get the true type.

   if ((mTargetIndex == 0) && (mTargetName != 0))
   {
      GetTargetIndex(); // This will populate mTargetType if the platform exists.
   }
   return mTargetType;
}

// =================================================================================================
//! Assignment operator.
WsfTrack& WsfTrack::operator=(const WsfTrack& aRhs)
{
   if (this != &aRhs)
   {
      CopyMemberData(aRhs, cCC_ASSIGNMENT);
      WsfAuxDataEnabled::operator=(aRhs);
   }
   return *this;
}

// =================================================================================================
bool WsfTrack::ProcessNoiseVariancesValid() const
{
   bool valid = false;
   if (mStateCovariancePtr.Get() != nullptr)
   {
      valid = mStateCovariancePtr.IsValid();
   }
   return valid;
}

// =================================================================================================
void WsfTrack::GetProcessNoiseVariancesECS(double aProcessNoiseVariancesECS[3]) const
{
   if (mStateCovariancePtr.IsValid())
   {
      mStateCovariancePtr.Get()->GetProcessNoiseVariancesECS(aProcessNoiseVariancesECS);
   }
}

// =================================================================================================
void WsfTrack::SetProcessNoiseVariancesECS(double aProcessNoiseVariancesECS[3])
{
   if (mStateCovariancePtr.IsValid())
   {
      mStateCovariancePtr.Get()->SetProcessNoiseVariancesECS(aProcessNoiseVariancesECS);
   }
}

// =================================================================================================
int WsfTrack::GetProcessNoiseModel() const
{
   int model = -1;
   if (mStateCovariancePtr.IsValid())
   {
      return mStateCovariancePtr.Get()->GetProcessNoiseModel();
   }
   return model;
}

// =================================================================================================
double WsfTrack::GetTrackQuality() const
{
   double trackQuality = mTrackQuality.Get();

   if (UseQuantitativeTrackQuality())
   {
      // Get the quantitative track quality;
      trackQuality = GetQuality();
   }

   return trackQuality;
}

// =================================================================================================
double WsfTrack::GetTrackQuality(double aSimTime) const
{
   double trackQuality = mTrackQuality.Get();

   if (UseQuantitativeTrackQuality())
   {
      // Get the quantitative track quality;
      trackQuality = GetQuality(aSimTime);
   }

   return trackQuality;
}

// =================================================================================================
double WsfTrack::GetQuality(double aSimTime) const
{
   double trackQuality = mTrackQuality.Get();

   if (StateCovarianceValid())
   {
      UtCovariance predictedState;
      if (predictedState.ComputePredictedState(aSimTime, *GetStateCovariance(), *this))
      {
         trackQuality = UtMeasurementUtil::GetQuantitativeMeasurementQuality(aSimTime, aSimTime, predictedState);
      }
   }
   else if (MeasurementCovarianceValid())
   {
      trackQuality = mMeasurementCovariancePtr.GetQuality();
   }

   return trackQuality;
}

// =================================================================================================
double WsfTrack::GetQuality() const
{
   double trackQuality = mTrackQuality.Get();

   if (StateCovarianceValid())
   {
      trackQuality = mStateCovariancePtr.GetQuality();
   }
   else if (MeasurementCovarianceValid())
   {
      trackQuality = mMeasurementCovariancePtr.GetQuality();
   }

   return trackQuality;
}

// =================================================================================================
double WsfTrack::GetExpectedLocationError() const
{
   return UtMeasurementUtil::GetExpectedLocationError(GetQuality());
}

// =================================================================================================
double WsfTrack::GetExpectedLocationError(double aSimTime) const
{
   return UtMeasurementUtil::GetExpectedLocationError(GetQuality(aSimTime));
}

// virtual
WsfTrack::History& WsfTrack::GetHistory() const
{
   return mHistory;
}

bool WsfTrack::HasHistory() const
{
   return !mHistory.empty();
}

const char* WsfTrack::GetScriptClassName() const
{
   return "WsfTrack";
}

void WsfTrack::SetSimulation(WsfSimulation* aSimulationPtr)
{
   mSimulationPtr = aSimulationPtr;
}

bool WsfTrack::UseQuantitativeTrackQuality() const
{
   return mSimulationPtr ? mSimulationPtr->GetScenario().UseQuantitativeTrackQuality() : false;
}


WsfTrack_Signal::WsfTrack_Signal()
   : mLowerFrequency(0.0)
   , mUpperFrequency(0.0)
   , mPulseRepetitionInterval(0.0)
   , mPulseWidth(0.0)
{
}

WsfTrack_Signal::WsfTrack_Signal(double aFrequency)
   : mLowerFrequency(aFrequency)
   , mUpperFrequency(aFrequency)
   , mPulseRepetitionInterval(0.0)
   , mPulseWidth(0.0)
{
}

WsfTrack_Signal::WsfTrack_Signal(double aLowerFreq, double aUpperFreq)
   : mLowerFrequency(aLowerFreq)
   , mUpperFrequency(aUpperFreq)
   , mPulseRepetitionInterval(0.0)
   , mPulseWidth(0.0)
{
}

WsfTrack_Signal::WsfTrack_Signal(double aLowerFreq, double aUpperFreq, double aPRI, double aPW)
   : mLowerFrequency(aLowerFreq)
   , mUpperFrequency(aUpperFreq)
   , mPulseRepetitionInterval(aPRI)
   , mPulseWidth(aPW)
{
}

bool WsfTrack_Signal::operator==(const WsfTrack_Signal& aRhs) const
{
   return ((mLowerFrequency == aRhs.mLowerFrequency) && (mUpperFrequency == aRhs.mUpperFrequency) &&
           (mPulseRepetitionInterval == aRhs.mPulseRepetitionInterval) && (mPulseWidth == aRhs.mPulseWidth));
}
