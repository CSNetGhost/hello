# ****************************************************************************
# CUI
#
# The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
#
# The use, dissemination or disclosure of data in this file is subject to
# limitation or restriction. See accompanying README and LICENSE for details.
# ****************************************************************************
# Behavior assumes it is attached to a behavior tree on a WSF_QUANTUM_TASKER_PROCESSOR

behavior debug_quantum_tasker

   script_variables
      string mDashedLine = "-";
      string mHeaderRow  = "                            Task,        Priority, ";
      string mAssetRow   = "                                                   ";
      Array<WsfQuantumTask> mTasks;
      Array<WsfAssetPerception> mAssets;
      Array<Array<double>> mValues;      
   end_script_variables
   
   script void MakeDashedLine()
      while (mDashedLine.Length() < mHeaderRow.Length())
      {
         mDashedLine = mDashedLine + "-";
      }   
   end_script
   
   script void MakeAssetRow()
      foreach(WsfAssetPerception a in mAssets)
      {
         string assetName = a.Name() + ":" + (string)a.Index();
         while (assetName.Length() < 16)
         {
            assetName = " " + assetName;
         }
         if (assetName.Length() > 16)
         {
            assetName = assetName.Substring(-16);
         }
         mHeaderRow = mHeaderRow + assetName + ", "; // each column is 18 spaces wide
         
         string assetSystem;
         if(a.SystemCount() == 1)
         {
            assetSystem = a.SystemName(0);
         }
         else
         {
            assetSystem = write_str("#_sys=", a.SystemCount());
         }
         while (assetSystem.Length() < 16)
         {
            assetSystem = " " + assetSystem;
         }
         if (assetSystem.Length() > 16)
         {
            assetSystem = assetSystem.Substring(-16);
         }
         mAssetRow = mAssetRow + assetSystem + ", "; // each column is 18 spaces wide
      }      
      mHeaderRow = mHeaderRow + "          winner";
   end_script
   
   script void WriteTaskRow(int i, WsfQuantumTask aTask)
   
      // Task = <task_type>:<target_name>
      string taskDesc;
      WsfTrack temp = PLATFORM.MasterTrackList().Find(aTask.TrackId());
      if (temp.IsValid())
      {
         taskDesc = write_str(aTask.TaskType(), ":", temp.TargetName());
      }
      else
      {
         taskDesc = write_str(aTask.TaskType(), ":", aTask.TrackId().ToString());
      }
      while (taskDesc.Length() < 32)
      {
         taskDesc = " " + taskDesc;
      }
      if (taskDesc.Length() > 32)
      {
         taskDesc = taskDesc.Substring(-32);
      }
      string row = taskDesc + " ";   // this should be 33 spaces, at this point
      
      // Priority
      string pString = (string)aTask.Priority();
      while( pString.Contains(".") && pString.Substring(-1)=="0")   // take off all trailing zeros
      {
         pString = pString.Substring(0,-1);
      }
      if (pString.Length() > 16)
      {
         pString = pString.Substring(0,15);
      }
      pString = pString + ", ";
      while (pString.Length() < 18)
      {
         pString = " " + pString;
      }
      row = row + pString;
      
      // Value for each asset
      for(int j = 0; j < mAssets.Size(); j += 1)
      {
         WsfAssetPerception p = mAssets.Get(j);
         double value = mValues.Get(i).Get(j);
         
         string valStr = (string)value;

         while( valStr.Contains(".") && valStr.Substring(-1)=="0")   #take off all trailing zeros
         {
            valStr = valStr.Substring(0,-1);
         }
         if (valStr.Length() > 16)
         {
            valStr = valStr.Substring(0,15);
         }
         valStr = valStr + ", ";
         while (valStr.Length() < 18)
         {
            valStr = " " + valStr;
         }
         row = row + valStr;
      }
     
      // TODO get task "winners"
      Array<WsfAssetPerception> assignees = ((WsfQuantumTaskerProcessor)PROCESSOR).AssetAssigneesFor(aTask);
      string winner;
      if (assignees.Empty())
      {
         winner = "-";
      }
      else if (assignees.Size() > 1)
      {
         //winner = (string)assignees.Size() + " winners";
         winner = "[";
         for (int idx = 0; idx < assignees.Size(); idx += 1)
         {
            if (idx > 0) winner += ",";         
            winner += (string)assignees[idx].Index();
         }
         winner += "]";
      }
      else  // Have just one asset; provide details
      {
         WsfAssetPerception asset = assignees[0];
         if(asset.SystemCount() == 1)
         {
            winner = write_str(asset.Name(),":", asset.SystemName(0));
         }
         else
         {
            winner = write_str(asset.Name(),":#_sys=", asset.SystemCount());
         }
      }
      while (winner.Length() < 16)
      {
         winner = " " + winner;
      }
      if (winner.Length() > 16)
      {
         winner = winner.Substring(-16);
      }
      row = row + winner;
      writeln(row);   
   end_script      

   precondition
      if (!PROCESSOR.IsA_TypeOf("WSF_QUANTUM_TASKER_PROCESSOR"))
      {
         return Failure("behavior not used by a QUANTUM TASKER processor!");
      }
      
      Array<WsfQuantumTask> tasks = ((WsfQuantumTaskerProcessor)PROCESSOR).TasksConsidered();
      Array<WsfAssetPerception> assets = ((WsfQuantumTaskerProcessor)PROCESSOR).AssetsConsidered();

      writeln_d("T=", TIME_NOW, " behavior precondition: debug_quantum_tasker;",
                " tasks (", tasks.Size(), ") assets (", assets.Size(), ")");
      
      if (tasks.Size() > 0 && assets.Size() > 0)
      {
         return true;
      }
      else
      {
         return Failure("Zero tasks or zero assets!");
      }
   end_precondition

   execute
      
      // Get the decision matrix information
      mTasks = ((WsfQuantumTaskerProcessor)PROCESSOR).TasksConsidered();
      mAssets = ((WsfQuantumTaskerProcessor)PROCESSOR).AssetsConsidered();
      mValues = ((WsfQuantumTaskerProcessor)PROCESSOR).ValuesConsidered();
          
      // Assets  
      // Write top row (asset names) and 2nd row (asset system)
      MakeAssetRow();
      MakeDashedLine();   // make this second as it is sized based on the number of assets
            
      // Write out the header and assets just created      
      writeln(mDashedLine);
      writeln(PLATFORM.Name(), ", T=", TIME_NOW, ", Executing debug_quantum_tasker");
      writeln(mDashedLine);
      writeln(mHeaderRow);
      writeln(mAssetRow);
      
      // Tasks
      // Write all columns of each row now
      for(int i = 0; i < mTasks.Size(); i += 1)
      {
         WriteTaskRow(i, mTasks.Get(i));
      }

      // Footer
      writeln(mDashedLine);      
      writeln("");
   end_execute
end_behavior
