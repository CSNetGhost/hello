# Warning: This grammar file was auto-generated by the generate_grammar.py script.
# Do not edit this file.
# To edit the grammar, use the template files wsf_multiresolution/grammar/*_template.ag and re-run generate_grammar.py

############### Comm
(struct root
   (var ObjectMap/MultiresolutionComm multiresolutionCommType)

   (rule multiresolution-comm-type {
      multiresolution_comm <string> <string> (new (type multiresolutionCommType $1) (type multiresolutionCommType $2) :backup (type multiresolutionCommType WSF_MULTIRESOLUTION_COMM) ) [apply($$)]
         <TypeCommand>*
      end_multiresolution_comm 
    | (error { multiresolution_comm <ignore>* end_multiresolution_comm } )
   })
{
   <multiresolution-comm-type>
})
(struct Platform
   (var ObjectMap/MultiresolutionComm multiresolutionComms)

   (rule type-command {
      multiresolution_comm <string> <string> (new (subtype multiresolutionComms $1) (type multiresolutionCommType $2) :backup (type multiresolutionCommType WSF_MULTIRESOLUTION_COMM)) [apply($$)]
         <TypeCommand>*
      end_multiresolution_comm
    })

   (rule instance-command {
      multiresolution_comm <string> (load (subtype multiresolutionComms $1)) [apply($$)] <TypeCommand>* end_multiresolution_comm
   })
{
   add multiresolution_comm <string> <string> (new (subtype multiresolutionComms $2) (type multiresolutionCommType $3) :backup (type multiresolutionCommType WSF_MULTIRESOLUTION_COMM)) [apply($$)]
      <TypeCommand>*
   end_multiresolution_comm
 | edit multiresolution_comm <string> (load (subtype multiresolutionComms $2)) [apply($$)]
      <TypeCommand>*
   end_multiresolution_comm
 | delete multiresolution_comm <string> (delete (subtype multiresolutionComms $2)) [apply($$)]
})
(struct MultiresolutionComm

   (struct CommModel
      :symbol (type modelType MULTIRESOLUTION_COMM_MODEL)
   {
        default 
      | fidelity_range <real> <real>
      | comm (typeref commType) (new_replace (subtype comm) (type commType $1)) <TypeCommand>* end_comm 
      | comm (load (subtype comm)) <TypeCommand>* end_comm
   })

   (var ObjectMap/CommModel modelTypes)
   (var CommModel commonType)

   (rule new-model
   {
      (new_replace (subtype modelTypes commonType) (type modelType MULTIRESOLUTION_COMM_MODEL)) [apply($$)]
         <CommModel>*
      end_model
   })
{
   fidelity <real>
 | model (typeref modelTypes) (load (subtype modelTypes $1)) [apply($$)] <CommModel>* end_model # Implicit edit
 | model <string> <new-model> (new (subtype modelTypes $1) (subtype modelTypes commonType)) # Implicit add
 | add model <string> <new-model> (new (subtype modelTypes $2) (subtype modelTypes commonType))
 | edit model (typeref modelTypes) (load (subtype modelTypes $2)) [apply($$)] <CommModel>* end_model
 | common (load (subtype modelTypes commonType comm)) <TypeCommand>* end_common # Just check w/ last loaded type
 | <wsfobject-command>
})

(struct WSF_MULTIRESOLUTION_COMM
   :symbol (type multiresolutionCommType WSF_MULTIRESOLUTION_COMM)
   :base_type MultiresolutionComm
{
   <MultiresolutionComm>
})
############### Fuel
(struct root
   (var ObjectMap/MultiresolutionFuel multiresolutionFuelType)

   (rule multiresolution-fuel-type {
      multiresolution_fuel <string> <string> (new (type multiresolutionFuelType $1) (type multiresolutionFuelType $2) :backup (type multiresolutionFuelType WSF_MULTIRESOLUTION_FUEL) ) [apply($$)]
         <TypeCommand>*
      end_multiresolution_fuel 
    | (error { multiresolution_fuel <ignore>* end_multiresolution_fuel } )
   })
{
   <multiresolution-fuel-type>
})
(struct Platform
   (var ObjectMap/MultiresolutionFuel multiresolutionFuels)

   (rule type-command {
      multiresolution_fuel <string> (new (subtype multiresolutionFuels multiresolutionFuel) (type multiresolutionFuelType $1) :backup (type multiresolutionFuelType WSF_MULTIRESOLUTION_FUEL)) [apply($$)]
         <TypeCommand>*
      end_multiresolution_fuel
    })

   (rule instance-command {
      multiresolution_fuel (load (subtype multiresolutionFuels multiresolutionFuel)) [apply($$)] <TypeCommand>* end_multiresolution_fuel
   })
{
   add multiresolution_fuel <string> (new (subtype multiresolutionFuels multiresolutionFuel) (type multiresolutionFuelType $2) :backup (type multiresolutionFuelType WSF_MULTIRESOLUTION_FUEL)) [apply($$)]
      <TypeCommand>*
   end_multiresolution_fuel
 | edit multiresolution_fuel (load (subtype multiresolutionFuels multiresolutionFuel)) [apply($$)]
      <TypeCommand>*
   end_multiresolution_fuel
 | delete multiresolution_fuel (delete (subtype multiresolutionFuels multiresolutionFuel)) [apply($$)]
})
(struct MultiresolutionFuel

   (struct FuelModel
      :symbol (type modelType MULTIRESOLUTION_FUEL_MODEL)
   {
        default 
      | fidelity_range <real> <real>
      | fuel (typeref fuelType) (new_replace (subtype fuel) (type fuelType $1)) <TypeCommand>* end_fuel 
      | fuel (load (subtype fuel)) <TypeCommand>* end_fuel
   })

   (var ObjectMap/FuelModel modelTypes)
   (var FuelModel commonType)

   (rule new-model
   {
      (new_replace (subtype modelTypes commonType) (type modelType MULTIRESOLUTION_FUEL_MODEL)) [apply($$)]
         <FuelModel>*
      end_model
   })
{
   fidelity <real>
 | model (typeref modelTypes) (load (subtype modelTypes $1)) [apply($$)] <FuelModel>* end_model # Implicit edit
 | model <string> <new-model> (new (subtype modelTypes $1) (subtype modelTypes commonType)) # Implicit add
 | add model <string> <new-model> (new (subtype modelTypes $2) (subtype modelTypes commonType))
 | edit model (typeref modelTypes) (load (subtype modelTypes $2)) [apply($$)] <FuelModel>* end_model
 | common (load (subtype modelTypes commonType fuel)) <TypeCommand>* end_common # Just check w/ last loaded type
 | <wsfobject-command>
})

(struct WSF_MULTIRESOLUTION_FUEL
   :symbol (type multiresolutionFuelType WSF_MULTIRESOLUTION_FUEL)
   :base_type MultiresolutionFuel
{
   <MultiresolutionFuel>
})
############### Mover
(struct root
   (var ObjectMap/MultiresolutionMover multiresolutionMoverType)

   (rule multiresolution-mover-type {
      multiresolution_mover <string> <string> (new (type multiresolutionMoverType $1) (type multiresolutionMoverType $2) :backup (type multiresolutionMoverType WSF_MULTIRESOLUTION_MOVER) ) [apply($$)]
         <TypeCommand>*
      end_multiresolution_mover 
    | (error { multiresolution_mover <ignore>* end_multiresolution_mover } )
   })
{
   <multiresolution-mover-type>
})
(struct Platform
   (var ObjectMap/MultiresolutionMover multiresolutionMovers)

   (rule type-command {
      multiresolution_mover <string> (new (subtype multiresolutionMovers multiresolutionMover) (type multiresolutionMoverType $1) :backup (type multiresolutionMoverType WSF_MULTIRESOLUTION_MOVER)) [apply($$)]
         <TypeCommand>*
      end_multiresolution_mover
    })

   (rule instance-command {
      multiresolution_mover (load (subtype multiresolutionMovers multiresolutionMover)) [apply($$)] <TypeCommand>* end_multiresolution_mover
   })
{
   add multiresolution_mover <string> (new (subtype multiresolutionMovers multiresolutionMover) (type multiresolutionMoverType $2) :backup (type multiresolutionMoverType WSF_MULTIRESOLUTION_MOVER)) [apply($$)]
      <TypeCommand>*
   end_multiresolution_mover
 | edit multiresolution_mover (load (subtype multiresolutionMovers multiresolutionMover)) [apply($$)]
      <TypeCommand>*
   end_multiresolution_mover
 | delete multiresolution_mover (delete (subtype multiresolutionMovers multiresolutionMover)) [apply($$)]
})
(struct MultiresolutionMover

   (struct MoverModel
      :symbol (type modelType MULTIRESOLUTION_MOVER_MODEL)
   {
        default 
      | fidelity_range <real> <real>
      | mover (typeref moverType) (new_replace (subtype mover) (type moverType $1)) <TypeCommand>* end_mover 
      | mover (load (subtype mover)) <TypeCommand>* end_mover
   })

   (var ObjectMap/MoverModel modelTypes)
   (var MoverModel commonType)

   (rule new-model
   {
      (new_replace (subtype modelTypes commonType) (type modelType MULTIRESOLUTION_MOVER_MODEL)) [apply($$)]
         <MoverModel>*
      end_model
   })
{
   fidelity <real>
 | model (typeref modelTypes) (load (subtype modelTypes $1)) [apply($$)] <MoverModel>* end_model # Implicit edit
 | model <string> <new-model> (new (subtype modelTypes $1) (subtype modelTypes commonType)) # Implicit add
 | add model <string> <new-model> (new (subtype modelTypes $2) (subtype modelTypes commonType))
 | edit model (typeref modelTypes) (load (subtype modelTypes $2)) [apply($$)] <MoverModel>* end_model
 | common (load (subtype modelTypes commonType mover)) <TypeCommand>* end_common # Just check w/ last loaded type
 | <wsfobject-command>
})

(struct WSF_MULTIRESOLUTION_MOVER
   :symbol (type multiresolutionMoverType WSF_MULTIRESOLUTION_MOVER)
   :base_type MultiresolutionMover
{
   <MultiresolutionMover>
})
############### Processor
(struct root
   (var ObjectMap/MultiresolutionProcessor multiresolutionProcessorType)

   (rule multiresolution-processor-type {
      multiresolution_processor <string> <string> (new (type multiresolutionProcessorType $1) (type multiresolutionProcessorType $2) :backup (type multiresolutionProcessorType WSF_MULTIRESOLUTION_PROCESSOR) ) [apply($$)]
         <TypeCommand>*
      end_multiresolution_processor 
    | (error { multiresolution_processor <ignore>* end_multiresolution_processor } )
   })
{
   <multiresolution-processor-type>
})
(struct Platform
   (var ObjectMap/MultiresolutionProcessor multiresolutionProcessors)

   (rule type-command {
      multiresolution_processor <string> <string> (new (subtype multiresolutionProcessors $1) (type multiresolutionProcessorType $2) :backup (type multiresolutionProcessorType WSF_MULTIRESOLUTION_PROCESSOR)) [apply($$)]
         <TypeCommand>*
      end_multiresolution_processor
    })

   (rule instance-command {
      multiresolution_processor <string> (load (subtype multiresolutionProcessors $1)) [apply($$)] <TypeCommand>* end_multiresolution_processor
   })
{
   add multiresolution_processor <string> <string> (new (subtype multiresolutionProcessors $2) (type multiresolutionProcessorType $3) :backup (type multiresolutionProcessorType WSF_MULTIRESOLUTION_PROCESSOR)) [apply($$)]
      <TypeCommand>*
   end_multiresolution_processor
 | edit multiresolution_processor <string> (load (subtype multiresolutionProcessors $2)) [apply($$)]
      <TypeCommand>*
   end_multiresolution_processor
 | delete multiresolution_processor <string> (delete (subtype multiresolutionProcessors $2)) [apply($$)]
})
(struct MultiresolutionProcessor

   (struct ProcessorModel
      :symbol (type modelType MULTIRESOLUTION_PROCESSOR_MODEL)
   {
        default 
      | fidelity_range <real> <real>
      | processor (typeref processorType) (new_replace (subtype processor) (type processorType $1)) <TypeCommand>* end_processor 
      | processor (load (subtype processor)) <TypeCommand>* end_processor
   })

   (var ObjectMap/ProcessorModel modelTypes)
   (var ProcessorModel commonType)

   (rule new-model
   {
      (new_replace (subtype modelTypes commonType) (type modelType MULTIRESOLUTION_PROCESSOR_MODEL)) [apply($$)]
         <ProcessorModel>*
      end_model
   })
{
   fidelity <real>
 | model (typeref modelTypes) (load (subtype modelTypes $1)) [apply($$)] <ProcessorModel>* end_model # Implicit edit
 | model <string> <new-model> (new (subtype modelTypes $1) (subtype modelTypes commonType)) # Implicit add
 | add model <string> <new-model> (new (subtype modelTypes $2) (subtype modelTypes commonType))
 | edit model (typeref modelTypes) (load (subtype modelTypes $2)) [apply($$)] <ProcessorModel>* end_model
 | common (load (subtype modelTypes commonType processor)) <TypeCommand>* end_common # Just check w/ last loaded type
 | <wsfobject-command>
})

(struct WSF_MULTIRESOLUTION_PROCESSOR
   :symbol (type multiresolutionProcessorType WSF_MULTIRESOLUTION_PROCESSOR)
   :base_type MultiresolutionProcessor
{
   <MultiresolutionProcessor>
})
############### Sensor
(struct root
   (var ObjectMap/MultiresolutionSensor multiresolutionSensorType)

   (rule multiresolution-sensor-type {
      multiresolution_sensor <string> <string> (new (type multiresolutionSensorType $1) (type multiresolutionSensorType $2) :backup (type multiresolutionSensorType WSF_MULTIRESOLUTION_SENSOR) ) [apply($$)]
         <TypeCommand>*
      end_multiresolution_sensor 
    | (error { multiresolution_sensor <ignore>* end_multiresolution_sensor } )
   })
{
   <multiresolution-sensor-type>
})
(struct Platform
   (var ObjectMap/MultiresolutionSensor multiresolutionSensors)

   (rule type-command {
      multiresolution_sensor <string> <string> (new (subtype multiresolutionSensors $1) (type multiresolutionSensorType $2) :backup (type multiresolutionSensorType WSF_MULTIRESOLUTION_SENSOR)) [apply($$)]
         <TypeCommand>*
      end_multiresolution_sensor
    })

   (rule instance-command {
      multiresolution_sensor <string> (load (subtype multiresolutionSensors $1)) [apply($$)] <TypeCommand>* end_multiresolution_sensor
   })
{
   add multiresolution_sensor <string> <string> (new (subtype multiresolutionSensors $2) (type multiresolutionSensorType $3) :backup (type multiresolutionSensorType WSF_MULTIRESOLUTION_SENSOR)) [apply($$)]
      <TypeCommand>*
   end_multiresolution_sensor
 | edit multiresolution_sensor <string> (load (subtype multiresolutionSensors $2)) [apply($$)]
      <TypeCommand>*
   end_multiresolution_sensor
 | delete multiresolution_sensor <string> (delete (subtype multiresolutionSensors $2)) [apply($$)]
})
(struct MultiresolutionSensor

   (struct SensorModel
      :symbol (type modelType MULTIRESOLUTION_SENSOR_MODEL)
   {
        default 
      | fidelity_range <real> <real>
      | sensor (typeref sensorType) (new_replace (subtype sensor) (type sensorType $1)) <TypeCommand>* end_sensor 
      | sensor (load (subtype sensor)) <TypeCommand>* end_sensor
   })

   (var ObjectMap/SensorModel modelTypes)
   (var SensorModel commonType)

   (rule new-model
   {
      (new_replace (subtype modelTypes commonType) (type modelType MULTIRESOLUTION_SENSOR_MODEL)) [apply($$)]
         <SensorModel>*
      end_model
   })
{
   fidelity <real>
 | model (typeref modelTypes) (load (subtype modelTypes $1)) [apply($$)] <SensorModel>* end_model # Implicit edit
 | model <string> <new-model> (new (subtype modelTypes $1) (subtype modelTypes commonType)) # Implicit add
 | add model <string> <new-model> (new (subtype modelTypes $2) (subtype modelTypes commonType))
 | edit model (typeref modelTypes) (load (subtype modelTypes $2)) [apply($$)] <SensorModel>* end_model
 | common (load (subtype modelTypes commonType sensor)) <TypeCommand>* end_common # Just check w/ last loaded type
 | <wsfobject-command>
})

(struct WSF_MULTIRESOLUTION_SENSOR
   :symbol (type multiresolutionSensorType WSF_MULTIRESOLUTION_SENSOR)
   :base_type MultiresolutionSensor
{
   <MultiresolutionSensor>
})
############### AcousticSignature
(struct root
   (var ObjectMap/MultiresolutionAcousticSignature multiresolutionAcousticSignatureType)

   (rule multiresolution-acoustic_signature-type {
      multiresolution_acoustic_signature <string> <string> (new (type multiresolutionAcousticSignatureType $1) (type multiresolutionAcousticSignatureType $2) :backup (type multiresolutionAcousticSignatureType WSF_MULTIRESOLUTION_ACOUSTIC_SIGNATURE) ) [apply($$)]
         <TypeCommand>*
      end_multiresolution_acoustic_signature 
    | (error { multiresolution_acoustic_signature <ignore>* end_multiresolution_acoustic_signature } )
   })
{
   <multiresolution-acoustic_signature-type>
})
(struct Platform
   (var ObjectMap/MultiresolutionAcousticSignature multiresolutionAcousticSignatures)

   (rule type-command {
      multiresolution_acoustic_signature <string> (new (subtype multiresolutionAcousticSignatures multiresolutionAcousticSignature) (type multiresolutionAcousticSignatureType $1) :backup (type multiresolutionAcousticSignatureType WSF_MULTIRESOLUTION_ACOUSTIC_SIGNATURE)) [apply($$)]
         <TypeCommand>*
      end_multiresolution_acoustic_signature
    })

   (rule instance-command {
      multiresolution_acoustic_signature (load (subtype multiresolutionAcousticSignatures multiresolutionAcousticSignature)) [apply($$)] <TypeCommand>* end_multiresolution_acoustic_signature
   })
{
   add multiresolution_acoustic_signature <string> (new (subtype multiresolutionAcousticSignatures multiresolutionAcousticSignature) (type multiresolutionAcousticSignatureType $2) :backup (type multiresolutionAcousticSignatureType WSF_MULTIRESOLUTION_ACOUSTIC_SIGNATURE)) [apply($$)]
      <TypeCommand>*
   end_multiresolution_acoustic_signature
 | edit multiresolution_acoustic_signature (load (subtype multiresolutionAcousticSignatures multiresolutionAcousticSignature)) [apply($$)]
      <TypeCommand>*
   end_multiresolution_acoustic_signature
 | delete multiresolution_acoustic_signature (delete (subtype multiresolutionAcousticSignatures multiresolutionAcousticSignature)) [apply($$)]
})
(struct MultiresolutionAcousticSignature

   (struct AcousticSignatureModel
      :symbol (type modelType MULTIRESOLUTION_ACOUSTIC_SIGNATURE_MODEL)
   {
        default 
      | fidelity_range <real> <real>
      | acoustic_signature (typeref acousticSignature) (new_replace (subtype acoustic_signature) (type acousticSignature $1)) <TypeCommand>* end_acoustic_signature 
      | acoustic_signature (load (subtype acoustic_signature)) <TypeCommand>* end_acoustic_signature
   })

   (var ObjectMap/AcousticSignatureModel modelTypes)
   (var AcousticSignatureModel commonType)

   (rule new-model
   {
      (new_replace (subtype modelTypes commonType) (type modelType MULTIRESOLUTION_ACOUSTIC_SIGNATURE_MODEL)) [apply($$)]
         <AcousticSignatureModel>*
      end_model
   })
{
   fidelity <real>
 | model (typeref modelTypes) (load (subtype modelTypes $1)) [apply($$)] <AcousticSignatureModel>* end_model # Implicit edit
 | model <string> <new-model> (new (subtype modelTypes $1) (subtype modelTypes commonType)) # Implicit add
 | add model <string> <new-model> (new (subtype modelTypes $2) (subtype modelTypes commonType))
 | edit model (typeref modelTypes) (load (subtype modelTypes $2)) [apply($$)] <AcousticSignatureModel>* end_model
 | common (load (subtype modelTypes commonType acoustic_signature)) <TypeCommand>* end_common # Just check w/ last loaded type
 | <wsfobject-command>
})

(struct WSF_MULTIRESOLUTION_ACOUSTIC_SIGNATURE
   :symbol (type multiresolutionAcousticSignatureType WSF_MULTIRESOLUTION_ACOUSTIC_SIGNATURE)
   :base_type MultiresolutionAcousticSignature
{
   <MultiresolutionAcousticSignature>
})
############### InfraredSignature
(struct root
   (var ObjectMap/MultiresolutionInfraredSignature multiresolutionInfraredSignatureType)

   (rule multiresolution-infrared_signature-type {
      multiresolution_infrared_signature <string> <string> (new (type multiresolutionInfraredSignatureType $1) (type multiresolutionInfraredSignatureType $2) :backup (type multiresolutionInfraredSignatureType WSF_MULTIRESOLUTION_INFRARED_SIGNATURE) ) [apply($$)]
         <TypeCommand>*
      end_multiresolution_infrared_signature 
    | (error { multiresolution_infrared_signature <ignore>* end_multiresolution_infrared_signature } )
   })
{
   <multiresolution-infrared_signature-type>
})
(struct Platform
   (var ObjectMap/MultiresolutionInfraredSignature multiresolutionInfraredSignatures)

   (rule type-command {
      multiresolution_infrared_signature <string> (new (subtype multiresolutionInfraredSignatures multiresolutionInfraredSignature) (type multiresolutionInfraredSignatureType $1) :backup (type multiresolutionInfraredSignatureType WSF_MULTIRESOLUTION_INFRARED_SIGNATURE)) [apply($$)]
         <TypeCommand>*
      end_multiresolution_infrared_signature
    })

   (rule instance-command {
      multiresolution_infrared_signature (load (subtype multiresolutionInfraredSignatures multiresolutionInfraredSignature)) [apply($$)] <TypeCommand>* end_multiresolution_infrared_signature
   })
{
   add multiresolution_infrared_signature <string> (new (subtype multiresolutionInfraredSignatures multiresolutionInfraredSignature) (type multiresolutionInfraredSignatureType $2) :backup (type multiresolutionInfraredSignatureType WSF_MULTIRESOLUTION_INFRARED_SIGNATURE)) [apply($$)]
      <TypeCommand>*
   end_multiresolution_infrared_signature
 | edit multiresolution_infrared_signature (load (subtype multiresolutionInfraredSignatures multiresolutionInfraredSignature)) [apply($$)]
      <TypeCommand>*
   end_multiresolution_infrared_signature
 | delete multiresolution_infrared_signature (delete (subtype multiresolutionInfraredSignatures multiresolutionInfraredSignature)) [apply($$)]
})
(struct MultiresolutionInfraredSignature

   (struct InfraredSignatureModel
      :symbol (type modelType MULTIRESOLUTION_INFRARED_SIGNATURE_MODEL)
   {
        default 
      | fidelity_range <real> <real>
      | infrared_signature (typeref infraredSignature) (new_replace (subtype infrared_signature) (type infraredSignature $1)) <TypeCommand>* end_infrared_signature 
      | infrared_signature (load (subtype infrared_signature)) <TypeCommand>* end_infrared_signature
   })

   (var ObjectMap/InfraredSignatureModel modelTypes)
   (var InfraredSignatureModel commonType)

   (rule new-model
   {
      (new_replace (subtype modelTypes commonType) (type modelType MULTIRESOLUTION_INFRARED_SIGNATURE_MODEL)) [apply($$)]
         <InfraredSignatureModel>*
      end_model
   })
{
   fidelity <real>
 | model (typeref modelTypes) (load (subtype modelTypes $1)) [apply($$)] <InfraredSignatureModel>* end_model # Implicit edit
 | model <string> <new-model> (new (subtype modelTypes $1) (subtype modelTypes commonType)) # Implicit add
 | add model <string> <new-model> (new (subtype modelTypes $2) (subtype modelTypes commonType))
 | edit model (typeref modelTypes) (load (subtype modelTypes $2)) [apply($$)] <InfraredSignatureModel>* end_model
 | common (load (subtype modelTypes commonType infrared_signature)) <TypeCommand>* end_common # Just check w/ last loaded type
 | <wsfobject-command>
})

(struct WSF_MULTIRESOLUTION_INFRARED_SIGNATURE
   :symbol (type multiresolutionInfraredSignatureType WSF_MULTIRESOLUTION_INFRARED_SIGNATURE)
   :base_type MultiresolutionInfraredSignature
{
   <MultiresolutionInfraredSignature>
})
############### OpticalSignature
(struct root
   (var ObjectMap/MultiresolutionOpticalSignature multiresolutionOpticalSignatureType)

   (rule multiresolution-optical_signature-type {
      multiresolution_optical_signature <string> <string> (new (type multiresolutionOpticalSignatureType $1) (type multiresolutionOpticalSignatureType $2) :backup (type multiresolutionOpticalSignatureType WSF_MULTIRESOLUTION_OPTICAL_SIGNATURE) ) [apply($$)]
         <TypeCommand>*
      end_multiresolution_optical_signature 
    | (error { multiresolution_optical_signature <ignore>* end_multiresolution_optical_signature } )
   })
{
   <multiresolution-optical_signature-type>
})
(struct Platform
   (var ObjectMap/MultiresolutionOpticalSignature multiresolutionOpticalSignatures)

   (rule type-command {
      multiresolution_optical_signature <string> (new (subtype multiresolutionOpticalSignatures multiresolutionOpticalSignature) (type multiresolutionOpticalSignatureType $1) :backup (type multiresolutionOpticalSignatureType WSF_MULTIRESOLUTION_OPTICAL_SIGNATURE)) [apply($$)]
         <TypeCommand>*
      end_multiresolution_optical_signature
    })

   (rule instance-command {
      multiresolution_optical_signature (load (subtype multiresolutionOpticalSignatures multiresolutionOpticalSignature)) [apply($$)] <TypeCommand>* end_multiresolution_optical_signature
   })
{
   add multiresolution_optical_signature <string> (new (subtype multiresolutionOpticalSignatures multiresolutionOpticalSignature) (type multiresolutionOpticalSignatureType $2) :backup (type multiresolutionOpticalSignatureType WSF_MULTIRESOLUTION_OPTICAL_SIGNATURE)) [apply($$)]
      <TypeCommand>*
   end_multiresolution_optical_signature
 | edit multiresolution_optical_signature (load (subtype multiresolutionOpticalSignatures multiresolutionOpticalSignature)) [apply($$)]
      <TypeCommand>*
   end_multiresolution_optical_signature
 | delete multiresolution_optical_signature (delete (subtype multiresolutionOpticalSignatures multiresolutionOpticalSignature)) [apply($$)]
})
(struct MultiresolutionOpticalSignature

   (struct OpticalSignatureModel
      :symbol (type modelType MULTIRESOLUTION_OPTICAL_SIGNATURE_MODEL)
   {
        default 
      | fidelity_range <real> <real>
      | optical_signature (typeref opticalSignature) (new_replace (subtype optical_signature) (type opticalSignature $1)) <TypeCommand>* end_optical_signature 
      | optical_signature (load (subtype optical_signature)) <TypeCommand>* end_optical_signature
   })

   (var ObjectMap/OpticalSignatureModel modelTypes)
   (var OpticalSignatureModel commonType)

   (rule new-model
   {
      (new_replace (subtype modelTypes commonType) (type modelType MULTIRESOLUTION_OPTICAL_SIGNATURE_MODEL)) [apply($$)]
         <OpticalSignatureModel>*
      end_model
   })
{
   fidelity <real>
 | model (typeref modelTypes) (load (subtype modelTypes $1)) [apply($$)] <OpticalSignatureModel>* end_model # Implicit edit
 | model <string> <new-model> (new (subtype modelTypes $1) (subtype modelTypes commonType)) # Implicit add
 | add model <string> <new-model> (new (subtype modelTypes $2) (subtype modelTypes commonType))
 | edit model (typeref modelTypes) (load (subtype modelTypes $2)) [apply($$)] <OpticalSignatureModel>* end_model
 | common (load (subtype modelTypes commonType optical_signature)) <TypeCommand>* end_common # Just check w/ last loaded type
 | <wsfobject-command>
})

(struct WSF_MULTIRESOLUTION_OPTICAL_SIGNATURE
   :symbol (type multiresolutionOpticalSignatureType WSF_MULTIRESOLUTION_OPTICAL_SIGNATURE)
   :base_type MultiresolutionOpticalSignature
{
   <MultiresolutionOpticalSignature>
})
############### RadarSignature
(struct root
   (var ObjectMap/MultiresolutionRadarSignature multiresolutionRadarSignatureType)

   (rule multiresolution-radar_signature-type {
      multiresolution_radar_signature <string> <string> (new (type multiresolutionRadarSignatureType $1) (type multiresolutionRadarSignatureType $2) :backup (type multiresolutionRadarSignatureType WSF_MULTIRESOLUTION_RADAR_SIGNATURE) ) [apply($$)]
         <TypeCommand>*
      end_multiresolution_radar_signature 
    | (error { multiresolution_radar_signature <ignore>* end_multiresolution_radar_signature } )
   })
{
   <multiresolution-radar_signature-type>
})
(struct Platform
   (var ObjectMap/MultiresolutionRadarSignature multiresolutionRadarSignatures)

   (rule type-command {
      multiresolution_radar_signature <string> (new (subtype multiresolutionRadarSignatures multiresolutionRadarSignature) (type multiresolutionRadarSignatureType $1) :backup (type multiresolutionRadarSignatureType WSF_MULTIRESOLUTION_RADAR_SIGNATURE)) [apply($$)]
         <TypeCommand>*
      end_multiresolution_radar_signature
    })

   (rule instance-command {
      multiresolution_radar_signature (load (subtype multiresolutionRadarSignatures multiresolutionRadarSignature)) [apply($$)] <TypeCommand>* end_multiresolution_radar_signature
   })
{
   add multiresolution_radar_signature <string> (new (subtype multiresolutionRadarSignatures multiresolutionRadarSignature) (type multiresolutionRadarSignatureType $2) :backup (type multiresolutionRadarSignatureType WSF_MULTIRESOLUTION_RADAR_SIGNATURE)) [apply($$)]
      <TypeCommand>*
   end_multiresolution_radar_signature
 | edit multiresolution_radar_signature (load (subtype multiresolutionRadarSignatures multiresolutionRadarSignature)) [apply($$)]
      <TypeCommand>*
   end_multiresolution_radar_signature
 | delete multiresolution_radar_signature (delete (subtype multiresolutionRadarSignatures multiresolutionRadarSignature)) [apply($$)]
})
(struct MultiresolutionRadarSignature

   (struct RadarSignatureModel
      :symbol (type modelType MULTIRESOLUTION_RADAR_SIGNATURE_MODEL)
   {
        default 
      | fidelity_range <real> <real>
      | radar_signature (typeref radarSignature) (new_replace (subtype radar_signature) (type radarSignature $1)) <TypeCommand>* end_radar_signature 
      | radar_signature (load (subtype radar_signature)) <TypeCommand>* end_radar_signature
   })

   (var ObjectMap/RadarSignatureModel modelTypes)
   (var RadarSignatureModel commonType)

   (rule new-model
   {
      (new_replace (subtype modelTypes commonType) (type modelType MULTIRESOLUTION_RADAR_SIGNATURE_MODEL)) [apply($$)]
         <RadarSignatureModel>*
      end_model
   })
{
   fidelity <real>
 | model (typeref modelTypes) (load (subtype modelTypes $1)) [apply($$)] <RadarSignatureModel>* end_model # Implicit edit
 | model <string> <new-model> (new (subtype modelTypes $1) (subtype modelTypes commonType)) # Implicit add
 | add model <string> <new-model> (new (subtype modelTypes $2) (subtype modelTypes commonType))
 | edit model (typeref modelTypes) (load (subtype modelTypes $2)) [apply($$)] <RadarSignatureModel>* end_model
 | common (load (subtype modelTypes commonType radar_signature)) <TypeCommand>* end_common # Just check w/ last loaded type
 | <wsfobject-command>
})

(struct WSF_MULTIRESOLUTION_RADAR_SIGNATURE
   :symbol (type multiresolutionRadarSignatureType WSF_MULTIRESOLUTION_RADAR_SIGNATURE)
   :base_type MultiresolutionRadarSignature
{
   <MultiresolutionRadarSignature>
})
