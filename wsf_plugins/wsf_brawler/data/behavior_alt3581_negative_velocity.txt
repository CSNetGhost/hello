# ****************************************************************************
# CUI//REL TO USA ONLY
#
# The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
#
# The use, dissemination or disclosure of data in this file is subject to
# limitation or restriction. See accompanying README and LICENSE for details.
# ****************************************************************************

// converted BRAWLER v7.5 alt35.f
// Replicates the negative velocity 3,5,8,1 alternative behavior

include_once BrawlerScriptUtil.txt

behavior alt3581_negative_velocity

   script_debug_writes off

   script_variables

      WsfBrawlerProcessor BRAWLER;
      WsfPerceptionProcessor    perception;

      //**********************************************************************//
      //** debugging parameters                                             **//
      //**********************************************************************//
      bool     mDrawSteering     = false;

      //**********************************************************************//
      //** alternative parameters                                           **//
      //**********************************************************************//
      // Flag used to enable/disable this alternative
      bool mAlternative3581Enabled = true;
      bool mCheckBoresight = true;
      bool mCheckRange = true;

      // Alternative ID
      int ilevel = 3;
      int kalt   = 5;
      int icall  = 8;
      int lcall  = 1;

      // Maneuver Alternative flight values
      Vec3 mDir0;
      double mGMX = 1.0;
      double mSpd0 = 3.0;

      //**********************************************************************//
      //********* VARIABLES BELOW THIS LINE ARE NOT FOR USER EDITING *********//
      //**********************************************************************//
      WsfDraw  mDraw             = WsfDraw();
      double   mLastTime         = 0.0;

   end_script_variables

   on_init

      perception = (WsfPerceptionProcessor)PLATFORM.Processor("perception");
      BRAWLER = (WsfBrawlerProcessor)PROCESSOR;
   end_on_init

   precondition
      #writeln_d(PLATFORM.Name(), " precondition behavior_alt3581_negative_velocity, T=", TIME_NOW);

      ### Evaluate conditions that would prevent behavior alternative from running

      if (!PROCESSOR.IsA_TypeOf("WSF_BRAWLER_PROCESSOR"))
      {
         writeln_d("not a brawler processor!");
         return Failure("behavior not attached to a WSF_BRAWLER_PROCESSOR");
      }

      if (!mAlternative3581Enabled)
      {
         writeln_d("behavior not enabled!");
         return Failure("behavior alternative not enabled");
      }

      WsfTaskList tasks = BRAWLER.TasksReceivedOfType("WEAPON");
      if(tasks.Count() <= 0)
      {
         return Failure("no weapon (hostile) tasks!");
      }
      WsfTask targetTask = tasks.Entry(0);
      WsfLocalTrack hostile = PLATFORM.MasterTrackList().Find(targetTask.LocalTrackId());
      if (!hostile.IsValid())
      {
         return Failure("no hostile track!");
      }

      //TODO - change this script so it doesn't use a truth method?
      if (hostile.TargetKilled())
      {
         return Failure("hostile was destroyed!");
      }

      // alt35.f line 282 - 285
#      if(spdut(iac).eq.0.0)goto 205
#      if(obang(iac,me).gt.hafpi) go to 205
#      rrunmn = 5.*ramp(twopi,obang(iac,me)+obang(me,iac),0.)  <- same as 3551
#      if(rngun(iac)*ftnmi .gt. rrunmn+1.) go to 205

      if (!hostile.VelocityValid() || (hostile.Speed()*MATH.FT_PER_M()) < 1)
      {
         // If we don't have valid velocity or spoed is effectively zero
         string msg = write_str("T=",TIME_NOW,", alt ", ilevel, kalt, icall, lcall, " hostile has invalid or no speed");
         writeln_d(msg);
         return Failure(msg);
      }

      double obang_hostile_me = BRAWLER.OffBoresightAngle(hostile.Target(), PLATFORM);
      double obang_me_hostile = BRAWLER.OffBoresightAngle(PLATFORM, hostile.Target());

      if (mCheckBoresight == true && obang_hostile_me > Math.PI_OVER_2())
      {
         // Not ahead of hostile
         string msg = write_str("T=",TIME_NOW,", alt ", ilevel, kalt, icall, lcall, " off boresight angle hostile to me > Pi/2");
         writeln_d(msg);
         return Failure(msg);
      }

      double rrunmn = 5.0 * ramp(Math.TWO_PI(), obang_hostile_me + obang_me_hostile, 0.0);
      double projectionTime = TIME_NOW + BRAWLER.ProjectedTimeDelta();
      WsfGeoPoint projectedHostileLocation = hostile.LocationAtTime(projectionTime);
      double rangeToHostile = PLATFORM.SlantRangeTo(projectedHostileLocation);
      if (mCheckRange == true && rangeToHostile * Math.M_PER_NM() < rrunmn + 1.0)
      {
         // Hostile too far
         string msg = write_str("T=",TIME_NOW,", alt ", ilevel, kalt, icall, lcall, " range to hostile < minimum range to run");
         writeln_d(msg);
         return Failure(msg);
      }

      // ALL CONDITIONS PASS
      ### Generate Maneuver Alternative
      // alt35.f line 286 - 292
#      iactn = 4
#      lenalt = lactn(iactn)
#      altdsc = altpk(3,5,icall,1,iacidt(iac),0)
#      call vmake(-1.,veut(1,iac),dir0)
#      gmx = gmxsu
#      spd0 = 3.
#      spdmod = thrttl
      mDir0 = vmake(-1.0, hostile.VelocityNED());
      mGMX = BRAWLER.MaxSustainedGs();
      mSpd0 = 3.0;

      ### Evaluate [Projected] Maneuver Alternative
      double score = BRAWLER.EvaluateVectorWithThrottle(mDir0, mGMX, mSpd0, ilevel, kalt, icall, lcall);
      return score;

   end_precondition


   execute
      ## what was evaluated should be actually performed now
      PLATFORM.FlyVectorWithThrottle(mDir0, mGMX, mSpd0);
   end_execute

end_behavior

