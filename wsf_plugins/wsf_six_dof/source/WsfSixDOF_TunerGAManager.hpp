// ****************************************************************************
// CUI
//
// The Advanced Framework for Simulation, Integration, and Modeling (AFSIM)
//
// Copyright 2020 Infoscitex, a DCS Company. All rights reserved.
//
// The use, dissemination or disclosure of data in this file is subject to
// limitation or restriction. See accompanying README and LICENSE for details.
// ****************************************************************************

#ifndef WSFSIXDOFTUNERGAMANAGER_HPP
#define WSFSIXDOFTUNERGAMANAGER_HPP

#include "wsf_six_dof_export.h"

#include <vector>

#include "UtRandom.hpp"
#include "WsfSixDOF_TunerGASpecimen.hpp"

namespace wsf
{
namespace six_dof
{
class WSF_SIX_DOF_EXPORT TunerGAManager
{
public:
   TunerGAManager() = default;

   void Advance(std::vector<TunerGASpecimen::PidLogElement>& aSimData);

   // Set the number of specimens in each population.
   void   SetPopulationSize(size_t aPopulationSize) { mPopulationSize = aPopulationSize; }
   size_t GetPopulationSize() const { return mPopulationSize; }

   // Set total number of generations to use in optimizations.
   void   SetMaxGenerationCount(size_t aMaxGenCount) { mMaxGenerations = aMaxGenCount; }
   size_t GetMaxGenerationCount() const { return mMaxGenerations; }

   // Set the ratio of specimens in the population that will be carried over to the next generation.
   // Value is clamped between 0.0 and 1.0. Recommend values above 0.7 to make sure that enough "fit"
   // specimens survive into the next generation. The remaining population that is not carried over is
   // randomly generated to expand the search area.
   void   SetCarryOverFraction(double aCarryOverFrac);
   double GetCarryOverFraction() const { return mCarryOverFraction; }

   // Sets the probability that a single "gene" in a specimen chromosome will spontaneously mutate.
   // Value is clamped between 0.0 and 1.0. Recommend values between 0.02 and 0.1. Mutation expands
   // search space by creating changes in existing specimens.
   void   SetMutationProbability(double aMutProb);
   double GetMutationProbability() const { return mMutationProbability; }

   // Set the probability that two specimens will be "crossed" exchanging elements of their
   // chromosomes. Value is clamped between 0.0 and 1.0. Recommend value between 0.5 and 0.8.
   // Crossover takes traits from 2 specimens and swaps them in an attempt to create a superior
   // specimen.
   void   SetCrossOverProbability(double aCrossOverProb);
   double GetCrossOverProbability() const { return mCrossOverProbability; }

   // Creates population by copying parent specimen. Specimen limits are preserved,
   // but their traits are generated by calling each specimen's Generate() method.
   void InitializePopulation(const TunerGASpecimen& aSpecimen);

   bool IsComplete() const { return mCompleted; }

   TunerGASpecimen GetOptimum() const { return mOptimum; }

   TunerGASpecimen& GetCurrentSpecimen() { return mPopulation[mCurrentSpecimen]; }

   size_t GetProgress() const { return mCurrentSpecimen + mCurrentGeneration * mPopulationSize; }

private:
   // Chose next population based on objective values and the carry over fraction.
   void SelectNextPopulation();

   size_t mPopulationSize       = 25;
   size_t mMaxGenerations       = 50;
   double mCarryOverFraction    = 1.0;
   double mMutationProbability  = 0.02;
   double mCrossOverProbability = 0.7;

   size_t mCurrentSpecimen   = 0;
   size_t mCurrentGeneration = 0;

   bool mCompleted = false;

   std::vector<TunerGASpecimen> mPopulation;

   TunerGASpecimen mParentSpecimen;
   TunerGASpecimen mOptimum;

   ut::Random mRandom;
};
} // namespace six_dof
} // namespace wsf

#endif
